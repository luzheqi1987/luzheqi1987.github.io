<!doctype html>



  



<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="jerkybible, 行走的轮子, java, c, c++, python, ruby, sicp, hexo, next, spring, ffmpeg, blog, qt, opencv, 博客, 音频, 视频, 编码, 解码, 编解码, 迁移, 轮子, 转" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="戒急用忍">
<meta property="og:type" content="website">
<meta property="og:title" content="行走的轮子">
<meta property="og:url" content="http://blog.jerkybible.com/page/4/index.html">
<meta property="og:site_name" content="行走的轮子">
<meta property="og:description" content="戒急用忍">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="行走的轮子">
<meta name="twitter:description" content="戒急用忍">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    },
    algolia: {
          applicationID: 'TQAF9AT4MZ',
          apiKey: '91f27cce56682c2525b0f9fbb867111a',
          indexName: 'hexoblog',
          hits: {"per_page":10},
          labels: {"input_placeholder":"搜索...","hits_empty":"未发现与 「${query}」相关的内容","hits_stats":"${hits} 条相关条目，使用了 ${time} 毫秒"}
    }
  };
</script>




  <link rel="canonical" href="http://blog.jerkybible.com/page/4/"/>

  <title> 行走的轮子 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?0dec9769c21972aef79776299d7801d0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">行走的轮子</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">戒急用忍</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-visited">
          <a href="/visited" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            到此一游
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>
    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/27/深入解析MySQL分区（Partition）功能/" itemprop="url">
                  深入解析MySQL分区（Partition）功能
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-27T09:15:01+08:00" content="2015-04-27">
              2015-04-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/27/深入解析MySQL分区（Partition）功能/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/27/深入解析MySQL分区（Partition）功能/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2015/04/27/深入解析MySQL分区（Partition）功能/" class="leancloud_visitors" data-flag-title="深入解析MySQL分区（Partition）功能">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <!-- <span class="post-meta-item-text">阅读次数 </span> -->
               <span class="post-meta-item-text">❤ </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Mysql自5.1开始对分区(Partition)有支持</p>
<p>= 水平分区（根据列属性按行分）=<br>举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。</p>
<p>=== 水平分区的几种模式：===</p>
<ul>
<li><p>Range（范围） – 这种模式允许DBA将数据划分不同范围。例如DBA可以将一个表通过年份划分成三个分区，80年代（1980’s）的数据，90年代（1990’s）的数据以及任何在2000年（包括2000年）后的数据。 </p>
</li>
<li><p>Hash（哈希） – 这中模式允许DBA通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区，。例如DBA可以建立一个对表主键进行分区的表。 </p>
</li>
<li><p>Key（键值） – 上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。 </p>
</li>
<li><p>List（预定义列表） – 这种模式允许系统通过DBA定义的列表的值所对应的行数据进行分割。例如：DBA建立了一个横跨三个分区的表，分别根据2004年2005年和2006年值所对应的数据。 </p>
</li>
<li><p>Composite（复合模式） - 很神秘吧，哈哈，其实是以上模式的组合使用而已，就不解释了。举例：在初始化已经进行了Range范围分区的表上，我们可以对其中一个分区再进行hash哈希分区。 </p>
</li>
</ul>
<p>= 垂直分区（按列分）=<br>举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</p>
<p>[分区表和未分区表试验过程]</p>
<p>*创建分区表,按日期的年份拆分<br>[sql]<br>CREATE TABLE part_tab ( c1 int default NULL, c2 varchar(30) default NULL, c3 date default NULL) engine=myisam<br>PARTITION BY RANGE (year(c3)) (PARTITION p0 VALUES LESS THAN (1995),<br>PARTITION p1 VALUES LESS THAN (1996) , PARTITION p2 VALUES LESS THAN (1997) ,<br>PARTITION p3 VALUES LESS THAN (1998) , PARTITION p4 VALUES LESS THAN (1999) ,<br>PARTITION p5 VALUES LESS THAN (2000) , PARTITION p6 VALUES LESS THAN (2001) ,<br>PARTITION p7 VALUES LESS THAN (2002) , PARTITION p8 VALUES LESS THAN (2003) ,<br>PARTITION p9 VALUES LESS THAN (2004) , PARTITION p10 VALUES LESS THAN (2010),<br>PARTITION p11 VALUES LESS THAN MAXVALUE );  [/sql]<br>注意最后一行，考虑到可能的最大值</p>
<p>*创建未分区表<br>[sql]<br>mysql&gt; create table no_part_tab (c1 int(11) default NULL,c2 varchar(30) default NULL,c3 date default NULL) engine=myisam;<br>[/sql]</p>
<p><em>通过存储过程灌入800万条测试数据<br>mysql&gt; set sql_mode=’’; /</em> 如果创建存储过程失败，则先需设置此变量, bug? <em>/<br>mysql&gt; delimiter //   /</em> 设定语句终结符为 //，因存储过程语句用;结束 */</p>
<p>[sql]<br>mysql&gt; CREATE PROCEDURE load_part_tab()<br>       begin<br>    declare v int default 0;<br>    while v &lt; 8000000<br>    do<br>        insert into part_tab<br>        values (v,’testing partitions’,adddate(‘1995-01-01’,(rand(v)<em>36520) mod 3652));<br>         set v = v + 1;<br>    end while;<br>    end<br>    //<br>mysql&gt; delimiter ;<br>mysql&gt; call load_part_tab();<br>Query OK, 1 row affected (8 min 17.75 sec)<br>[sql] view plaincopy<br>mysql&gt; insert into no_part_tab select </em> from part_tab;<br>Query OK, 8000000 rows affected (51.59 sec)<br>Records: 8000000 Duplicates: 0 Warnings: 0<br>[/sql]</p>
<ul>
<li>测试SQL性能</li>
</ul>
<p>[sql]<br>mysql&gt; select count(<em>) from part_tab where c3 &gt; date ‘1995-01-01’ and c3 &lt; date ‘1995-12-31’;<br>+———-+<br>| count(</em>) |<br>+———-+<br>|   795181 |<br>+———-+<br>1 row in set (0.55 sec)<br>[/sql]</p>
<p>[sql]<br>mysql&gt; select count(<em>) from no_part_tab where c3 &gt; date ‘1995-01-01’ and c3 &lt; date ‘1995-12-31’;<br>+———-+<br>| count(</em>) |<br>+———-+<br>|   795181 |<br>+———-+<br>1 row in set (4.69 sec)[/sql]<br>结果表明分区表比未分区表的执行时间少90%。</p>
<ul>
<li>通过explain语句来分析执行情况<br>[sql]<br>mysql &gt; explain select count(<em>) from no_part_tab where c3 &gt; date ‘1995-01-01’ and c3 &lt; date ‘1995-12-31’\G<br>/</em> 结尾的\G使得mysql的输出改为列模式 <em>/<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong><pre><code>id: 1
</code></pre>select_type: SIMPLE<pre><code>table: no_part_tab
 type: ALL
</code></pre>possible_keys: NULL<pre><code>    key: NULL
key_len: NULL
    ref: NULL
   rows: 8000000
  Extra: Using where
</code></pre>1 row in set (0.00 sec)<br>[/sql]</li>
</ul>
<p>[sql]<br>mysql&gt; explain select count(<em>) from part_tab where c3 &gt; date ‘1995-01-01’ and c3 &lt; date ‘1995-12-31’\G<br><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong><br>           id: 1<br>select_type: SIMPLE<br>        table: part_tab<br>         type: ALL<br>possible_keys: NULL<br>          key: NULL<br>      key_len: NULL<br>          ref: NULL<br>         rows: 798458<br>        Extra: Using where<br>1 row in set (0.00 sec)[/sql]<br>explain语句显示了SQL查询要处理的记录数目</p>
<ul>
<li><p>试验创建索引后情况<br>[sql]<br>mysql&gt; create index idx_of_c3 on no_part_tab (c3);<br>Query OK, 8000000 rows affected (1 min 18.08 sec)<br>Records: 8000000 Duplicates: 0 Warnings: 0<br>[/sql]<br>[sql]<br>mysql&gt; create index idx_of_c3 on part_tab (c3);<br>Query OK, 8000000 rows affected (1 min 19.19 sec)<br>Records: 8000000 Duplicates: 0 Warnings: 0[/sql]<br>创建索引后的数据库文件大小列表：<br>2008-05-24 09:23             8,608 no_part_tab.frm<br>2008-05-24 09:24       255,999,996 no_part_tab.MYD<br>2008-05-24 09:24        81,611,776 no_part_tab.MYI<br>2008-05-24 09:25                 0 part_tab#P#p0.MYD<br>2008-05-24 09:26             1,024 part_tab#P#p0.MYI<br>2008-05-24 09:26        25,550,656 part_tab#P#p1.MYD<br>2008-05-24 09:26         8,148,992 part_tab#P#p1.MYI<br>2008-05-24 09:26        25,620,192 part_tab#P#p10.MYD<br>2008-05-24 09:26         8,170,496 part_tab#P#p10.MYI<br>2008-05-24 09:25                 0 part_tab#P#p11.MYD<br>2008-05-24 09:26             1,024 part_tab#P#p11.MYI<br>2008-05-24 09:26        25,656,512 part_tab#P#p2.MYD<br>2008-05-24 09:26         8,181,760 part_tab#P#p2.MYI<br>2008-05-24 09:26        25,586,880 part_tab#P#p3.MYD<br>2008-05-24 09:26         8,160,256 part_tab#P#p3.MYI<br>2008-05-24 09:26        25,585,696 part_tab#P#p4.MYD<br>2008-05-24 09:26         8,159,232 part_tab#P#p4.MYI<br>2008-05-24 09:26        25,585,216 part_tab#P#p5.MYD<br>2008-05-24 09:26         8,159,232 part_tab#P#p5.MYI<br>2008-05-24 09:26        25,655,740 part_tab#P#p6.MYD<br>2008-05-24 09:26         8,181,760 part_tab#P#p6.MYI<br>2008-05-24 09:26        25,586,528 part_tab#P#p7.MYD<br>2008-05-24 09:26         8,160,256 part_tab#P#p7.MYI<br>2008-05-24 09:26        25,586,752 part_tab#P#p8.MYD<br>2008-05-24 09:26         8,160,256 part_tab#P#p8.MYI<br>2008-05-24 09:26        25,585,824 part_tab#P#p9.MYD<br>2008-05-24 09:26         8,159,232 part_tab#P#p9.MYI<br>2008-05-24 09:25             8,608 part_tab.frm<br>2008-05-24 09:25                68 part_tab.par</p>
</li>
<li><p>再次测试SQL性能</p>
</li>
</ul>
<p>[sql]<br>mysql&gt; select count(<em>) from no_part_tab where c3 &gt; date ‘1995-01-01’ and c3 &lt; date ‘1995-12-31’;<br>+———-+<br>| count(</em>) |<br>+———-+<br>|   795181 |<br>+———-+<br>1 row in set (2.42 sec)   /<em> 为原来4.69 sec 的51%</em>/<br>[/sql]</p>
<p>重启mysql ( net stop mysql, net start mysql)后，查询时间降为0.89 sec,几乎与分区表相同。</p>
<p>[sql]<br>mysql&gt; select count(<em>) from part_tab where c3 &gt; date ‘1995-01-01’ and c3 &lt; date ‘1995-12-31’;<br>+———-+<br>| count(</em>) |<br>+———-+<br>|   795181 |<br>+———-+<br>1 row in set (0.86 sec)<br>[/sql]</p>
<ul>
<li>更进一步的试验<br><em>* 增加日期范围<br>[sql]<br>mysql&gt; select count(</em>) from no_part_tab where c3 &gt; date ‘1995-01-01’ and c3 &lt; date ‘1997-12-31’;<br>+———-+<br>| count(<em>) |<br>+———-+<br>| 2396524 |<br>+———-+<br>1 row in set (5.42 sec)<br>[/sql]<br>[sql]<br>mysql&gt; select count(</em>) from part_tab where c3 &gt; date ‘1995-01-01’ and c3 &lt; date ‘1997-12-31’;<br>+———-+<br>| count(*) |<br>+———-+<br>| 2396524 |<br>+———-+<br>1 row in set (2.63 sec)<br>[/sql]</li>
</ul>
<p><em>* 增加未索引字段查询<br>[sql]<br>mysql&gt; select count(</em>) from part_tab where c3 &gt; date ‘1995-01-01’ and c3 &lt; date<br>‘1996-12-31’ and c2=’hello’;<br>+———-+<br>| count(<em>) |<br>+———-+<br>|        0 |<br>+———-+<br>1 row in set (0.75 sec)<br>[/sql]<br>[sql]<br>mysql&gt; select count(</em>) from no_part_tab where c3 &gt; date ‘1995-01-01’ and c3 &lt; date ‘1996-12-31’ and c2=’hello’;<br>+———-+<br>| count(*) |<br>+———-+<br>|        0 |<br>+———-+<br>1 row in set (11.52 sec)<br>[/sql]</p>
<p>= 初步结论 =</p>
<ul>
<li>分区和未分区占用文件空间大致相同 （数据和索引文件）</li>
<li>如果查询语句中有未建立索引字段，分区时间远远优于未分区时间</li>
<li>如果查询语句中字段建立了索引，分区和未分区的差别缩小，分区略优于未分区。</li>
</ul>
<p>= 最终结论 =</p>
<ul>
<li>对于大数据量，建议使用分区功能。</li>
<li>去除不必要的字段</li>
<li>根据手册， 增加myisam_max_sort_file_size 会增加分区性能</li>
</ul>
<p>[分区命令详解]</p>
<p>= 分区例子 = </p>
<ul>
<li><p>RANGE 类型<br>[sql]<br>CREATE TABLE users (  </p>
<pre><code>uid INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,  
name VARCHAR(30) NOT NULL DEFAULT &apos;&apos;,  
email VARCHAR(30) NOT NULL DEFAULT &apos;&apos;  
</code></pre><p>)<br>PARTITION BY RANGE (uid) (  </p>
<pre><code>PARTITION p0 VALUES LESS THAN (3000000)  
DATA DIRECTORY = &apos;/data0/data&apos;  
INDEX DIRECTORY = &apos;/data1/idx&apos;,  

PARTITION p1 VALUES LESS THAN (6000000)  
DATA DIRECTORY = &apos;/data2/data&apos;  
INDEX DIRECTORY = &apos;/data3/idx&apos;,  

PARTITION p2 VALUES LESS THAN (9000000)  
DATA DIRECTORY = &apos;/data4/data&apos;  
INDEX DIRECTORY = &apos;/data5/idx&apos;,  

PARTITION p3 VALUES LESS THAN MAXVALUE     DATA DIRECTORY = &apos;/data6/data&apos;   
INDEX DIRECTORY = &apos;/data7/idx&apos;  
</code></pre><p>);  [/sql]<br>在这里，将用户表分成4个分区，以每300万条记录为界限，每个分区都有自己独立的数据、索引文件的存放目录，与此同时，这些目录所在的物理磁盘分区可能也都是完全独立的，可以提高磁盘IO吞吐量。</p>
</li>
<li><p>LIST 类型<br>[sql]<br>CREATE TABLE category (<br>   cid INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,<br>   name VARCHAR(30) NOT NULL DEFAULT ‘’<br>)<br>PARTITION BY LIST (cid) (<br>   PARTITION p0 VALUES IN (0,4,8,12)<br>   DATA DIRECTORY = ‘/data0/data’<br>   INDEX DIRECTORY = ‘/data1/idx’,  </p>
<p>   PARTITION p1 VALUES IN (1,5,9,13)<br>   DATA DIRECTORY = ‘/data2/data’<br>   INDEX DIRECTORY = ‘/data3/idx’,  </p>
<p>   PARTITION p2 VALUES IN (2,6,10,14)<br>   DATA DIRECTORY = ‘/data4/data’<br>   INDEX DIRECTORY = ‘/data5/idx’,  </p>
<p>   PARTITION p3 VALUES IN (3,7,11,15)<br>   DATA DIRECTORY = ‘/data6/data’<br>   INDEX DIRECTORY = ‘/data7/idx’<br>);    [/sql]<br>分成4个区，数据文件和索引文件单独存放。</p>
</li>
<li><p>HASH 类型<br>[sql]<br>CREATE TABLE users (<br>   uid INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,<br>   name VARCHAR(30) NOT NULL DEFAULT ‘’,<br>   email VARCHAR(30) NOT NULL DEFAULT ‘’<br>)<br>PARTITION BY HASH (uid) PARTITIONS 4 (<br>   PARTITION p0<br>   DATA DIRECTORY = ‘/data0/data’<br>   INDEX DIRECTORY = ‘/data1/idx’,  </p>
<p>   PARTITION p1<br>   DATA DIRECTORY = ‘/data2/data’<br>   INDEX DIRECTORY = ‘/data3/idx’,  </p>
<p>   PARTITION p2<br>   DATA DIRECTORY = ‘/data4/data’<br>   INDEX DIRECTORY = ‘/data5/idx’,  </p>
<p>   PARTITION p3<br>   DATA DIRECTORY = ‘/data6/data’<br>   INDEX DIRECTORY = ‘/data7/idx’<br>);  [/sql]<br>分成4个区，数据文件和索引文件单独存放。</p>
</li>
</ul>
<p>例子：<br>[sql]<br>CREATE TABLE ti2 (id INT, amount DECIMAL(7,2), tr_date DATE)<br>    ENGINE=myisam<br>    PARTITION BY HASH( MONTH(tr_date) )<br>    PARTITIONS 6;  </p>
<p>CREATE PROCEDURE load_ti2()<br>       begin<br>    declare v int default 0;<br>    while v &lt; 80000<br>    do<br>        insert into ti2<br>        values (v,’3.14’,adddate(‘1995-01-01’,(rand(v)*3652) mod 365));<br>         set v = v + 1;<br>    end while;<br>    end<br>    //<br>[/sql]</p>
<ul>
<li><p>KEY 类型<br>[sql]<br>CREATE TABLE users (<br>   uid INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,<br>   name VARCHAR(30) NOT NULL DEFAULT ‘’,<br>   email VARCHAR(30) NOT NULL DEFAULT ‘’<br>)<br>PARTITION BY KEY (uid) PARTITIONS 4 (<br>   PARTITION p0<br>   DATA DIRECTORY = ‘/data0/data’<br>   INDEX DIRECTORY = ‘/data1/idx’,  </p>
<p>   PARTITION p1<br>   DATA DIRECTORY = ‘/data2/data’<br>   INDEX DIRECTORY = ‘/data3/idx’,  </p>
<p>   PARTITION p2<br>   DATA DIRECTORY = ‘/data4/data’<br>   INDEX DIRECTORY = ‘/data5/idx’,  </p>
<p>   PARTITION p3<br>   DATA DIRECTORY = ‘/data6/data’<br>   INDEX DIRECTORY = ‘/data7/idx’<br>); [/sql]<br>分成4个区，数据文件和索引文件单独存放。</p>
</li>
<li><p>子分区<br>子分区是针对 RANGE/LIST 类型的分区表中每个分区的再次分割。再次分割可以是 HASH/KEY 等类型。例如：<br>[sql]<br>CREATE TABLE users (<br>   uid INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,<br>   name VARCHAR(30) NOT NULL DEFAULT ‘’,<br>   email VARCHAR(30) NOT NULL DEFAULT ‘’<br>)<br>PARTITION BY RANGE (uid) SUBPARTITION BY HASH (uid % 4) SUBPARTITIONS 2(<br>   PARTITION p0 VALUES LESS THAN (3000000)<br>   DATA DIRECTORY = ‘/data0/data’<br>   INDEX DIRECTORY = ‘/data1/idx’,  </p>
<p>   PARTITION p1 VALUES LESS THAN (6000000)<br>   DATA DIRECTORY = ‘/data2/data’<br>   INDEX DIRECTORY = ‘/data3/idx’<br>);  [/sql]<br>对 RANGE 分区再次进行子分区划分，子分区采用 HASH 类型。<br>或者<br>[sql]<br>CREATE TABLE users (<br>   uid INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,<br>   name VARCHAR(30) NOT NULL DEFAULT ‘’,<br>   email VARCHAR(30) NOT NULL DEFAULT ‘’<br>)<br>PARTITION BY RANGE (uid) SUBPARTITION BY KEY(uid) SUBPARTITIONS 2(<br>   PARTITION p0 VALUES LESS THAN (3000000)<br>   DATA DIRECTORY = ‘/data0/data’<br>   INDEX DIRECTORY = ‘/data1/idx’,  </p>
<p>   PARTITION p1 VALUES LESS THAN (6000000)<br>   DATA DIRECTORY = ‘/data2/data’<br>   INDEX DIRECTORY = ‘/data3/idx’<br>);  [/sql]<br>对 RANGE 分区再次进行子分区划分，子分区采用 KEY 类型。</p>
</li>
</ul>
<p>= 分区管理 =</p>
<pre><code>* 删除分区  
</code></pre><p>[sql]<br>ALERT TABLE users DROP PARTITION p0;  [/sql]<br>      删除分区 p0。</p>
<pre><code>* 重建分区
      o RANGE 分区重建
</code></pre><p>[sql]<br>ALTER TABLE users REORGANIZE PARTITION p0,p1 INTO (PARTITION p0 VALUES LESS THAN (6000000));  [/sql]<br>            将原来的 p0,p1 分区合并起来，放到新的 p0 分区中。<br>          o LIST 分区重建<br>[sql]<br>ALTER TABLE users REORGANIZE PARTITION p0,p1 INTO (PARTITION p0 VALUES IN(0,1,4,5,8,9,12,13));  [/sql]<br>            将原来的 p0,p1 分区合并起来，放到新的 p0 分区中。<br>          o HASH/KEY 分区重建<br>[sql]<br>ALTER TABLE users REORGANIZE PARTITION COALESCE PARTITION 2;  [/sql]<br>            用 REORGANIZE 方式重建分区的数量变成2，在这里数量只能减少不能增加。想要增加可以用 ADD PARTITION 方法。</p>
<pre><code>* 新增分区
      o 新增 RANGE 分区   
</code></pre><p>[sql]<br>ALTER TABLE category ADD PARTITION (PARTITION p4 VALUES IN (16,17,18,19)<br>           DATA DIRECTORY = ‘/data8/data’<br>           INDEX DIRECTORY = ‘/data9/idx’);  [/sql]<br>            新增一个RANGE分区。<br>          o 新增 HASH/KEY 分区<br>[sql]<br>ALTER TABLE users ADD PARTITION PARTITIONS 8;  [/sql]<br>            将分区总数扩展到8个。</p>
<p>[ 给已有的表加上分区 ]<br>[sql]<br>alter table results partition by RANGE (month(ttime))<br>(PARTITION p0 VALUES LESS THAN (1),<br>PARTITION p1 VALUES LESS THAN (2) , PARTITION p2 VALUES LESS THAN (3) ,<br>PARTITION p3 VALUES LESS THAN (4) , PARTITION p4 VALUES LESS THAN (5) ,<br>PARTITION p5 VALUES LESS THAN (6) , PARTITION p6 VALUES LESS THAN (7) ,<br>PARTITION p7 VALUES LESS THAN (8) , PARTITION p8 VALUES LESS THAN (9) ,<br>PARTITION p9 VALUES LESS THAN (10) , PARTITION p10 VALUES LESS THAN (11),<br>PARTITION p11 VALUES LESS THAN (12),<br>PARTITION P12 VALUES LESS THAN (13) );   [/sql]</p>
<p>默认分区限制分区字段必须是主键（PRIMARY KEY)的一部分，为了去除此<br>限制：<br>[方法1] 使用ID<br>[sql]<br>mysql&gt; ALTER TABLE np_pk<br>    -&gt;     PARTITION BY HASH( TO_DAYS(added) )<br>    -&gt;     PARTITIONS 4;<br>ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table’s partitioning function<br>[/sql]<br>However, this statement using the id column for the partitioning column is valid, as shown here:</p>
<p>[sql]<br>mysql&gt; ALTER TABLE np_pk<br>    -&gt;     PARTITION BY HASH(id)<br>    -&gt;     PARTITIONS 4;<br>Query OK, 0 rows affected (0.11 sec)<br>Records: 0 Duplicates: 0 Warnings: 0<br>[/sql]<br>[方法2] 将原有PK去掉生成新PK<br>[sql]<br>mysql&gt; alter table results drop PRIMARY KEY;<br>Query OK, 5374850 rows affected (7 min 4.05 sec)<br>Records: 5374850 Duplicates: 0 Warnings: 0<br>[/sql]<br>[sql]<br>mysql&gt; alter table results add PRIMARY KEY(id, ttime);<br>Query OK, 5374850 rows affected (6 min 14.86 sec)<br>Records: 5374850 Duplicates: 0 Warnings: 0<br>[/sql]</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/22/Linux 面试/" itemprop="url">
                  Linux 面试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-22T14:02:42+08:00" content="2015-04-22">
              2015-04-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/Interview/" itemprop="url" rel="index">
                    <span itemprop="name">Interview</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/22/Linux 面试/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/22/Linux 面试/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2015/04/22/Linux 面试/" class="leancloud_visitors" data-flag-title="Linux 面试">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <!-- <span class="post-meta-item-text">阅读次数 </span> -->
               <span class="post-meta-item-text">❤ </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1. linux文件系统都有三个身份Owner, group, others， 每种身份都有r，w，x三种权限。<br>2. /etc/passwd 存有系统的用户信息，/etc/shadow存有用户的密码，/etc/group 存有组的情况。<br>3. 更改权限的三个命令：chmod, chgrp, chown<br>对于文件来说：r–读取文件内容；w–编辑、新增文件（不可删除）；x-可执行<br>umask 决定新建文件或文件夹的权限，显示的值为需要去掉的权限<br>对于目录来说：r–使用ls查看目录文件；w–创建、删除、移动、重命名文件；x-可使用cd切换目录<br>4. /sbin/service, /sbin/ifconfig默认状况下只有root用户才能直接使用<br>5.路径：. ， .. ，~<br>6. 目录有关的操作：cd，pwd，mkdir， rmdir<br>7.文件操作：ls，cp，rm，mv，touch<br>8.文件查阅：cat/tac， nl，more，less。head，tail<br>9.查看文件类型：file<br>10.查找脚本：which 查找文件名： whereis， locate， find<br>find -name -type -user -exec ls  {} \;<br>11. 添加用户useradd；用户组groupadd<br>用户查询：w/who 用户通讯：mesg，write，wall<br>批量添加用户和密码：useradd user；echo user | passwd –stdin user<br>12. 磁盘有关命令：df/du 查看磁盘； fdisk -l查看磁盘分区；fsck系统检查；mount挂载磁盘，新建目录，挂载磁盘分区；umount卸载磁盘<br>13. 打包 tar -czvf， 解压tar -xzvf<br>14.Vim编辑器使用<br>15.正则表达式和grep<br>16. awk，sed<br>17. Shell脚本<br>18.程序管理：<br>查看 进程 ps -ef | grep pname ps aux<br>后台运行&amp;<br>后台暂停：ctr+z<br>查看后台进程： jobs -l<br>恢复前台 fg %jobnumber<br>后台运行：bg %jobnumber<br>脱机运行：nohup<br>查看动态进程：top<br>强制杀死进程：kill -9 pid<br>19. 查看内存： free -m；查看内核：uname -a；跟踪网络 netstat -a -tlnp<br>20. /etc/init.d/<em> 系统启动脚本<br>     /etc/</em>  系统配置<br>     /var/lib/* 各服务产生的数据库<br>     service name start/stop/restart/status<br>     chkconfig –list –add 开机启动 防火墙 iptables<br>     /var/log 系统日志文件<br>21. 软件安装：rqm -ivh | -aq| -e ；yum install </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/22/vim下ctags使用/" itemprop="url">
                  vim下ctags使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-22T14:01:23+08:00" content="2015-04-22">
              2015-04-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/22/vim下ctags使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/22/vim下ctags使用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2015/04/22/vim下ctags使用/" class="leancloud_visitors" data-flag-title="vim下ctags使用">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <!-- <span class="post-meta-item-text">阅读次数 </span> -->
               <span class="post-meta-item-text">❤ </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1. cd to the root directory of your code:<br>2.Run Ctags recursively over the entire code to generate the tags file<br>ctags -R *<br>3. To search for a specific tag and open Vim to its definition, run the following command in your shell:<br>vim -t <tag><br>4. Or, open any Linux source file in Vim and use the following basic commands:<br>Ctrl-] Jump to the tag underneath the cursor<br>:ts <tag> <ret> Search for a particular tag<br>:tn Go to the next definition for the last tag<br>:tp Go to the previous definition for the last tag<br>:ts List all of the definitions of the last tag<br>Ctrl-t Jump back up in the tag stack<br>The first command is probably the one you will use most often: it jumps to the definition of the tag (function name, structure name, variable name, or pretty much anything) under the cursor. The second command can be used to search for any tag, regardless of the file that is currently opened. If there are multiple definitions/uses for a particular tag, the tn and tp commands can be used to scroll through them, and the ts command can be used to “search” a list for the definition you want (useful when there are dozens or hundreds of definitions for some commonly-used struct). Finally, the last command is used to jump back up in the tag stack to the location you initiated the previous tag search from.</ret></tag></tag></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/21/Ganglia 安装/" itemprop="url">
                  Ganglia 安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-21T14:09:28+08:00" content="2015-04-21">
              2015-04-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Operation-And-Maintenance/" itemprop="url" rel="index">
                    <span itemprop="name">Operation And Maintenance</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/21/Ganglia 安装/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/21/Ganglia 安装/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2015/04/21/Ganglia 安装/" class="leancloud_visitors" data-flag-title="Ganglia 安装">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <!-- <span class="post-meta-item-text">阅读次数 </span> -->
               <span class="post-meta-item-text">❤ </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1. Install prerequisites on server node</p>
<p>Step 0: Use yum to install dependency</p>
<h1 id="yum-y-install-apr-devel-apr-util-check-devel-cairo-devel-pango-devel-libxml2-devel-glib2-devel-dbus-devel-freetype-devel-fontconfig-devel-gcc-c-expat-devel-python-devel-libXrender-devel-zlib-libpng-freetype-libjpeg-fontconfig-gd-libxml2-pcre-pcre-devel"><a href="#yum-y-install-apr-devel-apr-util-check-devel-cairo-devel-pango-devel-libxml2-devel-glib2-devel-dbus-devel-freetype-devel-fontconfig-devel-gcc-c-expat-devel-python-devel-libXrender-devel-zlib-libpng-freetype-libjpeg-fontconfig-gd-libxml2-pcre-pcre-devel" class="headerlink" title="yum -y install apr-devel apr-util check-devel cairo-devel pango-devel libxml2-devel glib2-devel dbus-devel freetype-devel fontconfig-devel gcc-c++ expat-devel python-devel libXrender-devel zlib libpng freetype libjpeg fontconfig gd libxml2 pcre pcre-devel"></a>yum -y install apr-devel apr-util check-devel cairo-devel pango-devel libxml2-devel glib2-devel dbus-devel freetype-devel fontconfig-devel gcc-c++ expat-devel python-devel libXrender-devel zlib libpng freetype libjpeg fontconfig gd libxml2 pcre pcre-devel</h1><p>Step 1: Install libconfuse</p>
<h1 id="wget-http-savannah-nongnu-org-download-confuse-confuse-2-7-tar-gz"><a href="#wget-http-savannah-nongnu-org-download-confuse-confuse-2-7-tar-gz" class="headerlink" title="wget http://savannah.nongnu.org/download/confuse/confuse-2.7.tar.gz"></a>wget <a href="http://savannah.nongnu.org/download/confuse/confuse-2.7.tar.gz" target="_blank" rel="external">http://savannah.nongnu.org/download/confuse/confuse-2.7.tar.gz</a></h1><h1 id="tar-xzvf-confuse-2-7-tar-gz"><a href="#tar-xzvf-confuse-2-7-tar-gz" class="headerlink" title="tar -xzvf confuse-2.7.tar.gz"></a>tar -xzvf confuse-2.7.tar.gz</h1><h1 id="cd-confuse-2-7"><a href="#cd-confuse-2-7" class="headerlink" title="cd confuse-2.7"></a>cd confuse-2.7</h1><h1 id="configure-CFLAGS-fPIC-–disable-nls-amp-amp-make-amp-amp-make-install"><a href="#configure-CFLAGS-fPIC-–disable-nls-amp-amp-make-amp-amp-make-install" class="headerlink" title="./configure CFLAGS=-fPIC –disable-nls &amp;&amp; make &amp;&amp; make install"></a>./configure CFLAGS=-fPIC –disable-nls &amp;&amp; make &amp;&amp; make install</h1><p>Step 2: Install rrdtool on server node</p>
<h1 id="wget-http-oss-oetiker-ch-rrdtool-pub-rrdtool-1-4-7-tar-gz"><a href="#wget-http-oss-oetiker-ch-rrdtool-pub-rrdtool-1-4-7-tar-gz" class="headerlink" title="wget http://oss.oetiker.ch/rrdtool/pub/rrdtool-1.4.7.tar.gz"></a>wget <a href="http://oss.oetiker.ch/rrdtool/pub/rrdtool-1.4.7.tar.gz" target="_blank" rel="external">http://oss.oetiker.ch/rrdtool/pub/rrdtool-1.4.7.tar.gz</a></h1><h1 id="tar-xzvf-rrdtool-1-4-7-tar-gz"><a href="#tar-xzvf-rrdtool-1-4-7-tar-gz" class="headerlink" title="tar -xzvf rrdtool-1.4.7.tar.gz"></a>tar -xzvf rrdtool-1.4.7.tar.gz</h1><h1 id="cd-rrdtool-1-4-7"><a href="#cd-rrdtool-1-4-7" class="headerlink" title="cd rrdtool-1.4.7"></a>cd rrdtool-1.4.7</h1><h1 id="configure-–prefix-usr-lib64-rrdtool-–disable-perl"><a href="#configure-–prefix-usr-lib64-rrdtool-–disable-perl" class="headerlink" title="./configure –prefix=/usr/lib64/rrdtool –disable-perl"></a>./configure –prefix=/usr/lib64/rrdtool –disable-perl</h1><h1 id="make-amp-amp-make-install"><a href="#make-amp-amp-make-install" class="headerlink" title="make &amp;&amp; make install"></a>make &amp;&amp; make install</h1><p>Step 3(Optional): Install libpre</p>
<h1 id="wget-http-downloads-sourceforge-net-pcre-pcre-8-32-tar-bz2"><a href="#wget-http-downloads-sourceforge-net-pcre-pcre-8-32-tar-bz2" class="headerlink" title="wget  http://downloads.sourceforge.net/pcre/pcre-8.32.tar.bz2"></a>wget  <a href="http://downloads.sourceforge.net/pcre/pcre-8.32.tar.bz2" target="_blank" rel="external">http://downloads.sourceforge.net/pcre/pcre-8.32.tar.bz2</a></h1><h1 id="tar-xvf-pcre-8-32-tar-bz2"><a href="#tar-xvf-pcre-8-32-tar-bz2" class="headerlink" title="tar -xvf pcre-8.32.tar.bz2"></a>tar -xvf pcre-8.32.tar.bz2</h1><h1 id="cd-pcre-8-32"><a href="#cd-pcre-8-32" class="headerlink" title="cd pcre-8.32"></a>cd pcre-8.32</h1><h1 id="configure-amp-amp-make-amp-amp-make-install"><a href="#configure-amp-amp-make-amp-amp-make-install" class="headerlink" title="./configure &amp;&amp; make &amp;&amp; make install"></a>./configure &amp;&amp; make &amp;&amp; make install</h1><p>2. Install and configure gmetad&amp;gmond on server node</p>
<p>Step 0: Install ganglia code</p>
<h1 id="wget-http-sourceforge-net-projects-ganglia-files-latest-download-source-files"><a href="#wget-http-sourceforge-net-projects-ganglia-files-latest-download-source-files" class="headerlink" title="wget http://sourceforge.net/projects/ganglia/files/latest/download?source=files"></a>wget <a href="http://sourceforge.net/projects/ganglia/files/latest/download?source=files" target="_blank" rel="external">http://sourceforge.net/projects/ganglia/files/latest/download?source=files</a></h1><h1 id="tar-xzvf-ganglia-3-5-0-tar-gz"><a href="#tar-xzvf-ganglia-3-5-0-tar-gz" class="headerlink" title="tar -xzvf ganglia-3.5.0.tar.gz"></a>tar -xzvf ganglia-3.5.0.tar.gz</h1><h1 id="cd-ganglia-3-5-0"><a href="#cd-ganglia-3-5-0" class="headerlink" title="cd ganglia-3.5.0"></a>cd ganglia-3.5.0</h1><h1 id="configure-–with-gmetad-–with-librrd-usr-lib64-rrdtool-–sysconfdir-etc-ganglia"><a href="#configure-–with-gmetad-–with-librrd-usr-lib64-rrdtool-–sysconfdir-etc-ganglia" class="headerlink" title="./configure –with-gmetad –with-librrd=/usr/lib64/rrdtool –sysconfdir=/etc/ganglia"></a>./configure –with-gmetad –with-librrd=/usr/lib64/rrdtool –sysconfdir=/etc/ganglia</h1><p>Ganglia can not be compiled successfully until the information as below shows up.<br>Welcome to..</p>
<pre><code> ______                  ___
/ ____/___ _____  ____ _/ (_)___ _
</code></pre><p>   / / <strong>/ </strong> <code>/ __ \/ __</code>/ / / <strong> `/<br>  / /<em>/ / /</em>/ / / / / /<em>/ / / / /</em>/ /<br>  __</strong>/_<em>,</em>/<em>/ /</em>/_<em>, /</em>/<em>/__,</em>/<br>                   /<em>__</em>/</p>
<p>Copyright (c) 2005 University of California, Berkeley</p>
<h1 id="make-amp-amp-make-install-1"><a href="#make-amp-amp-make-install-1" class="headerlink" title="make &amp;&amp; make install"></a>make &amp;&amp; make install</h1><p>Step 1: Check gmetad&amp;gmond binary</p>
<h1 id="which-gmetric"><a href="#which-gmetric" class="headerlink" title="which gmetric"></a>which gmetric</h1><p>/usr/local/bin/gmetric</p>
<h1 id="which-gmond"><a href="#which-gmond" class="headerlink" title="which gmond"></a>which gmond</h1><p>/usr/local/sbin/gmond</p>
<h1 id="which-gmetad"><a href="#which-gmetad" class="headerlink" title="which gmetad"></a>which gmetad</h1><p>/usr/local/sbin/gmetad</p>
<p>Step 2: Customize data_source name and hosts in gmetad.conf</p>
<h1 id="vi-etc-ganglia-gmetad-conf"><a href="#vi-etc-ganglia-gmetad-conf" class="headerlink" title="vi /etc/ganglia/gmetad.conf"></a>vi /etc/ganglia/gmetad.conf</h1><p>data_source “cluster1” mdw # provide the name of host containing all data, better more than one if a cluster, default port number is 8649</p>
<p>Step 3: Generate &amp;&amp; Customize gmond.conf(Using unicast)</p>
<h1 id="gmond-–default-config-gt-etc-ganglia-gmond-conf"><a href="#gmond-–default-config-gt-etc-ganglia-gmond-conf" class="headerlink" title="gmond –default_config &gt; /etc/ganglia/gmond.conf"></a>gmond –default_config &gt; /etc/ganglia/gmond.conf</h1><p>At this point you may get this error</p>
<p>gmond: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory</p>
<p>Create a symlink and execute the command again</p>
<h1 id="ln-s-lib64-libpcre-so-0-lib64-libpcre-so-1"><a href="#ln-s-lib64-libpcre-so-0-lib64-libpcre-so-1" class="headerlink" title="ln -s /lib64/libpcre.so.0 /lib64/libpcre.so.1"></a>ln -s /lib64/libpcre.so.0 /lib64/libpcre.so.1</h1><h1 id="vi-etc-ganglia-gmond-conf"><a href="#vi-etc-ganglia-gmond-conf" class="headerlink" title="vi /etc/ganglia/gmond.conf"></a>vi /etc/ganglia/gmond.conf</h1><p>cluster {<br>  name = “cluster1” # use the cluster name defined in gmetad.conf<br>  owner = “unspecified”<br>  latlong = “unspecified”<br>  url = “unspecified”<br>}<br>udp_send_channel {</p>
<p>  #bind_hostname = yes # Highly recommended, soon to be default.</p>
<pre><code># This option tells gmond to use a source address
# that resolves to the machine&apos;s hostname.  Without
# this, the metrics may appear to come from any
# interface and the DNS names associated with
# those IPs will be used to create the RRDs.
</code></pre><p>  host = 172.28.8.250 #if using unicast, provide ip address of server node, host and mcast_join cannot be in a channel<br>  port = 8649<br>  ttl = 1<br>}</p>
<p>udp_recv_channel {</p>
<p>  #mcast_join = 239.2.11.71 don’t need to provide multicast address if using unicast<br>  port = 8649</p>
<h1 id="bind-239-2-11-71"><a href="#bind-239-2-11-71" class="headerlink" title="bind = 239.2.11.71"></a>bind = 239.2.11.71</h1><p>  #retry_bind = true<br>}<br>Step 4: Create rrd directory, change permissions</p>
<h1 id="mkdir-p-var-lib-ganglia-rrds"><a href="#mkdir-p-var-lib-ganglia-rrds" class="headerlink" title="mkdir -p /var/lib/ganglia/rrds"></a>mkdir -p /var/lib/ganglia/rrds</h1><h1 id="chown-nobody-nobody-var-lib-ganglia-R"><a href="#chown-nobody-nobody-var-lib-ganglia-R" class="headerlink" title="chown nobody:nobody /var/lib/ganglia/ -R"></a>chown nobody:nobody /var/lib/ganglia/ -R</h1><p>Step 5: Copy the init script &amp;&amp; binary to corresponding directory</p>
<h1 id="cp-gmetad-gmetad-init-etc-rc-d-init-d-gmetad"><a href="#cp-gmetad-gmetad-init-etc-rc-d-init-d-gmetad" class="headerlink" title="cp gmetad/gmetad.init /etc/rc.d/init.d/gmetad"></a>cp gmetad/gmetad.init /etc/rc.d/init.d/gmetad</h1><h1 id="cp-usr-local-sbin-gmetad-usr-sbin"><a href="#cp-usr-local-sbin-gmetad-usr-sbin" class="headerlink" title="cp /usr/local/sbin/gmetad /usr/sbin/"></a>cp /usr/local/sbin/gmetad /usr/sbin/</h1><h1 id="cp-gmond-gmond-init-etc-rc-d-init-d-gmond"><a href="#cp-gmond-gmond-init-etc-rc-d-init-d-gmond" class="headerlink" title="cp gmond/gmond.init /etc/rc.d/init.d/gmond"></a>cp gmond/gmond.init /etc/rc.d/init.d/gmond</h1><h1 id="cp-usr-local-sbin-gmond-usr-sbin"><a href="#cp-usr-local-sbin-gmond-usr-sbin" class="headerlink" title="cp /usr/local/sbin/gmond /usr/sbin/"></a>cp /usr/local/sbin/gmond /usr/sbin/</h1><p>Step 6: Start gmetad and gmond service</p>
<h1 id="chkconfig-–add-gmetad"><a href="#chkconfig-–add-gmetad" class="headerlink" title="chkconfig –add gmetad"></a>chkconfig –add gmetad</h1><h1 id="chkconfig-–add-gmond"><a href="#chkconfig-–add-gmond" class="headerlink" title="chkconfig –add gmond"></a>chkconfig –add gmond</h1><h1 id="chkconfig-gmetad-on"><a href="#chkconfig-gmetad-on" class="headerlink" title="chkconfig gmetad on"></a>chkconfig gmetad on</h1><h1 id="chkconfig-gmond-on"><a href="#chkconfig-gmond-on" class="headerlink" title="chkconfig gmond on"></a>chkconfig gmond on</h1><h1 id="service-gmetad-start"><a href="#service-gmetad-start" class="headerlink" title="service gmetad start"></a>service gmetad start</h1><h1 id="service-gmond-start"><a href="#service-gmond-start" class="headerlink" title="service gmond start"></a>service gmond start</h1><p>3. Install and configure gmond on client node</p>
<p>Put Ganglia on the compute nodes by just copying a few files. This is something you can add to a post install script.<br>Step 0: Create a file with all your host names.<br>Step 1: Change paths of libraries and run ganglia install script.</p>
<h1 id="cat-home-gpadmin-yum-install-ganglia-install-sh"><a href="#cat-home-gpadmin-yum-install-ganglia-install-sh" class="headerlink" title="cat /home/gpadmin/yum_install/ganglia_install.sh"></a>cat /home/gpadmin/yum_install/ganglia_install.sh</h1><p>#!/bin/sh</p>
<p>for i in <code>cat /home/gpadmin/yum_install/hosts_nomaster</code>; do<br>    scp /usr/sbin/gmond $i:/usr/sbin/gmond<br>    ssh $i mkdir -p /etc/ganglia/<br>    scp /etc/ganglia/gmond.conf $i:/etc/ganglia/<br>    scp /etc/init.d/gmond $i:/etc/init.d/<br>    scp /usr/local/lib64/libganglia-3.5.0.so.0 $i:/usr/local/lib64/<br>    scp /usr/lib64/libexpat.so.0 $i:/usr/lib64/<br>    scp /usr/local/lib/libconfuse.a $i:/usr/local/lib/<br>    scp /usr/lib64/libapr-1.so.0 $i:/usr/lib64/<br>    scp -r /usr/local/lib64/ganglia/ $i:/usr/local/lib64/ganglia/<br>    ssh $i service gmond start<br>done</p>
<p>4. Install web front-end on server node</p>
<p>Step 0: Install prerequisites</p>
<h1 id="yum-install-httpd-php"><a href="#yum-install-httpd-php" class="headerlink" title="yum install httpd php"></a>yum install httpd php</h1><p>Step 1: Install ganglia-web binary</p>
<h1 id="wget-http-downloads-sourceforge-net-project-ganglia-ganglia-web-3-5-2-ganglia-web-3-5-2-tar-gz-r-http-3A-2F-2Fsourceforge-net-2Fprojects-2Fganglia-2Ffiles-2Fganglia-web-2F3-5-2-2F-amp-ts-1347011991-amp-use-mirror-cdnetworks-kr-1"><a href="#wget-http-downloads-sourceforge-net-project-ganglia-ganglia-web-3-5-2-ganglia-web-3-5-2-tar-gz-r-http-3A-2F-2Fsourceforge-net-2Fprojects-2Fganglia-2Ffiles-2Fganglia-web-2F3-5-2-2F-amp-ts-1347011991-amp-use-mirror-cdnetworks-kr-1" class="headerlink" title="wget http://downloads.sourceforge.net/project/ganglia/ganglia-web/3.5.2/ganglia-web-3.5.2.tar.gz?r=http%3A%2F%2Fsourceforge.net%2Fprojects%2Fganglia%2Ffiles%2Fganglia-web%2F3.5.2%2F&amp;ts=1347011991&amp;use_mirror=cdnetworks-kr-1"></a>wget <a href="http://downloads.sourceforge.net/project/ganglia/ganglia-web/3.5.2/ganglia-web-3.5.2.tar.gz?r=http%3A%2F%2Fsourceforge.net%2Fprojects%2Fganglia%2Ffiles%2Fganglia-web%2F3.5.2%2F&amp;ts=1347011991&amp;use_mirror=cdnetworks-kr-1" target="_blank" rel="external">http://downloads.sourceforge.net/project/ganglia/ganglia-web/3.5.2/ganglia-web-3.5.2.tar.gz?r=http%3A%2F%2Fsourceforge.net%2Fprojects%2Fganglia%2Ffiles%2Fganglia-web%2F3.5.2%2F&amp;ts=1347011991&amp;use_mirror=cdnetworks-kr-1</a></h1><h1 id="tar-xzvf-ganglia-web-3-5-2-tar-gz"><a href="#tar-xzvf-ganglia-web-3-5-2-tar-gz" class="headerlink" title="tar -xzvf ganglia-web-3.5.2.tar.gz"></a>tar -xzvf ganglia-web-3.5.2.tar.gz</h1><h1 id="cd-ganglia-web-3-5-2"><a href="#cd-ganglia-web-3-5-2" class="headerlink" title="cd ganglia-web-3.5.2"></a>cd ganglia-web-3.5.2</h1><h1 id="make-amp-amp-make-install-2"><a href="#make-amp-amp-make-install-2" class="headerlink" title="make &amp;&amp; make install"></a>make &amp;&amp; make install</h1><p>Step 2: Configure rrdtool path</p>
<h1 id="vi-var-www-html-ganglia-conf-default-php"><a href="#vi-var-www-html-ganglia-conf-default-php" class="headerlink" title="vi /var/www/html/ganglia/conf_default.php"></a>vi /var/www/html/ganglia/conf_default.php</h1><p>$conf[‘rrdtool’] = “/usr/lib64/rrdtool/bin/rrdtool”;</p>
<p>Step 3: Visit ganglia web interface through  “<a href="http://server-ip/ganglia" target="_blank" rel="external">http://server-ip/ganglia</a>“</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/21/Postgres 源码学习/" itemprop="url">
                  Postgre 源码学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-21T14:08:02+08:00" content="2015-04-21">
              2015-04-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Postgre/" itemprop="url" rel="index">
                    <span itemprop="name">Postgre</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/21/Postgres 源码学习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/21/Postgres 源码学习/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2015/04/21/Postgres 源码学习/" class="leancloud_visitors" data-flag-title="Postgre 源码学习">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <!-- <span class="post-meta-item-text">阅读次数 </span> -->
               <span class="post-meta-item-text">❤ </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1. 首先， 我选择eclipse CDT作为开发工具，很简单， 在Help-&gt;Install New Software中输入一下网址安装插件即可<br><a href="http://download.eclipse.org/tools/cdt/releases/helios" target="_blank" rel="external">http://download.eclipse.org/tools/cdt/releases/helios</a></p>
<p>2. 下载postgres源码，配置、编译、安装<br>Step 2.1 在终端对PostgreSQL进行配置将目录切换到PostgreSQL源码的根目录，执行如下命令：<br>    cd postgresql-9.2.2<br>    ./configure –prefix=$HOME/project –enable-depend –enable-cassert –enable-debug<br>其中–prefix指定PostgreSQL要安装的目录 （这个目录可以任意指定，但是建议使用绝对路径，这样在后续开发过程中不会出现因路径问题而产生的一系列莫名其妙的问题） –enable-depend、 –enable-cassert及 –enable-debug</p>
<p>Step 2.2 编译PostgreSQL<br>打开Eclipse将PostgreSQL源码导入Eclipse的工作目录，选择File–&gt;import，选择Existing Code as Makefile Project， 然后点击Next,在下面的图示中选择PostgreSQL源码所在的目录，并为工程文件起一个项目名，并选择编译器<br>由于PostgreSQL是使用C编写的，所以也要把C++勾掉，只保留C，然后点击Finish,等待工程导入完毕，这里需要注意的是只有当工程完全导入之后才可以执行下面的操作，否可可能出现错误，（可以通过Eclipse右下角查看当前导入进度）。当工程完全导入之后没有出现错误，则表明PostgreSQL编译成功</p>
<p>Step 2.3  安装PostgreSQL<br>在导入的工程上右键选择Make Targets 然后选择Create，在Make Target选项卡中双击install进行安装，Eclipse控制台中出现“Postgres Installation Complete” 表明PostgreSQL安装成功。</p>
<p>3. 初始化Postgres<br>Step 3.1 此时的PostgreSQL还不能真正使用，还需要进行初始化，在终端中执行如下操作：<br>     export PATH=$HOME/postgresql-9.2.2/bin:$PATH<br>     export PGDATA=DemoDir<br>     initdb</p>
<p>Step 3.2 在Eclipse中项目上右键选择Run As–&gt;Run Configurations，双击C/C++ Application，在Main选项卡中点击Search Project选择Postgres点击Apply。然后再切换到Arguments选项卡，输入参数：-D DemoDir（即上面命令中PGDATA指定的路径）。点击Run，如果看到如下信息表示安装成功。<br>LOG:  database system is ready to accept connections<br>LOG:  autovacuum launcher started</p>
<p>4.  初始Postgres<br>在终端输入：<br>createdb DemoDB<br>psql -l<br>psql DemoDB</p>
<p>5. 在Eclipse中调试PostgreSQL源代码</p>
<p>如果要调试PostgreSQL源码，首先保证安装了gdb，之后在工程上右键，选择Debug  As–&gt;Local C/C++ Application,在弹出的窗口中选择postgres，点击OK, 这时我们就可以通过Eclipse调试PostgreSQL源码了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/16/[转]SpringMVC源码剖析（四）- DispatcherServlet请求转发的实现/" itemprop="url">
                  [转]SpringMVC源码剖析（四）- DispatcherServlet请求转发的实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-16T07:31:15+08:00" content="2015-04-16">
              2015-04-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/16/[转]SpringMVC源码剖析（四）- DispatcherServlet请求转发的实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/16/[转]SpringMVC源码剖析（四）- DispatcherServlet请求转发的实现/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2015/04/16/[转]SpringMVC源码剖析（四）- DispatcherServlet请求转发的实现/" class="leancloud_visitors" data-flag-title="[转]SpringMVC源码剖析（四）- DispatcherServlet请求转发的实现">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <!-- <span class="post-meta-item-text">阅读次数 </span> -->
               <span class="post-meta-item-text">❤ </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文地址 <a href="http://my.oschina.net/lichhao/blog/104943" target="_blank" rel="external">http://my.oschina.net/lichhao/blog/104943</a></p>
<p>SpringMVC完成初始化流程之后，就进入Servlet标准生命周期的第二个阶段，即“service”阶段。在“service”阶段中，每一次Http请求到来，容器都会启动一个请求线程，通过service()方法，委派到doGet()或者doPost()这些方法，完成Http请求的处理。</p>
<p>在初始化流程中，SpringMVC巧妙的运用依赖注入读取参数，并最终建立一个与容器上下文相关联的Spring子上下文。这个子上下文，就像Struts2中xwork容器一样，为接下来的Http处理流程中各种编程元素提供了容身之所。如果说将Spring上下文关联到Servlet容器中，是SpringMVC框架的第一个亮点，那么在请求转发流程中，SpringMVC对各种处理环节编程元素的抽象，就是另外一个独具匠心的亮点。</p>
<p>Struts2采取的是一种完全和Web容器隔离和解耦的事件机制。诸如Action对象、Result对象、Interceptor对象，这些都是完全脱离Servlet容器的编程元素。Struts2将数据流和事件处理完全剥离开来，从Http请求中读取数据后，下面的事件处理流程就只依赖于这些数据，而完全不知道有Web环境的存在。</p>
<p>反观SpringMVC，无论HandlerMapping对象、HandlerAdapter对象还是View对象，这些核心的接口所定义的方法中，HttpServletRequest和HttpServletResponse对象都是直接作为方法的参数出现的。这也就意味着，框架的设计者，直接将SpringMVC框架和容器绑定到了一起。或者说，整个SpringMVC框架，都是依托着Servlet容器元素来设计的。下面就来看一下，源码中是如何体现这一点的。</p>
<p>1.请求转发的入口</p>
<p>就像任何一个注册在容器中的Servlet一样，DispatcherServlet也是通过自己的service()方法来接收和转发Http请求到具体的doGet()或doPost()这些方法的。以一次典型的GET请求为例，经过HttpServlet基类中service()方法的委派，请求会被转发到doGet()方法中。doGet()方法，在DispatcherServlet的父类FrameworkServlet类中被覆写。<br>[java]<br>@Override<br>protected final void doGet(HttpServletRequest request, HttpServletResponse response)<br>        throws ServletException, IOException {</p>
<pre><code>processRequest(request, response);
</code></pre><p>}<br>[/java]<br>可以看到，这里只是简单的转发到processRequest()这个方法。</p>
<p>[java]<br>protected final void processRequest(HttpServletRequest request, HttpServletResponse response)<br>        throws ServletException, IOException {</p>
<pre><code>long startTime = System.currentTimeMillis();
Throwable failureCause = null;

// Expose current LocaleResolver and request as LocaleContext.
LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
LocaleContextHolder.setLocaleContext(buildLocaleContext(request), this.threadContextInheritable);

// Expose current RequestAttributes to current thread.
RequestAttributes previousRequestAttributes = RequestContextHolder.getRequestAttributes();
ServletRequestAttributes requestAttributes = null;
if (previousRequestAttributes == null || previousRequestAttributes.getClass().equals(ServletRequestAttributes.class)) {
    requestAttributes = new ServletRequestAttributes(request);
    RequestContextHolder.setRequestAttributes(requestAttributes, this.threadContextInheritable);
}

if (logger.isTraceEnabled()) {
    logger.trace(&amp;quot;Bound request context to thread: &amp;quot; + request);
}

try {
    doService(request, response);
}
catch (ServletException ex) {
    failureCause = ex;
    throw ex;
}
catch (IOException ex) {
    failureCause = ex;
    throw ex;
}
catch (Throwable ex) {
    failureCause = ex;
    throw new NestedServletException(&amp;quot;Request processing failed&amp;quot;, ex);
}

finally {
    // Clear request attributes and reset thread-bound context.
    LocaleContextHolder.setLocaleContext(previousLocaleContext, this.threadContextInheritable);
    if (requestAttributes != null) {
        RequestContextHolder.setRequestAttributes(previousRequestAttributes, this.threadContextInheritable);
        requestAttributes.requestCompleted();
    }
    if (logger.isTraceEnabled()) {
        logger.trace(&amp;quot;Cleared thread-bound request context: &amp;quot; + request);
    }

    if (logger.isDebugEnabled()) {
        if (failureCause != null) {
            this.logger.debug(&amp;quot;Could not complete request&amp;quot;, failureCause);
        }
        else {
            this.logger.debug(&amp;quot;Successfully completed request&amp;quot;);
        }
    }
    if (this.publishEvents) {
        // Whether or not we succeeded, publish an event.
        long processingTime = System.currentTimeMillis() - startTime;
        this.webApplicationContext.publishEvent(
                new ServletRequestHandledEvent(this,
                        request.getRequestURI(), request.getRemoteAddr(),
                        request.getMethod(), getServletConfig().getServletName(),
                        WebUtils.getSessionId(request), getUsernameForRequest(request),
                        processingTime, failureCause));
    }
}
</code></pre><p>}[/java]<br>代码有点长，理解的要点是以doService()方法为区隔，前一部分是将当前请求的Locale对象和属性，分别设置到LocaleContextHolder和RequestContextHolder这两个抽象类中的ThreadLocal对象中，也就是分别将这两个东西和请求线程做了绑定。在doService()处理结束后，再恢复回请求前的LocaleContextHolder和RequestContextHolder，也即解除线程绑定。每次请求处理结束后，容器上下文都发布了一个ServletRequestHandledEvent事件，你可以注册监听器来监听该事件。</p>
<p>可以看到，processRequest()方法只是做了一些线程安全的隔离，真正的请求处理，发生在doService()方法中。点开FrameworkServlet类中的doService()方法。<br>[java]<br>protected abstract void doService(HttpServletRequest request, HttpServletResponse response)<br>        throws Exception;<br>[/java]<br>又是一个抽象方法，这也是SpringMVC类设计中的惯用伎俩：父类抽象处理流程，子类给予具体的实现。真正的实现是在DispatcherServlet类中。</p>
<p>让我们接着看DispatcherServlet类中实现的doService()方法。</p>
<p>[java]<br>@Override<br>protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {<br>    if (logger.isDebugEnabled()) {<br>        String requestUri = urlPathHelper.getRequestUri(request);<br>        logger.debug(&quot;DispatcherServlet with name ‘&quot; + getServletName() + &quot;’ processing &quot; + request.getMethod() +<br>                &quot; request for [&quot; + requestUri + &quot;]&quot;);<br>    }</p>
<pre><code>// Keep a snapshot of the request attributes in case of an include,
// to be able to restore the original attributes after the include.
Map&amp;lt;String, Object&amp;gt; attributesSnapshot = null;
if (WebUtils.isIncludeRequest(request)) {
    logger.debug(&amp;quot;Taking snapshot of request attributes before include&amp;quot;);
    attributesSnapshot = new HashMap&amp;lt;String, Object&amp;gt;();
    Enumeration&amp;lt;?&amp;gt; attrNames = request.getAttributeNames();
    while (attrNames.hasMoreElements()) {
        String attrName = (String) attrNames.nextElement();
        if (this.cleanupAfterInclude || attrName.startsWith(&amp;quot;org.springframework.web.servlet&amp;quot;)) {
            attributesSnapshot.put(attrName, request.getAttribute(attrName));
        }
    }
}

// Make framework objects available to handlers and view objects.
request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
if (inputFlashMap != null) {
    request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
}
request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);

try {
    doDispatch(request, response);
}
finally {
    // Restore the original attribute snapshot, in case of an include.
    if (attributesSnapshot != null) {
        restoreAttributesAfterInclude(request, attributesSnapshot);
    }
}
</code></pre><p>}[/java]<br>几个requet.setAttribute()方法的调用，将前面在初始化流程中实例化的对象设置到http请求的属性中，供下一步处理使用，其中有容器的上下文对象、本地化解析器等SpringMVC特有的编程元素。不同于Struts2中的ValueStack，SpringMVC的数据并没有从HttpServletRequest对象中抽离出来再存进另外一个编程元素，这也跟SpringMVC的设计思想有关。因为从一开始，SpringMVC的设计者就认为，不应该将请求处理过程和Web容器完全隔离。</p>
<p>所以，你可以看到，真正发生请求转发的方法doDispatch()中，它的参数是HttpServletRequest和HttpServletResponse对象。这给我们传递的意思也很明确，从request中能获取到一切请求的数据，从response中，我们又可以往服务器端输出任何响应，Http请求的处理，就应该围绕这两个对象来设计。我们不妨可以将SpringMVC这种设计方案，是从Struts2的过度设计中吸取教训，而向Servlet编程的一种回归和简化。</p>
<p>2.请求转发的抽象描述</p>
<p>接下来让我们看看doDispatch()这个整个请求转发流程中最核心的方法。DispatcherServlet所接收的Http请求，经过层层转发，最终都是汇总到这个方法中来进行最后的请求分发和处理。doDispatch()这个方法的内容，就是SpringMVC整个框架的精华所在。它通过高度抽象的接口，描述出了一个MVC（Model-View-Controller）设计模式的实现方案。Model、View、Controller三种层次的编程元素，在SpringMVC中都有大量的实现类，各种处理细节也是千差万别。但是，它们最后都是由，也都能由doDispatch()方法来统一描述，这就是接口和抽象的威力，万变不离其宗。</p>
<p>先来看一下doDispatch()方法的庐山真面目。<br>[java]<br>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {<br>    HttpServletRequest processedRequest = request;<br>    HandlerExecutionChain mappedHandler = null;<br>    int interceptorIndex = -1;</p>
<pre><code>try {
    ModelAndView mv;
    boolean errorView = false;

    try {
        processedRequest = checkMultipart(request);

        // Determine handler for the current request.
        mappedHandler = getHandler(processedRequest, false);
        if (mappedHandler == null || mappedHandler.getHandler() == null) {
            noHandlerFound(processedRequest, response);
            return;
        }

        // Determine handler adapter for the current request.
        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

        // Process last-modified header, if supported by the handler.
        String method = request.getMethod();
        boolean isGet = &amp;quot;GET&amp;quot;.equals(method);
        if (isGet || &amp;quot;HEAD&amp;quot;.equals(method)) {
            long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
            if (logger.isDebugEnabled()) {
                String requestUri = urlPathHelper.getRequestUri(request);
                logger.debug(&amp;quot;Last-Modified value for [&amp;quot; + requestUri + &amp;quot;] is: &amp;quot; + lastModified);
            }
            if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp; isGet) {
                return;
            }
        }

        // Apply preHandle methods of registered interceptors.
        HandlerInterceptor[] interceptors = mappedHandler.getInterceptors();
        if (interceptors != null) {
            for (int i = 0; i &amp;lt; interceptors.length; i++) {
                HandlerInterceptor interceptor = interceptors[i];
                if (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) {
                    triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);
                    return;
                }
                interceptorIndex = i;
            }
        }

        // Actually invoke the handler.
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

        // Do we need view name translation?
        if (mv != null &amp;amp;&amp;amp; !mv.hasView()) {
            mv.setViewName(getDefaultViewName(request));
        }

        // Apply postHandle methods of registered interceptors.
        if (interceptors != null) {
            for (int i = interceptors.length - 1; i &amp;gt;= 0; i--) {
                HandlerInterceptor interceptor = interceptors[i];
                interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv);
            }
        }
    }
    catch (ModelAndViewDefiningException ex) {
        logger.debug(&amp;quot;ModelAndViewDefiningException encountered&amp;quot;, ex);
        mv = ex.getModelAndView();
    }
    catch (Exception ex) {
        Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
        mv = processHandlerException(processedRequest, response, handler, ex);
        errorView = (mv != null);
    }

    // Did the handler return a view to render?
    if (mv != null &amp;amp;&amp;amp; !mv.wasCleared()) {
        render(mv, processedRequest, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
    else {
        if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Null ModelAndView returned to DispatcherServlet with name &apos;&amp;quot; + getServletName() +
                    &amp;quot;&apos;: assuming HandlerAdapter completed request handling&amp;quot;);
        }
    }

    // Trigger after-completion for successful outcome.
    triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);
}

catch (Exception ex) {
    // Trigger after-completion for thrown exception.
    triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);
    throw ex;
}
catch (Error err) {
    ServletException ex = new NestedServletException(&amp;quot;Handler processing failed&amp;quot;, err);
    // Trigger after-completion for thrown exception.
    triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);
    throw ex;
}

finally {
    // Clean up any resources used by a multipart request.
    if (processedRequest != request) {
        cleanupMultipart(processedRequest);
    }
}
</code></pre><p>}[/java]<br>真是千呼万唤始出来，犹抱琵琶半遮面。我们在第一篇《SpringMVC源码剖析（一）- 从抽象和接口说起》中所描述的各种编程元素，依次出现在该方法中。HandlerMapping、HandlerAdapter、View这些接口的设计，我们在第一篇中已经讲过。现在我们来重点关注一下HandlerExecutionChain这个对象。</p>
<p>从上面的代码中，很明显可以看出一条线索，整个方法是围绕着如何获取HandlerExecutionChain对象，执行HandlerExecutionChain对象得到相应的视图对象，再对视图进行渲染这条主线来展开的。HandlerExecutionChain对象显得异常重要。</p>
<p>因为Http请求要进入SpringMVC的处理体系，必须由HandlerMapping接口的实现类映射Http请求，得到一个封装后的HandlerExecutionChain对象。再由HandlerAdapter接口的实现类来处理这个HandlerExecutionChain对象所包装的处理对象，来得到最后渲染的视图对象。</p>
<p>视图对象是用ModelAndView对象来描述的，名字已经非常直白，就是数据和视图，其中的数据，由HttpServletRequest的属性得到，视图就是由HandlerExecutionChain封装的处理对象处理后得到。当然HandlerExecutionChain中的拦截器列表HandlerInterceptor，会在处理过程的前后依次被调用，为处理过程留下充足的扩展点。</p>
<p>所有的SpringMVC框架元素，都是围绕着HandlerExecutionChain这个执行链来发挥效用。我们来看看，HandlerExecutionChain类的代码。</p>
<p>[java]<br>package org.springframework.web.servlet;</p>
<p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;</p>
<p>import org.springframework.util.CollectionUtils;</p>
<p>public class HandlerExecutionChain {</p>
<pre><code>private final Object handler;

private HandlerInterceptor[] interceptors;

private List&amp;lt;HandlerInterceptor&amp;gt; interceptorList;

public HandlerExecutionChain(Object handler) {
    this(handler, null);
}

public HandlerExecutionChain(Object handler, HandlerInterceptor[] interceptors) {
    if (handler instanceof HandlerExecutionChain) {
        HandlerExecutionChain originalChain = (HandlerExecutionChain) handler;
        this.handler = originalChain.getHandler();
        this.interceptorList = new ArrayList&amp;lt;HandlerInterceptor&amp;gt;();
        CollectionUtils.mergeArrayIntoCollection(originalChain.getInterceptors(), this.interceptorList);
        CollectionUtils.mergeArrayIntoCollection(interceptors, this.interceptorList);
    }
    else {
        this.handler = handler;
        this.interceptors = interceptors;
    }
}

public Object getHandler() {
    return this.handler;
}

public void addInterceptor(HandlerInterceptor interceptor) {
    initInterceptorList();
    this.interceptorList.add(interceptor);
}

public void addInterceptors(HandlerInterceptor[] interceptors) {
    if (interceptors != null) {
        initInterceptorList();
        this.interceptorList.addAll(Arrays.asList(interceptors));
    }
}

private void initInterceptorList() {
    if (this.interceptorList == null) {
        this.interceptorList = new ArrayList&amp;lt;HandlerInterceptor&amp;gt;();
    }
    if (this.interceptors != null) {
        this.interceptorList.addAll(Arrays.asList(this.interceptors));
        this.interceptors = null;
    }
}

public HandlerInterceptor[] getInterceptors() {
    if (this.interceptors == null &amp;amp;&amp;amp; this.interceptorList != null) {
        this.interceptors = this.interceptorList.toArray(new HandlerInterceptor[this.interceptorList.size()]);
    }
    return this.interceptors;
}

@Override
public String toString() {
    if (this.handler == null) {
        return &amp;quot;HandlerExecutionChain with no handler&amp;quot;;
    }
    StringBuilder sb = new StringBuilder();
    sb.append(&amp;quot;HandlerExecutionChain with handler [&amp;quot;).append(this.handler).append(&amp;quot;]&amp;quot;);
    if (!CollectionUtils.isEmpty(this.interceptorList)) {
        sb.append(&amp;quot; and &amp;quot;).append(this.interceptorList.size()).append(&amp;quot; interceptor&amp;quot;);
        if (this.interceptorList.size() &amp;gt; 1) {
            sb.append(&amp;quot;s&amp;quot;);
        }
    }
    return sb.toString();
}
</code></pre><p>}[/java]<br>一个拦截器列表，一个执行对象，这个类的内容十分的简单，它蕴含的设计思想，却十分的丰富。</p>
<p>1.拦截器组成的列表，在执行对象被调用的前后，会依次执行。这里可以看成是一个的AOP环绕通知，拦截器可以对处理对象随心所欲的进行处理和增强。这里明显是吸收了Struts2中拦截器的设计思想。这种AOP环绕式的扩展点设计，也几乎成为所有框架必备的内容。</p>
<p>2.实际的处理对象，即handler对象，是由Object对象来引用的。</p>
<p>[java]<br>private final Object handler;[/java]<br>之所以要用一个java世界最基础的Object对象引用来引用这个handler对象，是因为连特定的接口也不希望绑定在这个handler对象上，从而使handler对象具有最大程度的选择性和灵活性。</p>
<p>我们常说，一个框架最高层次的抽象是接口，但是这里SpringMVC更进了一步。在最后的处理对象上面，SpringMVC没有对它做任何的限制，只要是java世界中的对象，都可以用来作为最后的处理对象，来生成视图。极端一点来说，你甚至可以将另外一个MVC框架集成到SpringMVC中来，也就是为什么SpringMVC官方文档中，居然还有集成其他表现层框架的内容。这一点，在所有表现层框架中，是独领风骚，冠绝群雄的。<br><img src="http://static.oschina.net/uploads/space/2013/0125/203718_HPiY_118997.jpg" alt=""></p>
<p>3.结语</p>
<p>SpringMVC的成功，源于它对开闭原则的运用和遵守。也正因此，才使得整个框架具有如此强大的描述和扩展能力。这也许和SpringMVC出现和兴起的时间有关，正是经历了Struts1到Struts2这些Web开发领域MVC框架的更新换代，它的设计者才能站在前人的肩膀上。知道了如何将事情做的糟糕之后，你或许才知道如何将事情做得好。</p>
<p>希望在这个系列里面分享的SpringMVC源码阅读经验，能帮助读者们从更高的层次来审视SpringMVC框架的设计，也希望这里所描述的一些基本设计思想，能在你更深入的了解SpringMVC的细节时，对你有帮助。哲学才是唯一的、最终的武器，在一个框架的设计上，尤其是如此。经常地体会一个框架设计者的设计思想，对你更好的使用它，是有莫大的益处的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/15/[转]SpringMVC源码剖析（三）- DispatcherServlet的初始化流程/" itemprop="url">
                  [转]SpringMVC源码剖析（三）- DispatcherServlet的初始化流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-15T12:35:44+08:00" content="2015-04-15">
              2015-04-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/15/[转]SpringMVC源码剖析（三）- DispatcherServlet的初始化流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/15/[转]SpringMVC源码剖析（三）- DispatcherServlet的初始化流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2015/04/15/[转]SpringMVC源码剖析（三）- DispatcherServlet的初始化流程/" class="leancloud_visitors" data-flag-title="[转]SpringMVC源码剖析（三）- DispatcherServlet的初始化流程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <!-- <span class="post-meta-item-text">阅读次数 </span> -->
               <span class="post-meta-item-text">❤ </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文地址 <a href="http://my.oschina.net/lichhao/blog/102315" target="_blank" rel="external">http://my.oschina.net/lichhao/blog/102315</a></p>
<p>在我们第一次学Servlet编程，学java web的时候，还没有那么多框架。我们开发一个简单的功能要做的事情很简单，就是继承HttpServlet，根据需要重写一下doGet，doPost方法，跳转到我们定义好的jsp页面。Servlet类编写完之后在web.xml里注册这个Servlet类。</p>
<p>除此之外，没有其他了。我们启动web服务器，在浏览器中输入地址，就可以看到浏览器上输出我们写好的页面。为了更好的理解上面这个过程，你需要学习关于Servlet生命周期的三个阶段，就是所谓的“init-service-destroy”。</p>
<p>以上的知识，我觉得对于你理解SpringMVC的设计思想，已经足够了。SpringMVC当然可以称得上是一个复杂的框架，但是同时它又遵循Servlet世界里最简单的法则，那就是“init-service-destroy”。我们要分析SpringMVC的初始化流程，其实就是分析DispatcherServlet类的init()方法，让我们带着这种单纯的观点，打开DispatcherServlet的源码一窥究竟吧。</p>
<p>1.<init-param>配置元素读取</init-param></p>
<p>用Eclipse IDE打开DispatcherServlet类的源码，ctrl+T看一下。<br><img src="http://static.oschina.net/uploads/space/2013/0114/170921_edHO_118997.jpg" alt=""></p>
<p>DispatcherServlet类的初始化入口方法init()定义在HttpServletBean这个父类中，HttpServletBean类作为一个直接继承于HttpServlet类的类，覆写了HttpServlet类的init()方法，实现了自己的初始化行为。<br>[java]<br>@Override<br>    public final void init() throws ServletException {<br>        if (logger.isDebugEnabled()) {<br>            logger.debug(&quot;Initializing servlet ‘&quot; + getServletName() + &quot;’&quot;);<br>        }</p>
<pre><code>    // Set bean properties from init parameters.
    try {
        PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
        BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
        ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());
        bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.environment));
        initBeanWrapper(bw);
        bw.setPropertyValues(pvs, true);
    }
    catch (BeansException ex) {
        logger.error(&amp;quot;Failed to set bean&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; properties on servlet &apos;&amp;quot; + getServletName() + &amp;quot;&apos;&amp;quot;, ex);
        throw ex;
    }

    // Let subclasses do whatever initialization they like.
    initServletBean();

    if (logger.isDebugEnabled()) {
        logger.debug(&amp;quot;Servlet &apos;&amp;quot; + getServletName() + &amp;quot;&apos; configured successfully&amp;quot;);
    }
}
</code></pre><p>[/java]<br>这里的initServletBean()方法在HttpServletBean类中是一个没有任何实现的空方法，它的目的就是留待子类实现自己的初始化逻辑，也就是我们常说的模板方法设计模式。SpringMVC在此生动的运用了这个模式，init()方法就是模版方法模式中的模板方法，SpringMVC真正的初始化过程，由子类FrameworkServlet中覆写的initServletBean()方法触发。</p>
<p>再看一下init()方法内被try,catch块包裹的代码，里面涉及到BeanWrapper，PropertyValues，ResourceEditor这些Spring内部非常底层的类。要深究具体代码实现上面的细节，需要对Spring框架源码具有相当深入的了解。我们这里先避繁就简，从代码效果和设计思想上面来分析这段try,catch块内的代码所做的事情：</p>
<p>注册一个字符串到资源文件的编辑器，让Servlet下面的<init-param>配置元素可以使用形如“classpath:”这种方式指定SpringMVC框架bean配置文件的来源。<br>将web.xml中在DispatcherServlet这个Servlet下面的<init-param>配置元素利用JavaBean的方式（即通过setter方法）读取到DispatcherServlet中来。<br>这两点，我想通过下面一个例子来说明一下。</init-param></init-param></p>
<p>我在web.xml中注册的DispatcherServlet配置如下：<br>[java]<br>&lt;!– springMVC配置开始 –&gt;<br>&lt;servlet&gt;<br>    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;<br>    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;<br>    &lt;init-param&gt;<br>        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br>        &lt;param-value&gt;classpath:spring/spring-servlet.xml&lt;/param-value&gt;<br>    &lt;/init-param&gt;<br>    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br>&lt;/servlet&gt;<br>&lt;servlet-mapping&gt;<br>    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;<br>    &lt;url-pattern&gt;/&lt;/url-pattern&gt;<br>&lt;/servlet-mapping&gt;<br>&lt;!– springMVC配置结束 –&gt;[/java]<br>可以看到，我注册了一个名为contextConfigLocation的<init-param>元素，其值为“classpath:spring/spring-servlet.xml”，这也是大家常常用来指定SpringMVC配置文件路径的方法。上面那段try,catch块包裹的代码发挥的作用，一个是将“classpath:spring/spring-servlet.xml”这段字符串转换成classpath路径下的一个资源文件，供框架初始化读取配置元素。在我的工程中是在spring文件夹下面的配置文件spring-servlet.xml。<br><img src="http://static.oschina.net/uploads/space/2013/0114/185832_7twm_118997.jpg" alt=""></init-param></p>
<p>另外一个作用，就是将contextConfigLocation的值读取出来，然后通过setContextConfigLocation()方法设置到DispatcherServlet中，这个setContextConfigLocation()方法是在FrameworkServlet类中定义的，也就是上面继承类图中DispatcherServlet的直接父类。</p>
<p>我们在setContextConfigLocation()方法上面打上一个断点，启动web工程，可以看到下面的调试结果。<br><img src="http://static.oschina.net/uploads/space/2013/0114/190308_tfyy_118997.jpg" alt=""></p>
<p>HttpServletBean类的作者是大名鼎鼎的Spring之父Rod Johnson。作为POJO编程哲学的大师，他在HttpServletBean这个类的设计中，运用了依赖注入思想完成了<init-param>配置元素的读取。他抽离出HttpServletBean这个类的目的也在于此，就是“以依赖注入的方式来读取Servlet类的<init-param>配置信息”，而且这里很明显是一种setter注入。</init-param></init-param></p>
<p>明白了HttpServletBean类的设计思想，我们也就知道可以如何从中获益。具体来说，我们继承HttpServletBean类（就像DispatcherServlet做的那样），在类中定义一个属性，为这个属性加上setter方法后，我们就可以在<init-param>元素中为其定义值。在类被初始化后，值就会被注入进来，我们可以直接使用它，避免了样板式的getInitParameter()方法的使用，而且还免费享有Spring中资源编辑器的功能，可以在web.xml中，通过“classpath:”直接指定类路径下的资源文件。</init-param></p>
<p>注意，虽然SpringMVC本身为了后面初始化上下文的方便，使用了字符串来声明和设置contextConfigLocation参数，但是将其声明为Resource类型，同样能够成功获取。鼓励读者们自己继承HttpServletBean写一个测试用的Servlet类，并设置一个参数来调试一下，这样能够帮助你更好的理解获取配置参数的过程。</p>
<p>2.容器上下文的建立</p>
<p>上一篇文章中提到过，SpringMVC使用了Spring容器来容纳自己的配置元素，拥有自己的bean容器上下文。在SpringMVC初始化的过程中，非常关键的一步就是要建立起这个容器上下文，而这个建立上下文的过程，发生在FrameworkServlet类中，由上面init()方法中的initServletBean()方法触发。<br>[java]<br>@Override<br>protected final void initServletBean() throws ServletException {<br>    getServletContext().log(&quot;Initializing Spring FrameworkServlet ‘&quot; + getServletName() + &quot;’&quot;);<br>    if (this.logger.isInfoEnabled()) {<br>        this.logger.info(&quot;FrameworkServlet ‘&quot; + getServletName() + &quot;’: initialization started&quot;);<br>    }<br>    long startTime = System.currentTimeMillis();</p>
<pre><code>try {
    this.webApplicationContext = initWebApplicationContext();
    initFrameworkServlet();
}
catch (ServletException ex) {
    this.logger.error(&amp;quot;Context initialization failed&amp;quot;, ex);
    throw ex;
}
catch (RuntimeException ex) {
    this.logger.error(&amp;quot;Context initialization failed&amp;quot;, ex);
    throw ex;
}

if (this.logger.isInfoEnabled()) {
    long elapsedTime = System.currentTimeMillis() - startTime;
    this.logger.info(&amp;quot;FrameworkServlet &apos;&amp;quot; + getServletName() + &amp;quot;&apos;: initialization completed in &amp;quot; +
            elapsedTime + &amp;quot; ms&amp;quot;);
}
</code></pre><p>}[/java]<br>initFrameworkServlet()方法是一个没有任何实现的空方法，除去一些样板式的代码，那么这个initServletBean()方法所做的事情已经非常明白：</p>
<p>[java]<br>this.webApplicationContext = initWebApplicationContext();[/java]<br>这一句简单直白的代码，道破了FrameworkServlet这个类，在SpringMVC类体系中的设计目的，它是 用来抽离出建立 WebApplicationContext 上下文这个过程的。<br>initWebApplicationContext()方法，封装了建立Spring容器上下文的整个过程，方法内的逻辑如下：</p>
<p>获取由ContextLoaderListener初始化并注册在ServletContext中的根上下文，记为rootContext<br>如果webApplicationContext已经不为空，表示这个Servlet类是通过编程式注册到容器中的（Servlet 3.0+中的ServletContext.addServlet() ），上下文也由编程式传入。若这个传入的上下文还没被初始化，将rootContext上下文设置为它的父上下文，然后将其初始化，否则直接使用。<br>通过wac变量的引用是否为null，判断第2步中是否已经完成上下文的设置（即上下文是否已经用编程式方式传入），如果wac==null成立，说明该Servlet不是由编程式注册到容器中的。此时以contextAttribute属性的值为键，在ServletContext中查找上下文，查找得到，说明上下文已经以别的方式初始化并注册在contextAttribute下，直接使用。<br>检查wac变量的引用是否为null，如果wac==null成立，说明2、3两步中的上下文初始化策略都没成功，此时调用createWebApplicationContext(rootContext)，建立一个全新的以rootContext为父上下文的上下文，作为SpringMVC配置元素的容器上下文。大多数情况下我们所使用的上下文，就是这个新建的上下文。<br>以上三种初始化上下文的策略，都会回调onRefresh(ApplicationContext context)方法（回调的方式根据不同策略有不同），onRefresh方法在DispatcherServlet类中被覆写，以上面得到的上下文为依托，完成SpringMVC中默认实现类的初始化。<br>最后，将这个上下文发布到ServletContext中，也就是将上下文以一个和Servlet类在web.xml中注册名字有关的值为键，设置为ServletContext的一个属性。你可以通过改变publishContext的值来决定是否发布到ServletContext中，默认为true。<br>以上面6点跟踪FrameworkServlet类中的代码，可以比较清晰的了解到整个容器上下文的建立过程，也就能够领会到FrameworkServlet类的设计目的，它是用来建立一个和Servlet关联的Spring容器上下文，并将其注册到ServletContext中的。跳脱开SpringMVC体系，我们也能通过继承FrameworkServlet类，得到与Spring容器整合的好处，FrameworkServlet和HttpServletBean一样，是一个可以独立使用的类。整个SpringMVC设计中，处处体现开闭原则，这里显然也是其中一点。</p>
<p>3.初始化SpringMVC默认实现类</p>
<p>初始化流程在FrameworkServlet类中流转，建立了上下文后，通过onRefresh(ApplicationContext context)方法的回调，进入到DispatcherServlet类中。</p>
<p>[java]<br>@Override<br>protected void onRefresh(ApplicationContext context) {<br>    initStrategies(context);<br>}[/java]<br>DispatcherServlet类覆写了父类FrameworkServlet中的onRefresh(ApplicationContext context)方法，提供了SpringMVC各种编程元素的初始化。当然这些编程元素，都是作为容器上下文中一个个bean而存在的。具体的初始化策略，在initStrategies()方法中封装。</p>
<p>[java]<br>protected void initStrategies(ApplicationContext context) {<br>    initMultipartResolver(context);<br>    initLocaleResolver(context);<br>    initThemeResolver(context);<br>    initHandlerMappings(context);<br>    initHandlerAdapters(context);<br>    initHandlerExceptionResolvers(context);<br>    initRequestToViewNameTranslator(context);<br>    initViewResolvers(context);<br>    initFlashMapManager(context);<br>}[/java]<br>我们以其中initHandlerMappings(context)方法为例，分析一下这些SpringMVC编程元素的初始化策略，其他的方法，都是以类似的策略初始化的。<br>[java]<br>private void initHandlerMappings(ApplicationContext context) {<br>        this.handlerMappings = null;</p>
<pre><code>    if (this.detectAllHandlerMappings) {
        // Find all HandlerMappings in the ApplicationContext, including ancestor contexts.
        Map&amp;lt;String, HandlerMapping&amp;gt; matchingBeans =
                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);
        if (!matchingBeans.isEmpty()) {
            this.handlerMappings = new ArrayList&amp;lt;HandlerMapping&amp;gt;(matchingBeans.values());
            // We keep HandlerMappings in sorted order.
            OrderComparator.sort(this.handlerMappings);
        }
    }
    else {
        try {
            HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
            this.handlerMappings = Collections.singletonList(hm);
        }
        catch (NoSuchBeanDefinitionException ex) {
            // Ignore, we&apos;ll add a default HandlerMapping later.
        }
    }

    // Ensure we have at least one HandlerMapping, by registering
    // a default HandlerMapping if no other mappings are found.
    if (this.handlerMappings == null) {
        this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);
        if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;No HandlerMappings found in servlet &apos;&amp;quot; + getServletName() + &amp;quot;&apos;: using default&amp;quot;);
        }
    }
}[/java]
</code></pre><p>detectAllHandlerMappings变量默认为true，所以在初始化HandlerMapping接口默认实现类的时候，会把上下文中所有HandlerMapping类型的Bean都注册在handlerMappings这个List变量中。如果你手工将其设置为false，那么将尝试获取名为handlerMapping的Bean，新建一个只有一个元素的List，将其赋给handlerMappings。如果经过上面的过程，handlerMappings变量仍为空，那么说明你没有在上下文中提供自己HandlerMapping类型的Bean定义。此时，SpringMVC将采用默认初始化策略来初始化handlerMappings。</p>
<p>点进去getDefaultStrategies看一下。</p>
<p>[java]<br>@SuppressWarnings(&quot;unchecked&quot;)<br>protected &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) {<br>    String key = strategyInterface.getName();<br>    String value = defaultStrategies.getProperty(key);<br>    if (value != null) {<br>        String[] classNames = StringUtils.commaDelimitedListToStringArray(value);<br>        List&lt;T&gt; strategies = new ArrayList&lt;T&gt;(classNames.length);<br>        for (String className : classNames) {<br>            try {<br>                Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());<br>                Object strategy = createDefaultStrategy(context, clazz);<br>                strategies.add((T) strategy);<br>            }<br>            catch (ClassNotFoundException ex) {<br>                throw new BeanInitializationException(<br>                        &quot;Could not find DispatcherServlet’s default strategy class [&quot; + className +<br>                                &quot;] for interface [&quot; + key + &quot;]&quot;, ex);<br>            }<br>            catch (LinkageError err) {<br>                throw new BeanInitializationException(<br>                        &quot;Error loading DispatcherServlet’s default strategy class [&quot; + className +<br>                                &quot;] for interface [&quot; + key + &quot;]: problem with class file or dependent class&quot;, err);<br>            }<br>        }<br>        return strategies;<br>    }<br>    else {<br>        return new LinkedList&lt;T&gt;();<br>    }<br>}[/java]<br>它是一个范型的方法，承担所有SpringMVC编程元素的默认初始化策略。方法的内容比较直白，就是以传递类的名称为键，从defaultStrategies这个Properties变量中获取实现类，然后反射初始化。</p>
<p>需要说明一下的是defaultStrategies变量的初始化，它是在DispatcherServlet的静态初始化代码块中加载的。<br>[java]<br>private static final Properties defaultStrategies;</p>
<p>static {<br>    // Load default strategy implementations from properties file.<br>    // This is currently strictly internal and not meant to be customized<br>    // by application developers.<br>    try {<br>        ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);<br>        defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);<br>    }<br>    catch (IOException ex) {<br>        throw new IllegalStateException(&quot;Could not load ‘DispatcherServlet.properties’: &quot; + ex.getMessage());<br>    }<br>}[/java]<br>[java]<br>private static final String DEFAULT_STRATEGIES_PATH = &quot;DispatcherServlet.properties&quot;;[/java]<br>这个DispatcherServlet.properties里面，以键值对的方式，记录了SpringMVC默认实现类，它在spring-webmvc-3.1.3.RELEASE.jar这个jar包内，在org.springframework.web.servlet包里面。<br>[java]</p>
<h1 id="Default-implementation-classes-for-DispatcherServlet’s-strategy-interfaces"><a href="#Default-implementation-classes-for-DispatcherServlet’s-strategy-interfaces" class="headerlink" title="Default implementation classes for DispatcherServlet’s strategy interfaces."></a>Default implementation classes for DispatcherServlet’s strategy interfaces.</h1><h1 id="Used-as-fallback-when-no-matching-beans-are-found-in-the-DispatcherServlet-context"><a href="#Used-as-fallback-when-no-matching-beans-are-found-in-the-DispatcherServlet-context" class="headerlink" title="Used as fallback when no matching beans are found in the DispatcherServlet context."></a>Used as fallback when no matching beans are found in the DispatcherServlet context.</h1><h1 id="Not-meant-to-be-customized-by-application-developers"><a href="#Not-meant-to-be-customized-by-application-developers" class="headerlink" title="Not meant to be customized by application developers."></a>Not meant to be customized by application developers.</h1><p>org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</p>
<p>org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</p>
<p>org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\<br>    org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</p>
<p>org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\<br>    org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\<br>    org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</p>
<p>org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\<br>    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\<br>    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</p>
<p>org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</p>
<p>org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</p>
<p>org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager[/java]<br>至此，我们分析完了initHandlerMappings(context)方法的执行过程，其他的初始化过程与这个方法非常类似。所有初始化方法执行完后，SpringMVC正式完成初始化，静静等待Web请求的到来。</p>
<p>4.总结</p>
<p>回顾整个SpringMVC的初始化流程，我们看到，通过HttpServletBean、FrameworkServlet、DispatcherServlet三个不同的类层次，SpringMVC的设计者将三种不同的职责分别抽象，运用模版方法设计模式分别固定在三个类层次中。其中HttpServletBean完成的是<init-param>配置元素的依赖注入，FrameworkServlet完成的是容器上下文的建立，DispatcherServlet完成的是SpringMVC具体编程元素的初始化策略。</init-param></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/14/[转]SpringMVC源码剖析（二）- DispatcherServlet的前世今生/" itemprop="url">
                  [转]SpringMVC源码剖析（二）- DispatcherServlet的前世今生
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-14T12:19:45+08:00" content="2015-04-14">
              2015-04-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/14/[转]SpringMVC源码剖析（二）- DispatcherServlet的前世今生/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/14/[转]SpringMVC源码剖析（二）- DispatcherServlet的前世今生/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2015/04/14/[转]SpringMVC源码剖析（二）- DispatcherServlet的前世今生/" class="leancloud_visitors" data-flag-title="[转]SpringMVC源码剖析（二）- DispatcherServlet的前世今生">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <!-- <span class="post-meta-item-text">阅读次数 </span> -->
               <span class="post-meta-item-text">❤ </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文地址 <a href="http://my.oschina.net/lichhao/blog/100138" target="_blank" rel="external">http://my.oschina.net/lichhao/blog/100138</a></p>
<p>上一篇文章《SpringMVC源码剖析（一）- 从抽象和接口说起》中，我介绍了一次典型的SpringMVC请求处理过程中，相继粉墨登场的各种核心类和接口。我刻意忽略了源码中的处理细节，只列出最简单的类甚至是接口类，目的就是让大家先从最高层次的抽象意义上来审视SpringMVC这个框架；我也刻意将SpringMVC和Struts2做对比，目的是让大家看到，SpringMVC究竟吸取了Sturts2设计思想中的哪些精华，又弥补了它的哪些遗憾。</p>
<p>DispatcherServlet作为SpringMVC的核心之中的核心类，再怎么强调它的重要性也不为过。SpringMVC所有的核心类和接口，都密集地出现在DispatcherServlet的源码中，SpringMVC源码剖析，很大程度上可以说也是在剖析DispatcherServlet这一个类。这一篇文章里，我先说几点关于DispatcherServlet的前世今生，希望能帮助你更好的理解它。</p>
<p>1.对扩展开放，对修改封闭</p>
<p>SpringMVC是一个基于著名的Open-Closed，即开闭原则进行设计的框架。在Spring官方文档里面关于SpringMVC的介绍开宗明义地进行了说明：</p>
<p>[java]<br>A key design principle in Spring Web MVC and in Spring in general is the “Open for extension,closed for modification” principle.[/java]<br>开闭原则是一个很宽泛的原则，具体体现到DispatcherServlet的源码中，我们可以大致摸得到一些线索：</p>
<p>类中所有的变量声明，几乎都以接口的形式给出，并没有绑定在具体的实现类上。<br>使用模版方法模式，在父类中对基础行为进行定义，让子类实现模版方法扩展行为。<br>其中第一点，在一个框架的设计中尤为重要，也是贯彻开闭原则最重要的一点。因为当你通过一些高层次的接口或者抽象类，将一个类完成的逻辑或流程编写完成后（具体点说，是通过一个接口的引用调用接口方法），整个逻辑或流程的功能就被确实的在源码中固定下来了。可是这时，这些接口或抽象类的具体实现者是谁，还没有固定！这就给了你的系统或框架近乎无限的扩展性，因为你可以任意安排和实现这些类。</p>
<p>我认为，面向对象设计的精髓，是对现实世界中“行为和契约”的描述。这个“行为和契约”，体现在接口和抽象类的方法声明中。软件设计师要用面向对象的眼光去观察和抽象这个世界中的事物，这里的事物可以是一些商业逻辑、可以是一些处理流程，然后用高层次的接口去描述这些行为和契约。当你在越抽象的层次上将这些行为和契约描述清楚后，你所设计的系统就是越符合开闭原则的。</p>
<p>SpringMVC框架在面向对象设计上，做出了绝佳的示范。它通过高度抽象的接口，描述出了一次请求处理的流程，从而让整个框架从一开始就是符合开闭原则的。同时它也提供了这些接口的一系列默认实现类，让你不需要很复杂的配置，就能很好的使用SpringMVC进行开发。抽象的确是个利器，但是框架绝不能运行在空中楼阁中，SpringMVC提供的的这一系列默认实现类必须要有容身之所。聪明的你可能早已想到：Spring IOC容器。这就引出了我要说的第二点。</p>
<p>2.配置元素的对象化</p>
<p>所有的框架，都需要有这样一个功能，叫做：配置元素的对象化。因为几乎所有的框架，都将配置元素集中到外部的xml配置文件中，然后在框架的初始化流程中，对这些配置文件进行解析，再变成java世界中的一个个对象供框架使用，这整个过程，可以被称为配置元素的对象化。为什么要有配置文件呢？这个问题的回答也是很简单，因为没有人会想要使用一个配置散布在框架中各个java类源码里面的框架。框架也不允许使用者这样子做，因为框架在发布的时候，提供的是一个个jar包文件，jar包内是已经编译好的class文件。配置文件由使用者外部提供，框架对它进行解析，使用者能得到集中配置的好处，框架也乐于这样子，可以说是合情合理。</p>
<p>那么作为Spring产品族的新成员，SpringMVC在设计的时候，相信设计者们不做它想，这一个“配置元素的对象化”功能既然不可避免，那么使用Spring IOC容器，通过bean配置文件来配置SpringMVC，绝对是不二之选。不可能像Struts2一样，内部再搞一个别的容器，因为Spring容器本身已经是被高度设计，而且已经在java世界获得巨大成功。从推广的角度上来说，如果对spring容器的所有知识，都可以完整的应用到SpringMVC，那么对于开发者无疑是一个极大的吸引力。</p>
<p>剩下的问题就只有：到底该如何将Spring容器和SpringMVC的初始化过程整合起来呢？</p>
<p>答案就是WebApplicationContext接口，更具体点说，是XmlWebApplicationContext这个Spring上下文实现类。SpringMVC也使用了这一个为了将Spring容器和Web环境整合而特意设计的Spring上下文类。我们打开WebApplicationContext的源码：</p>
<p>[java]<br>package org.springframework.web.context;</p>
<p>import javax.servlet.ServletContext;</p>
<p>import org.springframework.context.ApplicationContext;</p>
<p>public interface WebApplicationContext extends ApplicationContext {</p>
<pre><code>String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + &amp;quot;.ROOT&amp;quot;;

String SCOPE_REQUEST = &amp;quot;request&amp;quot;;

String SCOPE_SESSION = &amp;quot;session&amp;quot;;

String SCOPE_GLOBAL_SESSION = &amp;quot;globalSession&amp;quot;;

String SCOPE_APPLICATION = &amp;quot;application&amp;quot;;

String SERVLET_CONTEXT_BEAN_NAME = &amp;quot;servletContext&amp;quot;;

String CONTEXT_PARAMETERS_BEAN_NAME = &amp;quot;contextParameters&amp;quot;;

String CONTEXT_ATTRIBUTES_BEAN_NAME = &amp;quot;contextAttributes&amp;quot;;

ServletContext getServletContext();
</code></pre><p>}[/java]<br>发现它是继承于ApplicationContext这个普通Spring容器所使用的上下文接口类，除了一些常量的声明，只多了一个可以获取到ServletContext的getServletContext()方法。回到上面提到的“行为和契约的描述”上，我们可以大胆的断言，Spring容器和Web环境的整合，是在ServletContext上做文章。</p>
<p>打开所有使用了Spring的Web项目的web.xml文件，必定有这样一段配置：<br>[java]<br>&lt;listener&gt;<br>    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;<br>&lt;/listener&gt;[/java]<br>ContextLoaderListener实现了ServletContextListener接口，在Servlet容器启动的时候，会初始化一个WebApplicationContext的实现类，并将其作为ServletContext的一个属性设置到Servlet环境中，摘抄源码如下： </p>
<p>[java]<br>servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);<br>[/java]<br>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE的值，在上面WebApplicationContext的源码中的第一个常量中就被声明，是WebApplicationContext.class.getName() + “.ROOT”，更直接一点，它是“org.springframework.web.context.WebApplicationContext.ROOT”。ContextLoaderListener所初始化的这个Spring容器上下文，被称为根上下文。</p>
<p>SpringMVC在DispatcherServlet的初始化过程中，同样会初始化一个WebApplicationContext的实现类，作为自己独有的上下文，这个独有的上下文，会将上面的根上下文作为自己的父上下文，来存放SpringMVC的配置元素，然后同样作为ServletContext的一个属性，被设置到ServletContext中，只不过它的key就稍微有点不同，key和具体的DispatcherServlet注册在web.xml文件中的名字有关，从这一点也决定了，我们可以在web.xml文件中注册多个DispatcherServlet，因为Servlet容器中注册的Servlet名字肯定不一样，设置到Servlet环境中的key也肯定不同。</p>
<p>由于在Spring容器中，子上下文可以访问到所有父上下文中的信息，而父上下文访问不到子上下文的信息，这个根上下文，就很适合作为多个子上下文配置的集中点。以官方文档中的图来说明：<br><img src="http://static.oschina.net/uploads/space/2013/0105/171256_QY0t_118997.jpg" alt=""><br>3.前端控制器</p>
<p>前端控制器，即所谓的Front Controller，体现的是设计模式中的前端控制器模式。前端控制器处理所有从用户过来的请求。所有用户的请求都要通过前端控制器。SpringMVC框架和其他请求驱动的表示层框架一样，也是围绕一个将请求分发到相应控制器的核心Servlet来设计的。DispatcherServlet和其他框架中的Servlet不一样的地方在于，它和Spring容器无缝整合在了一起，因此你可以在SpringMVC中使用Spring容器所有的特性。</p>
<p>DispatcherServlet这个前端控制器，在SpringMVC中的作用，以官方文档中的配图来说明：<br><img src="http://static.oschina.net/uploads/space/2013/0105/172154_xuHb_118997.jpg" alt=""></p>
<p>整个流程可以被大致描述为：一个http请求到达服务器，被DispatcherServlet接收。DispatcherServlet将请求委派给合适的处理器Controller，此时处理控制权到达Controller对象。Controller内部完成请求的数据模型的创建和业务逻辑的处理，然后再将填充了数据后的模型即model和控制权一并交还给DispatcherServlet，委派DispatcherServlet来渲染响应。DispatcherServlet再将这些数据和适当的数据模版视图结合，向Response输出响应。</p>
<p>可以看到Model-View-Controller这三样东西协同合作，共同体现出MVC的设计理念，三个层次可以分别独立演化，整个系统架构又清晰又简洁。这是SpringMVC为我们描述的美好愿景，后面我们也将看到，SpringMVC为了实现这一承诺，究竟做出了什么样的努力。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/14/[转]SpringMVC源码剖析（一）- 从抽象和接口说起/" itemprop="url">
                  [转]SpringMVC源码剖析（一）- 从抽象和接口说起
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-14T10:38:08+08:00" content="2015-04-14">
              2015-04-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/14/[转]SpringMVC源码剖析（一）- 从抽象和接口说起/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/14/[转]SpringMVC源码剖析（一）- 从抽象和接口说起/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2015/04/14/[转]SpringMVC源码剖析（一）- 从抽象和接口说起/" class="leancloud_visitors" data-flag-title="[转]SpringMVC源码剖析（一）- 从抽象和接口说起">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <!-- <span class="post-meta-item-text">阅读次数 </span> -->
               <span class="post-meta-item-text">❤ </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文地址  <a href="http://my.oschina.net/lichhao/blog/99039" target="_blank" rel="external">http://my.oschina.net/lichhao/blog/99039</a><br>SpringMVC作为Struts2之后异军突起的一个表现层框架，正越来越流行，相信javaee的开发者们就算没使用过SpringMVC，也应该对其略有耳闻。我试图通过对SpringMVC的设计思想和源码实现的剖析，从抽象意义上的设计层面和实现意义上的代码层面两个方面，逐一揭开SpringMVC神秘的面纱，本文的代码，都是基于Spring的 3.1.3RELEASE版本。</p>
<p>任何一个框架，都有自己特定的适用领域，框架的设计和实现，必定是为了应付该领域内许多通用的，烦琐的、基础的工作而生。SpringMVC作为一个表现层框架，也必须直面Web开发领域中表现层中的几大课题，并给出自己的回答：</p>
<p>URL到框架的映射。<br>http请求参数绑定<br>http响应的生成和输出<br>这三大课题，组成一个完整的web请求流程，每一个部分都具有非常广阔的外延。SpringMVC框架对这些课题的回答又是什么呢？</p>
<p>学习一个框架，首要的是要先领会它的设计思想。从抽象、从全局上来审视这个框架。其中最具有参考价值的，就是这个框架所定义的核心接口。核心接口定义了框架的骨架，也在最抽象的意义上表达了框架的设计思想。</p>
<p>下面我以一个web请求流程为载体，依次介绍SpringMVC的核心接口和类。</p>
<p>用户在浏览器中，输入了<a href="http://www.xxxx.com/aaa/bbb.ccc的地址，回车后，浏览器发起一个http请求。请求到达你的服务器后，首先会被SpringMVC注册在web.xml中的前端转发器DispatcherServlet接收，DispatcherServlet是一个标准的Servlet，它的作用是接受和转发web请求到内部框架处理单元。" target="_blank" rel="external">http://www.xxxx.com/aaa/bbb.ccc的地址，回车后，浏览器发起一个http请求。请求到达你的服务器后，首先会被SpringMVC注册在web.xml中的前端转发器DispatcherServlet接收，DispatcherServlet是一个标准的Servlet，它的作用是接受和转发web请求到内部框架处理单元。</a></p>
<p>下面看一下第一个出现在你面前的核心接口，它是在org.springframework.web.servlet包中定义的HandlerMapping接口：<br>[java]<br>package org.springframework.web.servlet;</p>
<p>import javax.servlet.http.HttpServletRequest;</p>
<p>public interface HandlerMapping {</p>
<pre><code>String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + &amp;quot;.pathWithinHandlerMapping&amp;quot;;

String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + &amp;quot;.bestMatchingPattern&amp;quot;;

String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + &amp;quot;.introspectTypeLevelMapping&amp;quot;;

String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &amp;quot;.uriTemplateVariables&amp;quot;;

String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + &amp;quot;.producibleMediaTypes&amp;quot;;

HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;
</code></pre><p>}[/java]<br>为了阅读方便，我去掉了源码中的注释，但是我强烈建议你一定要记得去阅读它，这样你才能从框架的设计者口中得到最准确的关于这个类或者接口的设计说明。类中定义的几个常量，我们先不去管它。关键在于这个接口中唯一的方法：</p>
<p>[java]<br>HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;<br>这个方法就算对于一个java初学者来说，也很容易理解：它只有一个类型为HttpServletRequest的参数，throws Exception的声明表示它不处理任何类型的异常，HandlerExecutionChain是它的返回类型。<br>[/java]</p>
<p>回到DispatcherServlet的处理流程，当DispatcherServlet接收到web请求后，由标准Servlet类处理方法doGet或者doPost，经过几次转发后，最终注册在DispatcherServlet类中的HandlerMapping实现类组成的一个List（有点拗口）会在一个循环中被遍历。以该web请求的HttpServletRequest对象为参数，依次调用其getHandler方法，第一个不为null的调用结果，将被返回。DispatcherServlet类中的这个遍历方法不长，贴一下，让大家有更直观的了解。<br>[java]<br>/**</p>
<pre><code> * Return the HandlerExecutionChain for this request.
 * &amp;lt;p&amp;gt;Tries all handler mappings in order.
 * @param request current HTTP request
 * @return the HandlerExecutionChain, or &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt; if no handler could be found
 */
protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    for (HandlerMapping hm : this.handlerMappings) {
        if (logger.isTraceEnabled()) {
            logger.trace(
                    &amp;quot;Testing handler map [&amp;quot; + hm + &amp;quot;] in DispatcherServlet with name &apos;&amp;quot; + getServletName() + &amp;quot;&apos;&amp;quot;);
        }
        HandlerExecutionChain handler = hm.getHandler(request);
        if (handler != null) {
            return handler;
        }
    }
    return null;
}
</code></pre><p>[/java]<br>是的，第一步处理就这么简单的完成了。一个web请求经过处理后，会得到一个HandlerExecutionChain对象，这就是SpringMVC对URl映射给出的回答。需要留意的是，HandlerMapping接口的getHandler方法参数是HttpServletRequest，这意味着，HandlerMapping的实现类可以利用HttpServletRequest中的 所有信息来做出这个HandlerExecutionChain对象的生成”决策“。这包括，请求头、url路径、cookie、session、参数等等一切你从一个web请求中可以得到的任何东西（最常用的是url路径）。</p>
<p>SpirngMVC的第一个扩展点，就出现在这里。我们可以编写任意的HandlerMapping实现类，依据任何策略来决定一个web请求到HandlerExecutionChain对象的生成。可以说，从第一个核心接口的声明开始，SpringMVC就把自己的灵活性和野心暴露无疑：哥玩的就是”Open-Closed“。</p>
<p>HandlerExecutionChain这个类，就是我们下一个要了解的核心类。从名字可以直观的看得出，这个对象是一个执行链的封装。熟悉Struts2的都知道，Action对象也是被层层拦截器包装，这里可以做个类比，说明SpringMVC确实是吸收了Struts2的部分设计思想。</p>
<p>HandlerExecutionChain类的代码不长，它定义在org.springframework.web.servlet包中，为了更直观的理解，先上代码。<br>[java]<br>package org.springframework.web.servlet;</p>
<p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;</p>
<p>import org.springframework.util.CollectionUtils;</p>
<p>public class HandlerExecutionChain {</p>
<pre><code>private final Object handler;

private HandlerInterceptor[] interceptors;

private List&amp;lt;HandlerInterceptor&amp;gt; interceptorList;

public HandlerExecutionChain(Object handler) {
    this(handler, null);
}

public HandlerExecutionChain(Object handler, HandlerInterceptor[] interceptors) {
    if (handler instanceof HandlerExecutionChain) {
        HandlerExecutionChain originalChain = (HandlerExecutionChain) handler;
        this.handler = originalChain.getHandler();
        this.interceptorList = new ArrayList&amp;lt;HandlerInterceptor&amp;gt;();
        CollectionUtils.mergeArrayIntoCollection(originalChain.getInterceptors(), this.interceptorList);
        CollectionUtils.mergeArrayIntoCollection(interceptors, this.interceptorList);
    }
    else {
        this.handler = handler;
        this.interceptors = interceptors;
    }
}

public Object getHandler() {
    return this.handler;
}

public void addInterceptor(HandlerInterceptor interceptor) {
    initInterceptorList();
    this.interceptorList.add(interceptor);
}

public void addInterceptors(HandlerInterceptor[] interceptors) {
    if (interceptors != null) {
        initInterceptorList();
        this.interceptorList.addAll(Arrays.asList(interceptors));
    }
}

private void initInterceptorList() {
    if (this.interceptorList == null) {
        this.interceptorList = new ArrayList&amp;lt;HandlerInterceptor&amp;gt;();
    }
    if (this.interceptors != null) {
        this.interceptorList.addAll(Arrays.asList(this.interceptors));
        this.interceptors = null;
    }
}

public HandlerInterceptor[] getInterceptors() {
    if (this.interceptors == null &amp;amp;&amp;amp; this.interceptorList != null) {
        this.interceptors = this.interceptorList.toArray(new HandlerInterceptor[this.interceptorList.size()]);
    }
    return this.interceptors;
}

@Override
public String toString() {
    if (this.handler == null) {
        return &amp;quot;HandlerExecutionChain with no handler&amp;quot;;
    }
    StringBuilder sb = new StringBuilder();
    sb.append(&amp;quot;HandlerExecutionChain with handler [&amp;quot;).append(this.handler).append(&amp;quot;]&amp;quot;);
    if (!CollectionUtils.isEmpty(this.interceptorList)) {
        sb.append(&amp;quot; and &amp;quot;).append(this.interceptorList.size()).append(&amp;quot; interceptor&amp;quot;);
        if (this.interceptorList.size() &amp;gt; 1) {
            sb.append(&amp;quot;s&amp;quot;);
        }
    }
    return sb.toString();
}
</code></pre><p>}<br>[/java]<br>乱七八糟一大堆，相信你也没全看完，也没必要全看。其实只需要看两行足矣。<br>[java]<br>private final Object handler;</p>
<p>private HandlerInterceptor[] interceptors;<br>[/java]<br>不出我们所料，一个实质执行对象，还有一堆拦截器。这不就是Struts2中的实现么，SpringMVC没有避嫌，还是采用了这种封装。得到HandlerExecutionChain这个执行链（execution chain）之后，下一步的处理将围绕其展开。</p>
<p>HandlerInterceptor也是SpringMVC的核心接口，定义如下：<br>[java]<br>package org.springframework.web.servlet;</p>
<p>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p>
<p>public interface HandlerInterceptor {</p>
<pre><code>boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
    throws Exception;

void postHandle(
        HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)
        throws Exception;

void afterCompletion(
        HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
        throws Exception;
</code></pre><p>}[/java]<br>至此，HandlerExecutionChain整个执行脉络也就清楚了：在真正调用其handler对象前，HandlerInterceptor接口实现类组成的数组将会被遍历，其preHandle方法会被依次调用，然后真正的handler对象将被调用。</p>
<p>handler对象被调用后，就生成了需要的响应数据，在将处理结果写到HttpServletResponse对象之前（SpringMVC称为渲染视图），其postHandle方法会被依次调用。视图渲染完成后，最后afterCompletion方法会被依次调用，整个web请求的处理过程就结束了。</p>
<p>在一个处理对象执行之前，之后利用拦截器做文章，这已经成为一种经典的框架设计套路。Struts2中的拦截器会做诸如参数绑定这类复杂的工作，那么SpringMVC的拦截器具体做些什么呢？我们暂且不关心，虽然这是很重要的细节，但细节毕竟是细节，我们先来理解更重要的东西。</p>
<p>HandlerInterceptor，是SpringMVC的第二个扩展点的暴露，通过自定义拦截器，我们可以在一个请求被真正处理之前、请求被处理但还没输出到响应中、请求已经被输出到响应中之后这三个时间点去做任何我们想要做的事情。Struts2框架的成功，就是源于这种拦截器的设计，SpringMVC吸收了这种设计思想，并推陈出新，更合理的划分了三个不同的时间点，从而给web请求处理这个流程，提供了更大的扩展性。</p>
<p>这个HandlerExecutionChain类中以Object引用所声明的handler对象，到底是个什么东东？它是怎么被调用的？</p>
<p>回答这些问题之前，先看SpringMVC中的又一个核心接口，HandlerAdapter：</p>
<p>[java]<br>package org.springframework.web.servlet;</p>
<p>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p>
<p>public interface HandlerAdapter {</p>
<pre><code>boolean supports(Object handler); 

ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;

long getLastModified(HttpServletRequest request, Object handler);
</code></pre><p>}[/java]<br>在DispatcherServlet中，除了HandlerMapping实现类的列表，同样也注册了一个HandlerAdapter实现类组成的列表，有代码为证。<br>[java]<br>/<em>* List of HandlerMappings used by this servlet </em>/<br>private List&lt;HandlerMapping&gt; handlerMappings;</p>
<p>/<strong> List of HandlerAdapters used by this servlet */<br>private List&lt;HandlerAdapter&gt; handlerAdapters;[/java]<br>接下来，我们再以DispatcherServlet类中另外一段代码来回答上述的问题：<br>[java]<br>/</strong></p>
<ul>
<li>Return the HandlerAdapter for this handler object.</li>
<li>@param handler the handler object to find an adapter for</li>
<li>@throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.<br>*/<br>protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {<br> for (HandlerAdapter ha : this.handlerAdapters) {<pre><code>if (logger.isTraceEnabled()) {
    logger.trace(&amp;quot;Testing handler adapter [&amp;quot; + ha + &amp;quot;]&amp;quot;);
}
if (ha.supports(handler)) {
    return ha;
}
</code></pre> }<br> throw new ServletException(&quot;No adapter for handler [&quot; + handler +<pre><code>&amp;quot;]: Does your handler implement a supported interface like Controller?&amp;quot;);
</code></pre>}[/java]<br>这段代码已经很明显了，HandlerExecutionChain中的handler对象会被作为参数传递进去，在DispatcherServlet类中注册的HandlerAdapter实现类列表会被遍历，然后返回第一个supports方法返回true的HandlerAdapter对象，用这个HandlerAdapter实现类中的handle方法处理handler对象，并返回ModelAndView这个包含了视图和数据的对象。HandlerAdapter就是SpringMVC提供的第三个扩展点，你可以提供自己的实现类来处理handler对象。</li>
</ul>
<p>ModelAndView对象的代码就不贴了，它是SpringMVC中对视图和数据的一个聚合类。其中的视图，就是由SpringMVC的最后一个核心接口View所抽象：<br>[java]<br>package org.springframework.web.servlet;</p>
<p>import java.util.Map;</p>
<p>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p>
<p>public interface View {</p>
<pre><code>String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + &amp;quot;.responseStatus&amp;quot;;

String PATH_VARIABLES = View.class.getName() + &amp;quot;.pathVariables&amp;quot;;

String getContentType();

void render(Map&amp;lt;String, ?&amp;gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;
</code></pre><p>}<br>[/java]<br>所有的数据，最后会作为一个Map对象传递到View实现类中的render方法，调用这个render方法，就完成了视图到响应的渲染。这个View实现类，就是来自HandlerAdapter中的handle方法的返回结果。当然从ModelAndView到真正的View实现类有一个解析的过程，ModelAndView中可以有真正的视图对象，也可以只是有一个视图的名字，SpringMVC会负责将视图名称解析为真正的视图对象。</p>
<p>至此，我们了解了一个典型的完整的web请求在SpringMVC中的处理过程和其中涉及到的核心类和接口。</p>
<p>在一个典型的SpringMVC调用中，HandlerExecutionChain中封装handler对象就是用@Controller注解标识的类的一个实例，根据类级别和方法级别的@RequestMapping注解，由默认注册的DefaultAnnotationHandlerMapping（3.1.3中更新为RequestMappingHandlerMapping类，但是为了向后兼容，DefaultAnnotationHandlerMapping也可以使用）生成HandlerExecutionChain对象，再由AnnotationMethodHandlerAdapter（3.1.3中更新为RequestMappingHandlerAdapter类，但是为了向后兼容，AnnotationMethodHandlerAdapter也可以使用）来执行这个HandlerExecutionChain对象，生成最终的ModelAndView对象后，再由具体的View对象的render方法渲染视图。</p>
<p>可以看到，作为一个表现层框架，SpringMVC没有像Struts2那样激进，并没有采用和Web容器完全解耦的设计思想，而是以原生的Servlet框架对象为依托，通过合理的抽象，制定了严谨的的处理流程。这样做的结果是，执行效率比Struts2要高，灵活性也上升了一个层次。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/13/进程 线程操作/" itemprop="url">
                  进程/线程操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-13T10:59:50+08:00" content="2015-04-13">
              2015-04-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Interview/" itemprop="url" rel="index">
                    <span itemprop="name">Interview</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/13/进程 线程操作/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/13/进程 线程操作/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2015/04/13/进程 线程操作/" class="leancloud_visitors" data-flag-title="进程/线程操作">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <!-- <span class="post-meta-item-text">阅读次数 </span> -->
               <span class="post-meta-item-text">❤ </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.为什么要进行线程/进程间的同步？<br>因为存在多个线程或者进程需要访问相同的资源。如果不进行同步，可能导致错误发生。比如因读写的不同步造成的数据错误，或者死锁的出现等，让系统和数据进入到一种错误或者不稳定的状态。</p>
<p>2.使用了多线程就必须要进行同步么？<br>大部分情况下是这样，但也不能绝对。 因为需要进行同步的情况需要满足两个条件：</p>
<p>a.存在多个线程/进程</p>
<p>b.多个线程/进程之间会相互的竞争资源</p>
<p>如果只是存在多个线程/进程，但只见并没有竟让共有资源，那也没必要进行同步。 如线程内的局部变量等数据</p>
<p>3.进行同步的机制都有什么？<br>比如加互斥锁，临界区，信号量等。</p>
<p>互斥锁： 一次只允许一个线程进入共享区域，在离开共享区域时释放锁。</p>
<p>临界区： 类似互斥锁</p>
<p>信号量： 维护一个数，允许特定数量的线程进入</p>
<p>4.什么是原子操作。</p>
<p>原子操作就是一组不可分离的操作。应该把它视为一个整体，要么全部成功，要么全部失败，不会出现部分成功，部分失败的现象。而且原子操作执行中间不会被打断。</p>
<p>5.原子操作的不会被打断是什么意思，是说线程不会被切换么？<br>不是的。</p>
<p>有的原子操作是由处理器本身所支持的。 如一条指令本身肯定是一个原子操作。</p>
<p>但有的原子操作是一个执行块，这时在这个执行块中间，是非常有可能发生线程间的切换的。</p>
<p>有时候，一条高级语言的语句可能会被编译成好几条对应的汇编语句（机器语句） 如 c = a+b； 很有可能还没有算出c的结果线程就被切换了。<br>但发生线程间的切换并不意味着数据就可以被其他的线程访问。因为我们可以通过加锁的办法，让其他线程不能进入到执行块内部。这样其他线程虽然获得了CPU时间，但如果要访问执行块，只有等待，别的什么也做不了。数据还是安全的。</p>
<p>6.锁和原子操作是一个概念么。<br>原子操作是一个不可被分割的单个或者多个操作。<br>锁是一种机制，让我们来协调各个线程，来实现原子操作。<br>原子操作 分为物理的  和 软件实现的两种<br>物理的比如一条单独的汇编语句。<br>软件实现的往往依赖于锁</p>
<p>7. 什么是死锁。<br>如在一个单轨的铁路上，两条火车向不同的方向开。 谁也动不了了</p>
<p>8.为什么会发生死锁<br>死锁一般都是由于对共享资源的竞争引起的。 但对共享资源的竞争又不一定就会发生死锁。 死锁的发生必须同时满足四个条件：互斥，持有/等待，非抢占， 形成等待环</p>
<p>9.什么是活锁<br>活锁和死锁很像似。 只是活锁的状态可以发生改变。不过虽然状态可以改变，却没有实质的进展。<br>活锁一般是由于对死锁的不正确处理引起的。由于处于死锁中的多个线程同时采取了行动。 而避免的方法也是只让一个线程释放资源。<br>比如两个人在一个很宅的胡同里。 一次只能并排过两个人。 两人比较礼貌，都要给对方让路。 结果一起要么让到左边，要么让到右边，结果仍然是谁也过不去。 类似于原地踏步或者震荡状态。</p>
<p>10. 什么是饿死<br>饿死（starvation） 是一个线程长时间得不到需要的资源而不能执行的现象。 有人饿死并不代表着出现了死锁。很有可能系统还能很好的进行。<br>所以，没有出现死锁并不能就认为系统是完好的。还要保证没有出现饿死的现象。<br>避免饿死就应该是采用队列的方式，保证每个人都有机会获得请求的资源。 当然实现方式可以很多个变化，比如优先级，时间片，等，都是“队列”的特殊形式</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Jerky Lu" />
          <p class="site-author-name" itemprop="name">Jerky Lu</p>
          <p class="site-description motion-element" itemprop="description">戒急用忍</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">322</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">42</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/luzheqi1987" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jerkybible" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://lqcode.com/" title="李琼写文章的地方" target="_blank">李琼写文章的地方</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://wiredtiger.org/" title="落影流年" target="_blank">落影流年</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerky Lu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jerkybible"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("ikggGroaejtGnK5kN7meiyXz-gzGzoHsz", "xE9HyNGqt0oKWPxB4mz6HScq");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
  
  
    

  
  
  
  <link rel="stylesheet" href="/vendors/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/vendors/algolia-instant-search/instantsearch.min.js"></script>
  

  <script type="text/javascript" src="/js/src/algolia.js?v=5.0.1"></script>



  

</body>
</html>
