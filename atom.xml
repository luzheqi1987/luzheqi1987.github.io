<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>行走的轮子</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-23T03:35:18.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jerky Lu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[转]如何处理异常? catch Exception OR catch Throwable</title>
    <link href="http://yoursite.com/2016/05/11/%5B%E8%BD%AC%5D%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%20catch%20Exception%20OR%20catch%20Throwable/"/>
    <id>http://yoursite.com/2016/05/11/[转]如何处理异常 catch Exception OR catch Throwable/</id>
    <published>2016-05-10T19:52:20.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    <content type="html">   <![CDATA[ <blockquote>
<p><strong>在Java中，当你需要统一处理异常的时候，你是会选择catch (Exception)，还是直接catch (Throwable)？</strong></p>
</blockquote>
<h3 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h3><ol>
<li><p><em><u>Throwable</u></em>: Java中所有异常和错误类的父类。只有这个类的实例（或者子类的实例）可以被虚拟机抛出或者被java的throw关键字抛出。同样，只有其或其子类可以出现在catch子句里面。</p>
</li>
<li><p><em><u>Error</u></em>: Throwable的子类，表示严重的问题发生了，而且这种错误是不可恢复的。</p>
</li>
<li><p><em><u>Exception</u></em>: Throwable的子类，应用程序应该要捕获其或其子类（RuntimeException例外），称为checked exception。比如：IOException, NoSuchMethodException…</p>
</li>
<li><p><em><u>RuntimeException</u></em>: Exception的子类，运行时异常，程序可以不捕获，称为unchecked exception。比如：NullPointException.</p>
<a id="more"></a>
</li>
</ol>
<hr>
<h3 id="应该catch什么"><a href="#应该catch什么" class="headerlink" title="应该catch什么"></a>应该catch什么</h3><p>其实只要是Throwable和其子类都是可以throw和catch的，那么如果在需要统一处理异常的地方，我们应该catch (Throwable th) 还是 catch (Exception)呢？</p>
<p>这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。先不考虑有其他的类继承了Throwable的情况下（附录A），第一种catch相当于比第二种catch多捕捉了把Error和其子类。</p>
<p>那么究竟Error是否需要捕捉呢？JDK中Error类的的注释（如下）里提到过，Error是一种严重的问题，应用程序不应该捕捉它。</p>
<blockquote>
<p>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a “normal” condition, is also a subclass of Error because most applications should not try to catch it.<br>A method is not required to declare in its throws clause any subclasses of Error that might be thrown during the execution of the method but not caught, since these errors are abnormal conditions that should never occur.</p>
</blockquote>
<p>Java Lanuage Spec 7 中也提到：Error继承自Throwable而不是继承自Exception，是为了方便程序可以使用 “catch (Exception)“来捕捉异常而不会把Error也捕捉在内，因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。</p>
<blockquote>
<p>The class Error is a separate subclass ofThrowable, distinct from Exception in the class<br>hierarchy, to allow programs to use the idiom “} catch (Exception e) { &quot; (§11.2.3)<br>to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible.</p>
</blockquote>
<p>已经不难看出，Java本身设计思路就是希望大家catch Exception就足够了，如果有Error发生，catch了也不会有什么作用（附录B）。 </p>
<hr>
<h3 id="引申，如何设计异常体系？"><a href="#引申，如何设计异常体系？" class="headerlink" title="引申，如何设计异常体系？"></a>引申，如何设计异常体系？</h3><p>如何设计异常体系要根据你的项目的情况，类库框架，应用程序的异常设计方式都会有一些区别。下面简单谈谈个人对异常设计的一些看法</p>
<p><strong>类库/框架</strong></p>
<p>继承RuntimeException扩展一个新的异常作为整个类库的异常基类。这个异常应该可以满足大部分类库对异常的要求。<br>在实现中，在任何需要捕捉checked exception的地方都会把异常统一转化成这个新的异常。<br>对于有特殊需求，需要自定义异常的，就通过继承这个基类来实现自定义异常。<br>不对异常记录log（交给上层来处理）</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><strong>fastjson</strong><br><img src="/images/exception_fastjson.png" alt=""></p>
<p><strong>spring</strong><br>自定义异常比较多，不过都是继承自<code>org.springframework.core.NestedRuntimeException</code>，而这个异常也是继承自RuntimeException。</p>
<p><strong>应用程序</strong><br>设计上和框架异常类似，只是在捕捉checked exception的时候需要log<br>如果需要根据异常进行不同的处理，建议给自定义异常增加一个ERROR_CODE字段，这样无论在服务器还是客户端都可以根据不同的ERROR_CODE进行对应的处理。但是出现这种情况的时候，应该需要考虑一下设计思路了，一般来讲根据异常来决定业务流程不是一个好的设计方案。</p>
<p><em>附录A：是否应该直接继承Throwable来扩展新的异常？</em><br>个人认为异常都应该继承自Exception或者RuntimeException，而且Java本身对Exception和Error的规划就很清晰了，Java自己类库中没有异常是直接继承自Throwable的。<br><em>附录B：Error可以catch吗？ 可以catch了后做些其他处理吗？</em><br>Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。<br>假设进行网络连接操作的时候，IOException 发生了，可能是网络中断，我可以再尝试几次。<br>假设OutOfMemoryError发生了，就算被捕捉了，可以有什么手段让程序正常运行下去吗？<br>假设ExceptionInInitializerError发生了，类无法被正常初始化，这个是可以通过捕捉来恢复的吗？</p>
<p>原文链接:<a href="http://my.oschina.net/foxty/blog/359473" title="http://my.oschina.net/foxty/blog/359473" target="_blank" rel="external">http://my.oschina.net/foxty/blog/359473</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在Java中，当你需要统一处理异常的时候，你是会选择catch (Exception)，还是直接catch (Throwable)？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Java的异常体系&quot;&gt;&lt;a href=&quot;#Java的异常体系&quot; class=&quot;headerlink&quot; title=&quot;Java的异常体系&quot;&gt;&lt;/a&gt;Java的异常体系&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;u&gt;Throwable&lt;/u&gt;&lt;/em&gt;: Java中所有异常和错误类的父类。只有这个类的实例（或者子类的实例）可以被虚拟机抛出或者被java的throw关键字抛出。同样，只有其或其子类可以出现在catch子句里面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;u&gt;Error&lt;/u&gt;&lt;/em&gt;: Throwable的子类，表示严重的问题发生了，而且这种错误是不可恢复的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;u&gt;Exception&lt;/u&gt;&lt;/em&gt;: Throwable的子类，应用程序应该要捕获其或其子类（RuntimeException例外），称为checked exception。比如：IOException, NoSuchMethodException…&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;u&gt;RuntimeException&lt;/u&gt;&lt;/em&gt;: Exception的子类，运行时异常，程序可以不捕获，称为unchecked exception。比如：NullPointException.&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java8中Lambda表达式的10个例子</title>
    <link href="http://yoursite.com/2015/11/25/Java8%E4%B8%ADLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%8410%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2015/11/25/Java8中Lambda表达式的10个例子/</id>
    <published>2015-11-25T06:46:18.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="例1-用Lambda表达式实现Runnable接口"><a href="#例1-用Lambda表达式实现Runnable接口" class="headerlink" title="例1: 用Lambda表达式实现Runnable接口"></a>例1: 用Lambda表达式实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Before Java 8:  </span></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">    System.out.println(&amp;quot;Before Java8, too much code <span class="keyword">for</span> too little to do&amp;quot;);  </div><div class="line">&#125;  </div><div class="line">&#125;).start();  </div><div class="line"><span class="comment">//Java 8 way:  </span></div><div class="line"><span class="keyword">new</span> Thread( () -&amp;gt; System.out.println(&amp;quot;In Java8, Lambda expression rocks !!&amp;quot;) ).start();</div></pre></td></tr></table></figure>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">too much code, for too little to do </div><div class="line">Lambda expression rocks !!</div></pre></td></tr></table></figure></p>
<p>这个例子使我们学到了java8中Lambda表达式的书写方式：<br>(参数) -&gt; 表达式<br>(参数) -&gt; 语句<br>(参数) -&gt; { 语句 }<br>例如，如果你的方法只是在控制台打印信息，则可以这么写： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() -&amp;gt; System.out.println(&amp;quot;Hello Lambda Expressions&amp;quot;);</div></pre></td></tr></table></figure>
<p>如果你的方法接收两个参数，那么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span> even, <span class="keyword">int</span> odd) -&amp;gt; even + odd</div></pre></td></tr></table></figure></p>
<p>顺带提一句，一般来说在Lambda表达式中要尽量保持变量的简洁性。这会使你的代码简短而能保持在一行之内。所以像上面的代码可以选择变量名类似a,b或者x,y之类的，比起even和odd来会更好。 </p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="例2-用Lambda表达式写事件监听程序"><a href="#例2-用Lambda表达式写事件监听程序" class="headerlink" title="例2: 用Lambda表达式写事件监听程序"></a>例2: 用Lambda表达式写事件监听程序</h3><p>要是你用过Swing API，那就少不了事件监听代码，这是使用匿名类的经典例子。现在我们可以用Lambda表达式来抒写更好的事件处理代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Before Java 8:  </span></div><div class="line">JButton show = <span class="keyword">new</span> JButton(&amp;quot;Show&amp;quot;);  </div><div class="line">show.addActionListener(<span class="keyword">new</span> ActionListener() &#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;  </div><div class="line">        System.out.println(&amp;quot;Event handling without lambda expression is boring&amp;quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line"><span class="comment">// Java 8 way:  </span></div><div class="line">show.addActionListener((e) -&amp;gt; &#123;  </div><div class="line">    System.out.println(&amp;quot;Light, Camera, Action !! Lambda expressions Rocks&amp;quot;);  </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>另外一个常用匿名类的地方是给Collections.sort()方法提供自定义的Comparator接口实现。这个地方也可以用Lambda表达式。 </p>
<hr>
<h3 id="例3-用Lambda表达式进行List迭代"><a href="#例3-用Lambda表达式进行List迭代" class="headerlink" title="例3: 用Lambda表达式进行List迭代"></a>例3: 用Lambda表达式进行List迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Prior Java 8 :  </span></div><div class="line">List features = Arrays.asList(&amp;quot;Lambdas&amp;quot;, &amp;quot;Default Method&amp;quot;, &amp;quot;Stream API&amp;quot;, &amp;quot;Date and Time API&amp;quot;);  </div><div class="line"><span class="keyword">for</span> (String feature : features) &#123;  </div><div class="line">    System.out.println(feature);  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//In Java 8:  </span></div><div class="line">List features = Arrays.asList(&amp;quot;Lambdas&amp;quot;, &amp;quot;Default Method&amp;quot;, &amp;quot;Stream API&amp;quot;, &amp;quot;Date and Time API&amp;quot;);  </div><div class="line">features.forEach(n -&amp;gt; System.out.println(n));  </div><div class="line"></div><div class="line"><span class="comment">// 用java8的方法引用更好，方法引用由::(双冒号)操作符来完成,看起来像c++中的作用域操作符 </span></div><div class="line">Java代码  收藏代码</div><div class="line">features.forEach(System.out::println);</div></pre></td></tr></table></figure>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Lambdas </div><div class="line">Default Method </div><div class="line">Stream API </div><div class="line">Date and Time API</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="例4-使用Lambda表达式和函数式接口Predicate"><a href="#例4-使用Lambda表达式和函数式接口Predicate" class="headerlink" title="例4: 使用Lambda表达式和函数式接口Predicate"></a>例4: 使用Lambda表达式和函数式接口Predicate</h3><p>除了提供函数式编程语言级别的支持外，java8同时也新增了一个新的包java.util.function。其中包含了许多类来支持java函数式编程。其中之一是Predicate接口，使用这个接口和lamb表达式就可以以更少的代码为API方法添加更多的动态行为。<br>以下是Predicate的使用范例，展示了过滤集合数据的许多共性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(args[])</span></span>&#123;  </div><div class="line">    List languages = Arrays.asList(&amp;quot;Java&amp;quot;, &amp;quot;Scala&amp;quot;, &amp;quot;C++&amp;quot;, &amp;quot;Haskell&amp;quot;, &amp;quot;Lisp&amp;quot;);  </div><div class="line">    System.out.println(&amp;quot;Languages which starts with J :&amp;quot;);  </div><div class="line">    filter(languages, (str)-&amp;gt;str.startsWith(&amp;quot;J&amp;quot;));  </div><div class="line">    System.out.println(&amp;quot;Languages which ends with a &amp;quot;);  </div><div class="line">    filter(languages, (str)-&amp;gt;str.endsWith(&amp;quot;a&amp;quot;));  </div><div class="line">    System.out.println(&amp;quot;Print all languages :&amp;quot;);  </div><div class="line">    filter(languages, (str)-&amp;gt;<span class="keyword">true</span>);  </div><div class="line">    System.out.println(&amp;quot;Print no language : &amp;quot;);  </div><div class="line">    filter(languages, (str)-&amp;gt;<span class="keyword">false</span>);  </div><div class="line">    System.out.println(&amp;quot;Print language whose length greater than <span class="number">4</span>:&amp;quot;);  </div><div class="line">    filter(languages, (str)-&amp;gt;str.length() &amp;gt; <span class="number">4</span>);  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List names, Predicate condition)</span> </span>&#123;  </div><div class="line">    <span class="keyword">for</span>(String name: names) &#123;  </div><div class="line">        <span class="keyword">if</span>(condition.test(name)) &#123;  </div><div class="line">            System.out.println(name + &amp;quot; &amp;quot;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Languages which starts with J : </div><div class="line">Java </div><div class="line">Languages which ends with a </div><div class="line">Java </div><div class="line">Scala </div><div class="line">Print all languages : </div><div class="line">Java </div><div class="line">Scala </div><div class="line">C++ </div><div class="line">Haskell </div><div class="line">Lisp </div><div class="line">Print no language : </div><div class="line">Print language whose length greater than 4: </div><div class="line">Scala </div><div class="line">Haskell</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//更佳的方式  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List names, Predicate condition)</span> </span>&#123;  </div><div class="line">    names.stream().filter((name) -&amp;gt; (condition.test(name))).forEach((name) -&amp;gt; &#123;  </div><div class="line">        System.out.println(name + &amp;quot; &amp;quot;);  </div><div class="line">    &#125;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到Stream API的filter方法也接受一个Predicate，意味着可以用内联代码直接替换我们自定义的filter()方法。这就是Lambda表达式的威力所在。除此之外Predicate接口也可以测试多个条件，将会在下面的例子中加以说明。</p>
<hr>
<h3 id="例5-Lambda表达式结合Predicate"><a href="#例5-Lambda表达式结合Predicate" class="headerlink" title="例5: Lambda表达式结合Predicate"></a>例5: Lambda表达式结合Predicate</h3><p>就像上个例子所说，Predicate允许组合两个以上的条件，它提供了类似于逻辑与和或的操作and(),or()和xor()，这些方法可以用来组合传递到filter方法中的多个条件。例如为了获取所有以J开头并有四个字符长度的语言，可以定义两个单独的Predicate实例覆盖每个条件然后用and方法将他们组合在一起。看例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Predicate&amp;lt;String&amp;gt; startsWithJ = (n) -&amp;gt; n.startsWith(&amp;quot;J&amp;quot;);  </div><div class="line">Predicate&amp;lt;String&amp;gt; fourLetterLong = (n) -&amp;gt; n.length() == <span class="number">4</span>;  </div><div class="line">names.stream().filter(startsWithJ.and(fourLetterLong)).forEach((n) -&amp;gt; System.out.print(&amp;quot;\nName, which starts with <span class="string">'J'</span> and four letter <span class="keyword">long</span> is : &amp;quot; + n));</div></pre></td></tr></table></figure></p>
<p>类似可以用or或者xor。这个例子也强调了单独用或者按需组合用Predicate的重要性。简而言之用Predicate和Lambda表达式的优势你可以写的更少做得更多。 </p>
<hr>
<h3 id="例6-Map和Reduce的例子"><a href="#例6-Map和Reduce的例子" class="headerlink" title="例6: Map和Reduce的例子"></a>例6: Map和Reduce的例子</h3><h4 id="6-1-Map"><a href="#6-1-Map" class="headerlink" title="6.1 Map"></a>6.1 Map</h4><p>在这个例子中，我们要将costBeforeTax的每个元素以加上他们的增值税。传递一个Lambda表达式给map方法使之应用于每个元素，之后在用forEach打印结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Without lambda expressions:  </span></div><div class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);  </div><div class="line"><span class="keyword">for</span> (Integer cost : costBeforeTax) &#123;  </div><div class="line">    <span class="keyword">double</span> price = cost + .<span class="number">12</span>*cost;  </div><div class="line">    System.out.println(price);  </div><div class="line">&#125;   </div><div class="line"><span class="comment">// With Lambda expression:  </span></div><div class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);  </div><div class="line">costBeforeTax.stream().map((cost) -&amp;gt; cost + .<span class="number">12</span>*cost).forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">112.0 </div><div class="line">224.0 </div><div class="line">336.0 </div><div class="line">448.0 </div><div class="line">560.0 </div><div class="line">112.0 </div><div class="line">224.0 </div><div class="line">336.0 </div><div class="line">448.0 </div><div class="line">560.0</div></pre></td></tr></table></figure></p>
<h4 id="6-2-Reduce"><a href="#6-2-Reduce" class="headerlink" title="6.2 Reduce"></a>6.2 Reduce</h4><p>还有另外一个函数reduce可以将所有值转换为一个值。map跟reduce操作是函数式编程的核心，reduce也被称作折叠操作。reduce并不是一种新的操作，在SQL中我们用的一些聚集函数比如sum，avg，count等他们实际上也是reduce操作，因为他们也是将多个值进行操作然后返回一个值。Stream API定义了reduce函数，可以接受一个Lambda表达式然后组合所有值。Stream类中像IntStream都有内置的方法像average(), count(), sum(), mapToLong(), mapToDouble()等转换方法。我们可以用内置的方法也可以自定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Old way:  </span></div><div class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);  </div><div class="line"><span class="keyword">double</span> total = <span class="number">0</span>;  </div><div class="line"><span class="keyword">for</span> (Integer cost : costBeforeTax) &#123;  </div><div class="line">    <span class="keyword">double</span> price = cost + .<span class="number">12</span>*cost;  </div><div class="line">    total = total + price;  </div><div class="line">&#125;  </div><div class="line">System.out.println(&amp;quot;Total : &amp;quot; + total);  </div><div class="line"><span class="comment">// New way:  </span></div><div class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);  </div><div class="line"><span class="keyword">double</span> bill = costBeforeTax.stream().map((cost) -&amp;gt; cost + .<span class="number">12</span>*cost).reduce((sum, cost) -&amp;gt; sum  </div><div class="line">+ cost).get();  </div><div class="line">System.out.println(&amp;quot;Total : &amp;quot; + bill);</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Total : 1680.0 </div><div class="line">Total : 1680.0</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="例7-用filter创建一个字符串List"><a href="#例7-用filter创建一个字符串List" class="headerlink" title="例7: 用filter创建一个字符串List"></a>例7: 用filter创建一个字符串List</h3><p>在java开发中对大的集合进行过滤是常用的操作。用Lambda表达式和Stream API会让操作变得简单易懂。<br>Stream提供了一个filter()方法，接受一个Predicate对象。这意味着可以传递一个Lambda表达式作为过滤逻辑，看例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个长度大于两个字符的字符串List  </span></div><div class="line">List&amp;lt;String&amp;gt; filtered = strList.stream().filter(x -&amp;gt; x.length()&amp;gt;  </div><div class="line"><span class="number">2</span>).collect(Collectors.toList());  </div><div class="line">System.out.printf(&amp;quot;Original List : %s, filtered list : %s %n&amp;quot;, strList, filtered);</div></pre></td></tr></table></figure></p>
<p>输出 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Original List : [abc, , bcd, , defg, jk], filtered list : [abc, bcd, defg]</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="例8-给每个List元素应用函数"><a href="#例8-给每个List元素应用函数" class="headerlink" title="例8: 给每个List元素应用函数"></a>例8: 给每个List元素应用函数</h3><p>在工作中我们经常会碰到这样的情况：给List中每个元素加以一定的操作例如乘以或者除以某个值等。这些操作用map方法再好不过了，我们可以将转换逻辑以Lambda表达式传给map方法来应用于每个元素：<br>//将字符串转为大写然后用逗号连起来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&amp;lt;String&amp;gt; G7 = Arrays.asList(&amp;quot;USA&amp;quot;, &amp;quot;Japan&amp;quot;, &amp;quot;France&amp;quot;, &amp;quot;Germany&amp;quot;, &amp;quot;Italy&amp;quot;,&amp;quot;U.K.&amp;quot;,&amp;quot;Canada&amp;quot;);  </div><div class="line">String G7Countries = G7.stream().map(x -&amp;gt; x.toUpperCase()).collect(Collectors.joining(&amp;quot;, &amp;quot;));  </div><div class="line">System.out.println(G7Countries);</div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">USA, JAPAN, FRANCE, GERMANY, ITALY, U.K., CANADA</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="例9-复制不同值到子列表"><a href="#例9-复制不同值到子列表" class="headerlink" title="例9: 复制不同值到子列表"></a>例9: 复制不同值到子列表</h3><p>本例演示如何利用Stream类的distinct方法过滤重复值到集合中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(<span class="number">9</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>);  </div><div class="line">List&amp;lt;Integer&amp;gt; distinct = numbers.stream().map( i -&amp;gt;i*i).distinct().collect(Collectors.toList());  </div><div class="line">System.out.printf(&amp;quot;Original List : %s, Square Without duplicates : %s %n&amp;quot;, numbers, distinct);</div></pre></td></tr></table></figure></p>
<p>输出 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Original List : [9, 10, 3, 4, 7, 3, 4], Square Without duplicates : [81, 100, 9, 16, 49]</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="例10-计算List中元素的最大，最小，和以及平均值"><a href="#例10-计算List中元素的最大，最小，和以及平均值" class="headerlink" title="例10: 计算List中元素的最大，最小，和以及平均值"></a>例10: 计算List中元素的最大，最小，和以及平均值</h3><p>在Stream类中像IntStream, LongStream and DoubleStream有一个非常有用的方法summaryStattics()，返回IntSummaryStatistics, LongSummaryStatistics or DoubleSummaryStatistics其描述了这个流中元素的统计数据。下面的例子中我们用这个方法来计算一个List中的最大最小值总和以及均值:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&amp;lt;Integer&amp;gt; primes = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>);  </div><div class="line">IntSummaryStatistics stats = primes.stream().mapToInt((x) -&amp;gt; x).summaryStatistics();  </div><div class="line">System.out.println(&amp;quot;Highest prime number in List : &amp;quot; + stats.getMax());  </div><div class="line">System.out.println(&amp;quot;Lowest prime number in List : &amp;quot; + stats.getMin());  </div><div class="line">System.out.println(&amp;quot;Sum of all prime numbers : &amp;quot; + stats.getSum());  </div><div class="line">System.out.println(&amp;quot;Average of all prime numbers : &amp;quot; + stats.getAverage());</div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Highest prime number in List : 29 </div><div class="line">Lowest prime number in List : 2 </div><div class="line">Sum of all prime numbers : 129 </div><div class="line">Average of all prime numbers : 12.9</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;例1-用Lambda表达式实现Runnable接口&quot;&gt;&lt;a href=&quot;#例1-用Lambda表达式实现Runnable接口&quot; class=&quot;headerlink&quot; title=&quot;例1: 用Lambda表达式实现Runnable接口&quot;&gt;&lt;/a&gt;例1: 用Lambda表达式实现Runnable接口&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Before Java 8:  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&amp;amp;quot;Before Java8, too much code &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; too little to do&amp;amp;quot;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).start();  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Java 8 way:  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread( () -&amp;amp;gt; System.out.println(&amp;amp;quot;In Java8, Lambda expression rocks !!&amp;amp;quot;) ).start();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;too much code, for too little to do &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Lambda expression rocks !!&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子使我们学到了java8中Lambda表达式的书写方式：&lt;br&gt;(参数) -&amp;gt; 表达式&lt;br&gt;(参数) -&amp;gt; 语句&lt;br&gt;(参数) -&amp;gt; { 语句 }&lt;br&gt;例如，如果你的方法只是在控制台打印信息，则可以这么写： &lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;() -&amp;amp;gt; System.out.println(&amp;amp;quot;Hello Lambda Expressions&amp;amp;quot;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你的方法接收两个参数，那么：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; even, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; odd) -&amp;amp;gt; even + odd&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;顺带提一句，一般来说在Lambda表达式中要尽量保持变量的简洁性。这会使你的代码简短而能保持在一行之内。所以像上面的代码可以选择变量名类似a,b或者x,y之类的，比起even和odd来会更好。 &lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Python之在Windows 7下安装PIL</title>
    <link href="http://yoursite.com/2015/10/22/Python%E4%B9%8B%E5%9C%A8Windows%207%E4%B8%8B%E5%AE%89%E8%A3%85PIL/"/>
    <id>http://yoursite.com/2015/10/22/Python之在Windows 7下安装PIL/</id>
    <published>2015-10-21T19:09:28.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在PIL的官方网页上，给出了很多PIL的版本，当选择Win32版本在Windows 7下安装时，会报出无法找到Python的提示，即使正确安装了Python 2.7。在网上查阅后，有人如下回答：</p>
<p>问题：<br>在64位Win7下安装PIL库，提示注册表中找不到Python2.7（肯定是有的）。<br>原因：<br>PIL官方<a href="http://www.pythonware.com/products/pil/提供的PIL二进制安装库都是32位的。" target="_blank" rel="external">http://www.pythonware.com/products/pil/提供的PIL二进制安装库都是32位的。</a><br>64位程序和32位程序检测注册表的位置是不一样的：<br>64-bit: HKLM|HKCU\SOFTWARE\<br>32-bit: HKLM|HKCU\SOFTWARE\wow6432node\<br>我安装的是Python2.7 x64版，所以相关信息是在 HKLM|HKCU\SOFTWARE\下面，32位程序在HKLM|HKCU\SOFTWARE\wow6432node\下面找Python安装信息，肯定是找不到了。<br>解决：<br>幸好有人提供了非官方的64位库（官方源码编译版）。<br><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p>
<p>在提供的网址下，下载PIL 64位的版本，果然可以用了。</p>
<p>注：在linux下安装PIL for Python3.x，可以到<a href="https://github.com/sloonz/pil-py3k下载相应版本。" target="_blank" rel="external">https://github.com/sloonz/pil-py3k下载相应版本。</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在PIL的官方网页上，给出了很多PIL的版本，当选择Win32版本在Windows 7下安装时，会报出无法找到Python的提示，即使正确安装了Python 2.7。在网上查阅后，有人如下回答：&lt;/p&gt;
&lt;p&gt;问题：&lt;br&gt;在64位Win7下安装PIL库，提示注册表中找不到
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Ruby操作mysql数据库及中文编码解决方案</title>
    <link href="http://yoursite.com/2015/07/11/Ruby%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2015/07/11/Ruby操作mysql数据库及中文编码解决方案/</id>
    <published>2015-07-11T01:46:19.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>搭建ruby mysql环境<br>1. 安装ruby2.2.1<br>2. 安装mysql插件<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install mysql</div></pre></td></tr></table></figure></p>
<p>3. 数据库编码修改<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'mysql'</span></div><div class="line"><span class="keyword">begin</span> </div><div class="line">db = Mysql.init db.options(Mysql::SET_CHARSET_NAME, <span class="string">'utf8'</span>) </div><div class="line">db = Mysql.real_connect(<span class="comment">#&#123;host&#125;, #&#123;username&#125;, #&#123;passwd&#125;, #&#123;dbname&#125;,3306)</span></div><div class="line">db.query(&amp;quot;SET NAMES utf8&amp;quot;) </div><div class="line">db.query(&amp;quot;drop table <span class="keyword">if</span> exists test_rb&amp;quot;)</div><div class="line">db.query(&amp;quot;create table test_rb (id int,text [...]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>4.ruby文件的编码：<br>加入<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># encoding: utf-8</span></div></pre></td></tr></table></figure></p>
<p>通过下面的语句可以查看编码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">puts __ENCODING_<span class="number">_</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建ruby mysql环境&lt;br&gt;1. 安装ruby2.2.1&lt;br&gt;2. 安装mysql插件&lt;br&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1
    
    </summary>
    
      <category term="Ruby" scheme="http://yoursite.com/categories/Ruby/"/>
    
    
      <category term="ruby" scheme="http://yoursite.com/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>Data truncation: Out of range value adjusted for column &quot;***&quot;</title>
    <link href="http://yoursite.com/2015/07/01/com-mysql-jdbc-mysqldatatruncation-data-truncation-out-of-range-value-adjusted-for-column/"/>
    <id>http://yoursite.com/2015/07/01/com-mysql-jdbc-mysqldatatruncation-data-truncation-out-of-range-value-adjusted-for-column/</id>
    <published>2015-07-01T02:53:42.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>com.mysql.jdbc.MysqlDataTruncation: Data truncation: Out of range value adjusted for column &apos;***&apos; at row 1
    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3513)
    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3447)
    at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1951)
    at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2101)
    at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2548)
    at com.mysql.jdbc.StatementImpl.executeUpdate(StatementImpl.java:1605)
    at com.mysql.jdbc.StatementImpl.executeUpdate(StatementImpl.java:1524)
</code></pre><p>出现这个问题的原因有以下几种：<br>1.超过字段的表示范围。<br>2.设置了无符号的字段，却传了负数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;com.mysql.jdbc.MysqlDataTruncation: Data truncation: Out of range value adjusted for column &amp;apos;***&amp;apos; at row 1
    at com.m
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>[转]Git 常用命令大全</title>
    <link href="http://yoursite.com/2015/06/24/%5B%E8%BD%AC%5DGit%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2015/06/24/[转]Git 常用命令大全/</id>
    <published>2015-06-23T19:16:35.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。<br>Git常用操作命令：<br>1) 远程仓库相关命令<br>检出仓库：$ git clone git://github.com/jquery/jquery.git<br>查看远程仓库：$ git remote -v<br>添加远程仓库：$ git remote add [name] [url]<br>删除远程仓库：$ git remote rm [name]<br>修改远程仓库：$ git remote set-url –push [name] [newUrl]<br>拉取远程仓库：$ git pull [remoteName] [localBranchName]<br>推送远程仓库：$ git push [remoteName] [localBranchName]</p>
<p>*如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：<br>$git push origin test:master         // 提交本地test分支作为远程的master分支<br>$git push origin test:test              // 提交本地test分支作为远程的test分支<br><a id="more"></a><br>2）分支(branch)操作相关命令<br>查看本地分支：$ git branch<br>查看远程分支：$ git branch -r<br>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支<br>切换分支：$ git checkout [name]<br>创建新分支并立即切换到新分支：$ git checkout -b [name]<br>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项<br>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并<br>创建远程分支(本地分支push到远程)：$ git push origin [name]<br>删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] </p>
<p>*创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)<br>$git symbolic-ref HEAD refs/heads/[name]<br>$rm .git/index<br>$git clean -fdx</p>
<p>3）版本(tag)操作相关命令<br>查看版本：$ git tag<br>创建版本：$ git tag [name]<br>删除版本：$ git tag -d [name]<br>查看远程版本：$ git tag -r<br>创建远程版本(本地版本push到远程)：$ git push origin [name]<br>删除远程版本：$ git push origin :refs/tags/[name]<br>合并远程仓库的tag到本地：$ git pull origin –tags<br>上传本地tag到远程仓库：$ git push origin –tags<br>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</p>
<p>4) 子模块(submodule)相关操作命令<br>添加子模块：$ git submodule add [url] [path]<br>   如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs<br>初始化子模块：$ git submodule init  —-只在首次检出仓库时运行一次就行<br>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下<br>删除子模块：（分4步走哦）<br> 1) $ git rm –cached [path]<br> 2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉<br> 3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉<br> 4) 手动删除子模块残留的目录</p>
<p>5）忽略一些文件、文件夹不提交<br>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如<br>target<br>bin<br>*.db</p>
<p>=====================<br>Git 常用命令<br>git branch 查看本地所有分支<br>git status 查看当前状态<br>git commit 提交<br>git branch -a 查看所有的分支<br>git branch -r 查看本地所有分支<br>git commit -am “init” 提交并且加注释<br>git remote add origin git@192.168.1.119:ndshow<br>git push origin master 将文件给推到服务器上<br>git remote show origin 显示远程库origin里的资源<br>git push origin master:develop<br>git push origin master:hb-dev 将本地库与服务器上的库进行关联<br>git checkout –track origin/dev 切换到远程dev分支<br>git branch -D master develop 删除本地库develop<br>git checkout -b dev 建立一个新的本地分支dev<br>git merge origin/dev 将分支dev与当前分支进行合并<br>git checkout dev 切换到本地dev分支<br>git remote show 查看远程库<br>git add .<br>git rm 文件名(包括路径) 从git中删除指定文件<br>git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来<br>git config –list 看所有用户<br>git ls-files 看已经被提交的<br>git rm [file name] 删除一个文件<br>git commit -a 提交当前repos的所有的改变<br>git add [file name] 添加一个文件到git index<br>git commit -v 当你用－v参数的时候可以看commit的差异<br>git commit -m “This is the message describing the commit” 添加commit信息<br>git commit -a -a是代表add，把所有的change加到git index里然后再commit<br>git commit -a -v 一般提交命令<br>git log 看你commit的日志<br>git diff 查看尚未暂存的更新<br>git rm a.a 移除文件(从暂存区和工作区中删除)<br>git rm –cached a.a 移除文件(只从暂存区中删除)<br>git commit -m “remove” 移除文件(从Git中删除)<br>git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)<br>git diff –cached 或 $ git diff –staged 查看尚未提交的更新<br>git stash push 将文件给push到一个临时空间中</p>
<h2 id="git-stash-pop-将文件从临时空间pop下来"><a href="#git-stash-pop-将文件从临时空间pop下来" class="headerlink" title="git stash pop 将文件从临时空间pop下来"></a>git stash pop 将文件从临时空间pop下来</h2><p>git remote add origin git@github.com:username/Hello-World.git</p>
<h2 id="git-push-origin-master-将本地项目给提交到服务器中"><a href="#git-push-origin-master-将本地项目给提交到服务器中" class="headerlink" title="git push origin master 将本地项目给提交到服务器中"></a>git push origin master 将本地项目给提交到服务器中</h2><h2 id="git-pull-本地与服务器端同步"><a href="#git-pull-本地与服务器端同步" class="headerlink" title="git pull 本地与服务器端同步"></a>git pull 本地与服务器端同步</h2><p>git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。</p>
<h2 id="git-push-origin-serverfix-awesomebranch"><a href="#git-push-origin-serverfix-awesomebranch" class="headerlink" title="git push origin serverfix:awesomebranch"></a>git push origin serverfix:awesomebranch</h2><p>git fetch 相当于是从远程获取最新版本到本地，不会自动merge<br>git commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：<br>git branch branch_0.1 master 从主分支master创建branch_0.1分支<br>git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0<br>git checkout branch_1.0/master 切换到branch_1.0/master分支<br>du -hs</p>
<hr>
<p>mkdir WebApp<br>cd WebApp<br>git init<br>touch README<br>git add README<br>git commit -m ‘first commit’<br>git remote add origin git@github.com:daixu/WebApp.git<br>git push -u origin master</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。&lt;br&gt;Git常用操作命令：&lt;br&gt;1) 远程仓库相关命令&lt;br&gt;检出仓库：$ git clone git://github.com/jquery/jquery.git&lt;br&gt;查看远程仓库：$ git remote -v&lt;br&gt;添加远程仓库：$ git remote add [name] [url]&lt;br&gt;删除远程仓库：$ git remote rm [name]&lt;br&gt;修改远程仓库：$ git remote set-url –push [name] [newUrl]&lt;br&gt;拉取远程仓库：$ git pull [remoteName] [localBranchName]&lt;br&gt;推送远程仓库：$ git push [remoteName] [localBranchName]&lt;/p&gt;
&lt;p&gt;*如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：&lt;br&gt;$git push origin test:master         // 提交本地test分支作为远程的master分支&lt;br&gt;$git push origin test:test              // 提交本地test分支作为远程的test分支&lt;br&gt;
    
    </summary>
    
      <category term="Other" scheme="http://yoursite.com/categories/Other/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 之 View，ViewResolver</title>
    <link href="http://yoursite.com/2015/06/06/Spring%20MVC%20%E4%B9%8B%20View%EF%BC%8CViewResolver/"/>
    <id>http://yoursite.com/2015/06/06/Spring MVC 之 View，ViewResolver/</id>
    <published>2015-06-06T03:35:14.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、概念理解</p>
<p>View —View接口表示一个响应给用户的视图，例如jsp文件，pdf文件，html文件等，它的定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="comment">//HttpServletRequest中的属性名，其值为响应状态码</span></div><div class="line">    String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + &amp;quot;.responseStatus&amp;quot;;</div><div class="line">    <span class="comment">//HttpServletRequest中的属性名，前一篇文章用到了该变量，它的对应值是请求路径中的变量，及@PathVariable</span></div><div class="line">    <span class="comment">//注解的变量</span></div><div class="line">    String PATH_VARIABLES = View.class.getName() + &amp;quot;.pathVariables&amp;quot;;</div><div class="line">    <span class="comment">//该视图的ContentType</span></div><div class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//渲染该视图</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&amp;lt;String, ?&amp;gt; model, HttpServletRequest request, HttpServletResponse response)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   该接口只有两个方法定义，分别表明该视图的ContentType和如何被渲染。Spring中提供了丰富的视图支持，几乎包含所有你想得到的，并且Spring的视图拓展性很好，你可以轻松实现自己的视图。</p>
<p>ViewResolver — ViewResolver接口定义了如何通过view 名称来解析对应View实例的行为，它的定义相当简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewResolver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该接口只有一个方法，通过view name 解析出View。同样Spring提供了丰富的ViewResolver实现用来解析不同的View：<br><a id="more"></a><br>二、获取ModelAndView</p>
<pre><code>上一篇文章我们分析了处理器方法如何被调用以及获取了返回值，但是Spring是如何处理返回值并响应给客户呢？这就是这节要分析的，根据返回值解析出对应的视图。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">invokeHandleMethod</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line">            HttpServletResponse response, HandlerMethod handlerMethod) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">        ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</div><div class="line"></div><div class="line">        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</div><div class="line">        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</div><div class="line">        ServletInvocableHandlerMethod requestMappingMethod = </div><div class="line">                                    createRequestMappingMethod(handlerMethod, binderFactory);</div><div class="line"></div><div class="line">        ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</div><div class="line">        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</div><div class="line">        modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</div><div class="line">        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</div><div class="line"></div><div class="line">        AsyncExecutionChain chain = AsyncExecutionChain.getForCurrentRequest(request);</div><div class="line">        chain.addDelegatingCallable(getAsyncCallable(mavContainer, modelFactory, webRequest));</div><div class="line">        chain.setAsyncWebRequest(createAsyncWebRequest(request, response));</div><div class="line">        chain.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</div><div class="line">        <span class="comment">//上一篇文章分析到这里，调用了处理器方法并处理了返回值</span></div><div class="line">        requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (chain.isAsyncStarted()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//这里是根据返回值返回ModelAndView了</span></div><div class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>   上面的代码在上一篇文章中已经分析到了invokeAndHandle方法，该方法调用了处理器方法，并处理了返回值，剩下的就是如何将返回值呈现给用户了，我们看getModelAndView的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">getModelAndView</span><span class="params">(ModelAndViewContainer mavContainer,</span></span></div><div class="line">            ModelFactory modelFactory, NativeWebRequest webRequest) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">//主要是同步model属性，并且将BindingResult添加到model中来</span></div><div class="line">        modelFactory.updateModel(webRequest, mavContainer);</div><div class="line">        <span class="comment">//是否直接处理请求，如@ResponseBody</span></div><div class="line">        <span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        ModelMap model = mavContainer.getModel();</div><div class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(mavContainer.getViewName(), model);</div><div class="line">        <span class="keyword">if</span> (!mavContainer.isViewReference()) &#123;</div><div class="line">            mav.setView((View) mavContainer.getView());</div><div class="line">        &#125;<span class="comment">//如果model是RedirectAttributes，进行flashAttributes的处理</span></div><div class="line">        <span class="comment">//即将flashAttribute属性添加到request的Output FlashMap中，以被重定向后的request获取</span></div><div class="line">        <span class="keyword">if</span> (model <span class="keyword">instanceof</span> RedirectAttributes) &#123;</div><div class="line">            Map&amp;lt;String, ?&amp;gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</div><div class="line">            HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</div><div class="line">            RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mav;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   上面的代码是根据方法执行完后生成的model和视图名等信息生成ModelAndView对象，该对象维护了一个View和Model的对应关系，以便在View中可以访问Model的属性。</p>
<p>三、RedirectAttributes    </p>
<pre><code>上面的代码还有一个对RedirectAttributes的处理，这里我们来分析下是个什么回事？我们知道request中的属性只能在request范围内访问到，一旦执行重定向，重定向后的request并访问不到前面设置的属性了，虽然放到Session中可以在不同的request中共享这些属性，但是有时候放到Session中显得没有必要，毕竟很多属性只需要在“某次操作”中有用（重定向操作对用户来说其实是一次操作，因为重定向是浏览器执行的，对用户透明的。

因此为了解决这个问题，Spring引入了RedirectAttributes概念，即添加到RedirectAttributes中的属性，在重定向后依旧可以获取到，并且获取到以后，这些属性就会失效，新的request便无法获取了，这样就方便了开发者，同样也节省了内错占用。

那Spring是怎么实现的呢？这里牵扯到了FlashMap这一概念，Spring会默认为每一个请求添加两个FlashMap属性，一个是InputFlashMap，另一个是OutputFlashMap，其中InputFlashMap便包含了上一个请求在重定向到该请求前设置的属性值，也就是上一个请求的OutputFlashMap，看下面的图方便理解：

下面是DispatcherServlet中doService中的代码片段，在调用doDispatch前便设置了InputFlashmap和OutputFlashMap：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//尝试获取该request的InputFlashMap</span></div><div class="line">FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</div><div class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</div><div class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, </div><div class="line">                                                Collections.unmodifiableMap(inputFlashMap));</div><div class="line">        &#125;</div><div class="line"><span class="comment">//设置该请求的OutputFlashMap</span></div><div class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</div><div class="line"><span class="comment">//设置该请求的FlashMapManager，用来管理InputFlashMap和OutputFlashMap</span></div><div class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</div></pre></td></tr></table></figure>
<p>四、视图解析</p>
<pre><code>了解了FlashMap的概念我们继续往下看，前面我们已经获取到了请求的ModelAndView对象，这时invokeHandleMethod执行完毕将控制权交给了doDispatch，我们看怎么处理ModelAndView：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line"><span class="keyword">if</span> (asyncChain.isAsyncStarted()) &#123;<span class="comment">///异步调用，暂不关心</span></div><div class="line">        mappedHandler.applyPostHandleAsyncStarted(processedRequest, response);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">&#125;<span class="comment">//如果ModelAndView中没有设置视图名，则设置默认视图（大致是prefix/请求路径/suffix）</span></div><div class="line">applyDefaultViewName(request, mv);</div><div class="line"><span class="comment">//执行拦截器的后处理器</span></div><div class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</div><div class="line"><span class="comment">//处理分派结果，响应用户</span></div><div class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</div></pre></td></tr></table></figure>
<p>   重点就在最后一行，我们继续追踪：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></div><div class="line">            HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) &#123;</div><div class="line">        <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//出现异常，进行异常处理，暂不关心</span></div><div class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</div><div class="line">                logger.debug(&amp;quot;ModelAndViewDefiningException encountered&amp;quot;, exception);</div><div class="line">                mv = ((ModelAndViewDefiningException) exception).getModelAndView();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</div><div class="line">                mv = processHandlerException(request, response, handler, exception);</div><div class="line">                errorView = (mv != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果返回View需要渲染？</span></div><div class="line">        <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;amp;&amp;amp; !mv.wasCleared()) &#123;</div><div class="line">            <span class="comment">//惊醒视图的渲染，我们主题</span></div><div class="line">            render(mv, request, response);</div><div class="line">            <span class="keyword">if</span> (errorView) &#123;</div><div class="line">                WebUtils.clearErrorRequestAttributes(request);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//调用拦截器的afterComplete</span></div><div class="line">        <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</div><div class="line">            mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   上面的代码我们着重看render方法是怎样实现的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">protected void render(ModelAndView mv,HttpServletRequest request,HttpServletResponse response)&#123;</div><div class="line">        // 确定当前请求的Locale，并设置Response</div><div class="line">        Locale locale = this.localeResolver.resolveLocale(request);</div><div class="line">        response.setLocale(locale);</div><div class="line"></div><div class="line">        View view;//ModelAndView中的View还只是名称，需要解析成View对象</div><div class="line">        if (mv.isReference()) &#123;</div><div class="line">            view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);</div><div class="line">            if (view == null) &#123;</div><div class="line">                throw new ServletException(</div><div class="line">                        &amp;quot;Could not resolve view with name '&amp;quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;//直接获取视图对象</div><div class="line">            view = mv.getView();</div><div class="line">            if (view == null) &#123;</div><div class="line">                throw new ServletException(&amp;quot;ModelAndView [&amp;quot; + mv + &amp;quot;] &amp;quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //委托视图对象进行渲染</div><div class="line">        view.render(mv.getModelInternal(), request, response);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   上面的代码涉及了两个重要步骤，视图名的解析和视图的渲染，这一小节我们来讲解视图名的解析，也就是ViewResolver了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">resolveViewName</span><span class="params">(String viewName, Map&amp;lt;String, Object&amp;gt; model, Locale locale,</span></span></div><div class="line">            HttpServletRequest request) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="keyword">for</span> (ViewResolver viewResolver : <span class="keyword">this</span>.viewResolvers) &#123;</div><div class="line">            View view = viewResolver.resolveViewName(viewName, locale);</div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> view;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<pre><code>我们查看resolveViewName方法，发现其中有一个viewResolvers实例变量，如果你看过前面的几篇文章，你获取会记得handlerMappings, handlerAdapters等变量，不错他们是一伙的，都是在DispatcherServlet初始化时完成设置的，并且我们可以在配置文件中定义我们自己的HandleMappings， HandlerAdapters，ViewResolvers等（这里不讲解怎样设置了），但是如果我们不设置的话Spring也会为我们设置一些默认值：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">org.springframework.web.servlet.HandlerMapping =</div><div class="line">                org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</div><div class="line">                org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerAdapter=</div><div class="line">                org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</div><div class="line">                org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</div><div class="line">                org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerExceptionResolver=</div><div class="line">    org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</div><div class="line">    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</div><div class="line">    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.RequestToViewNameTranslator=</div><div class="line">                org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class="line"></div><div class="line">org.springframework.web.servlet.ViewResolver=</div><div class="line">                            org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.FlashMapManager=</div><div class="line">                    org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure>
<p>   上面代码片段来自Spring MVC包中的DispatcherServlet.properties属性文件中，这里Spring为我们默认设置了诸多处理器，解析器等，可以看出在我们不进行ViewResolver设置的情况下，默认实现是InternalResourceViewResolver。我们知道，InternalResourceViewResolver继承自UrlBasedViewResolver， 而UrlBasedViewResolver继承自AbstractCachingViewResolver，其实这就是Spring的聪明之处，为了提高性能，Spring中充斥着缓存策略，在试图解析中也使用了缓存。这样只需在第一次解析时完成整个的视图创建工作，后续的请求只需从缓存中索取即可了。</p>
<pre><code>这里的InternalResourceViewResolver主要是用来支持Jsp文件的，换句话说，如果你的系统中只用到了jsp文件而没有模板引擎等框架，这个ViewResolver就够你用了，你也就无需在配置文件中多此一举的写上该ViewResolver了。下面我们就来看它的实现吧：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//如果没有被缓存呢，只能创建了</span></div><div class="line">        <span class="keyword">if</span> (!isCache()) &#123;</div><div class="line">            <span class="keyword">return</span> createView(viewName, locale);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;<span class="comment">//检索缓存中的视图对象</span></div><div class="line">            Object cacheKey = getCacheKey(viewName, locale);</div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.viewCache) &#123;</div><div class="line">                View view = <span class="keyword">this</span>.viewCache.get(cacheKey);</div><div class="line">                <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;amp;&amp;amp; (!<span class="keyword">this</span>.cacheUnresolved </div><div class="line">                                                || !<span class="keyword">this</span>.viewCache.containsKey(cacheKey))) &#123;</div><div class="line">                    <span class="comment">// Ask the subclass to create the View object.</span></div><div class="line">                    view = createView(viewName, locale);</div><div class="line">                    <span class="keyword">if</span> (view != <span class="keyword">null</span> || <span class="keyword">this</span>.cacheUnresolved) &#123;</div><div class="line">                        <span class="keyword">this</span>.viewCache.put(cacheKey, view);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> view;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>   方法很简单，我们接着看是怎样创建视图的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">createView</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 当前ViewResolver无法解析该视图名，返回null</span></div><div class="line">        <span class="keyword">if</span> (!canHandle(viewName, locale)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// view名称以redirect:开头，即重定向视图解析</span></div><div class="line">        <span class="keyword">if</span> (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123;</div><div class="line">            String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());</div><div class="line">            RedirectView view = <span class="keyword">new</span> RedirectView(redirectUrl, isRedirectContextRelative()</div><div class="line">                                                               , isRedirectHttp10Compatible());</div><div class="line">            <span class="keyword">return</span> applyLifecycleMethods(viewName, view);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// view名称以forward:开头，即转发视图解析</span></div><div class="line">        <span class="keyword">if</span> (viewName.startsWith(FORWARD_URL_PREFIX)) &#123;</div><div class="line">            String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InternalResourceView(forwardUrl);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 正常情况下，让父类创建吧</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.createView(viewName, locale);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   创建视图时，Spring会检查视图名，有三种情况redirect视图，forward视图，普通视图，进行了不同处理。对于redirect视图，spring获取redirectURL并创建了RedirectView对象，然后执行了一下bean实例的生命周期方法，没什么实质性东西，我们不关心。对于转发视图，创建了InternalResourceView对象，上面说的这两种对象的渲染过程我们过会会降到的。这里大家先记住。第三种情况呢，又交给了父类处理，我们继续看看吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">createView</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">return</span> loadView(viewName, locale);</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">loadView</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        AbstractUrlBasedView view = buildView(viewName);</div><div class="line">        View result = applyLifecycleMethods(viewName, view);</div><div class="line">        <span class="keyword">return</span> (view.checkResource(locale) ? result : <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   父类的createView方法又委托给了loadView，而loadView是抽象的由子类实现，我们继续看loadView中有一个buildView方法，看着不错哦：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> AbstractUrlBasedView <span class="title">buildView</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//根据ViewClass实例化该Class</span></div><div class="line">        AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils</div><div class="line">                                                            .instantiateClass(getViewClass());</div><div class="line">        <span class="comment">//设置视图的url，prefix/viewName/suffix</span></div><div class="line">        view.setUrl(getPrefix() + viewName + getSuffix());</div><div class="line">        String contentType = getContentType();</div><div class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;<span class="comment">//设置ContentType</span></div><div class="line">            view.setContentType(contentType);</div><div class="line">        &#125;<span class="comment">//设置请求上下文属性</span></div><div class="line">        view.setRequestContextAttribute(getRequestContextAttribute());</div><div class="line">        view.setAttributesMap(getAttributesMap());</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.exposePathVariables != <span class="keyword">null</span>) &#123;<span class="comment">//设置是否暴露PathVariable</span></div><div class="line">            view.setExposePathVariables(exposePathVariables);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   上面的代码又出来个ViewClass， prefix，suffix，他们又是个什么东西呢？其实我们知道在配置InternalResourceViewResolver时可以指定一个viewClass，prefix，suffix，没错，就是他们，先说prefix，suffix，我们看到了它会分别添加到viewName的前后，组成视图的URL。那个viewClass就是视图的class对象类型了。我们看InternalResourceViewResolver的构造器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InternalResourceViewResolver</span><span class="params">()</span> </span>&#123;</div><div class="line">        Class viewClass = requiredViewClass();</div><div class="line">        <span class="keyword">if</span> (viewClass.equals(InternalResourceView.class) &amp;amp;&amp;amp; jstlPresent) &#123;</div><div class="line">            viewClass = JstlView.class;</div><div class="line">        &#125;</div><div class="line">        setViewClass(viewClass);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   会发现在我们没有指定的情况下默认是JstlView哦。它继承自InternalResourceView。到此为止我们的视图对象已经创建完毕。</p>
<pre><code>我们这里只解析了Spring默认情况下的InternalResourceViewResolver的解析过程，默认情况下解析的视图类型是JstlView。如果是Redirect的话则是RedirectView。
</code></pre><p>五、视图渲染</p>
<pre><code>视图解析出来了，下面就是要将视图渲染给用户显示了。这里我们依旧只讲解默认的JstlView的渲染过程，当然还有RedirectView的。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&amp;lt;String, ?&amp;gt; model, HttpServletRequest request, </span></span></div><div class="line">                                                HttpServletResponse response) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">        Map&amp;lt;String, Object&amp;gt; mergedModel = createMergedOutputModel(model, request, response);</div><div class="line"></div><div class="line">        prepareResponse(request, response);</div><div class="line">        renderMergedOutputModel(mergedModel, request, response);</div><div class="line">&#125;</div><div class="line"><span class="keyword">protected</span> Map&amp;lt;String, Object&amp;gt; createMergedOutputModel(Map&amp;lt;String, ?&amp;gt; model, </div><div class="line">                            HttpServletRequest request, HttpServletResponse response) &#123;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(&amp;quot;unchecked&amp;quot;)</div><div class="line">        <span class="comment">//如果需要保留PathVariable</span></div><div class="line">        Map&amp;lt;String, Object&amp;gt; pathVars = <span class="keyword">this</span>.exposePathVariables ?</div><div class="line">            (Map&amp;lt;String, Object&amp;gt;) request.getAttribute(View.PATH_VARIABLES) : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">//联合动态和静态属性</span></div><div class="line">        <span class="keyword">int</span> size = <span class="keyword">this</span>.staticAttributes.size();</div><div class="line">        size += (model != <span class="keyword">null</span>) ? model.size() : <span class="number">0</span>;</div><div class="line">        size += (pathVars != <span class="keyword">null</span>) ? pathVars.size() : <span class="number">0</span>;</div><div class="line">        Map&amp;lt;String, Object&amp;gt; mergedModel = <span class="keyword">new</span> HashMap&amp;lt;String, Object&amp;gt;(size);</div><div class="line">        mergedModel.putAll(<span class="keyword">this</span>.staticAttributes);</div><div class="line">        <span class="keyword">if</span> (pathVars != <span class="keyword">null</span>) &#123;</div><div class="line">            mergedModel.putAll(pathVars);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (model != <span class="keyword">null</span>) &#123;</div><div class="line">            mergedModel.putAll(model);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Expose RequestContext?</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.requestContextAttribute != <span class="keyword">null</span>) &#123;</div><div class="line">            mergedModel.put(<span class="keyword">this</span>.requestContextAttribute, </div><div class="line">                                        createRequestContext(request, response, mergedModel));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> mergedModel;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   上面代码是AbstractView中的方法，也就是所有视图都会执行的操作，就是将静态属性和动态生成的属性合并，我们重点看</p>
<p>renderMergedOutputModel方法，子类会覆盖该方法，实现不同的逻辑。我们来看JstlView和RedirectView的实现，首先JstlView :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">renderMergedOutputModel</span><span class="params">(</span></span></div><div class="line">            Map&amp;lt;String, Object&amp;gt; model, HttpServletRequest request,HttpServletResponse response)&#123;</div><div class="line"></div><div class="line">        <span class="comment">//确定执行请求转发的request对象</span></div><div class="line">        HttpServletRequest requestToExpose = getRequestToExpose(request);</div><div class="line">        <span class="comment">//将model中的属性暴露为请求属性表中</span></div><div class="line">        exposeModelAsRequestAttributes(model, requestToExpose);</div><div class="line">        <span class="comment">//暴露MessageResource</span></div><div class="line">        exposeHelpers(requestToExpose);</div><div class="line">        <span class="comment">//确定转发的路径，也就是View的URL，但会检查是否会进入死循环，即跟当前请求同一个路径</span></div><div class="line">        String dispatcherPath = prepareForRendering(requestToExpose, response);</div><div class="line">        <span class="comment">//生成RequestDispatcher对象</span></div><div class="line">        RequestDispatcher rd = getRequestDispatcher(requestToExpose, dispatcherPath);</div><div class="line">        <span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(&amp;quot;Could not get RequestDispatcher <span class="keyword">for</span> [&amp;quot; + getUrl() +&amp;quot;]&amp;quot;);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//include操作</span></div><div class="line">        <span class="keyword">if</span> (useInclude(requestToExpose, response)) &#123;</div><div class="line">            response.setContentType(getContentType());</div><div class="line">            rd.include(requestToExpose, response);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//执行转发，暴露属性到转发请求中</span></div><div class="line">            exposeForwardRequestAttributes(requestToExpose);</div><div class="line">            rd.forward(requestToExpose, response);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  方法看着很长其实思路比较简单，主要就是调用了RequestDispatcher的include 或forward的方法，将请求转发到指定URL。JstlView的视图渲染相对简单，我们来看RedirectView的渲染：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">renderMergedOutputModel</span><span class="params">(</span></span></div><div class="line">            Map&amp;lt;String, Object&amp;gt; model, HttpServletRequest request, HttpServletResponse response)</div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="comment">//获取重定向的路径，也就是前面生成RedirectView时设置的URL，但会进行相对路径的处理</span></div><div class="line">        String targetUrl = createTargetUrl(model, request);</div><div class="line">        <span class="comment">//调用用户注册的RequestDataValueProcessor的process方法，通常用不到，不管</span></div><div class="line">        targetUrl = updateTargetUrl(targetUrl, model, request, response);</div><div class="line">        <span class="comment">//这里就是上面讲到的FlashMap的处理啦，是怎样实现的呢？</span></div><div class="line">        <span class="comment">//我们知道前面将RedirectAttributes的属性都设置到了当前请求的OutputFlashMap中了，这里再取出来。</span></div><div class="line">        <span class="comment">//设置flashMap的目标请求路径，用来比对下次请求的路径，如果匹配，将其中的属性设置到请求属性表中</span></div><div class="line">        FlashMap flashMap = RequestContextUtils.getOutputFlashMap(request);</div><div class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(flashMap)) &#123;</div><div class="line">            UriComponents uriComponents = UriComponentsBuilder.fromUriString(targetUrl).build();</div><div class="line">            flashMap.setTargetRequestPath(uriComponents.getPath());</div><div class="line">            flashMap.addTargetRequestParams(uriComponents.getQueryParams());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将flashMap交由FlashMapManager管理。</span></div><div class="line">        FlashMapManager flashMapManager = RequestContextUtils.getFlashMapManager(request);</div><div class="line">        flashMapManager.saveOutputFlashMap(flashMap, request, response);</div><div class="line">        <span class="comment">//返回结果，设置响应头304.</span></div><div class="line">        sendRedirect(request, response, targetUrl.toString(), <span class="keyword">this</span>.http10Compatible);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   到此为止，我们的试图解析，渲染过程就完全分析完了，获取到目前为止有点晕，其实好好思考下，Spring在视图解析，和渲染这块给了我们足够的拓展空间。</p>
<p>六、总结<br>    Spring对视图的支持相当完善，默认的JSP不用说，PDF，Excel, 等，还包括主流的模板引擎，像FreeMarker， Tiles等，可以参考第一张图片。当然你完全也可以实现自己的View，以及ViewResolver，来解析自定义的视图。不过应该没多大必要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、概念理解&lt;/p&gt;
&lt;p&gt;View —View接口表示一个响应给用户的视图，例如jsp文件，pdf文件，html文件等，它的定义如下&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;View&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//HttpServletRequest中的属性名，其值为响应状态码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + &amp;amp;quot;.responseStatus&amp;amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//HttpServletRequest中的属性名，前一篇文章用到了该变量，它的对应值是请求路径中的变量，及@PathVariable&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//注解的变量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    String PATH_VARIABLES = View.class.getName() + &amp;amp;quot;.pathVariables&amp;amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//该视图的ContentType&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;getContentType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//渲染该视图&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Map&amp;amp;lt;String, ?&amp;amp;gt; model, HttpServletRequest request, HttpServletResponse response)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;   该接口只有两个方法定义，分别表明该视图的ContentType和如何被渲染。Spring中提供了丰富的视图支持，几乎包含所有你想得到的，并且Spring的视图拓展性很好，你可以轻松实现自己的视图。&lt;/p&gt;
&lt;p&gt;ViewResolver — ViewResolver接口定义了如何通过view 名称来解析对应View实例的行为，它的定义相当简单：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewResolver&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;View &lt;span class=&quot;title&quot;&gt;resolveViewName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String viewName, Locale locale)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该接口只有一个方法，通过view name 解析出View。同样Spring提供了丰富的ViewResolver实现用来解析不同的View：&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 之 @RequestMapping（2）</title>
    <link href="http://yoursite.com/2015/06/04/Spring%20MVC%20%E4%B9%8B%20RequestMapping%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2015/06/04/Spring MVC 之 RequestMapping（2）/</id>
    <published>2015-06-04T01:03:25.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、从头开始</p>
<p>   SpringMvc会通过DispatcherServlet来处理所有的请求，展开这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) &#123;</div><div class="line">        HttpServletRequest processedRequest = request;</div><div class="line">        HandlerExecutionChain mappedHandler = null;</div><div class="line">        AsyncExecutionChain asyncChain = AsyncExecutionChain.getForCurrentRequest(request);</div><div class="line">        try &#123;</div><div class="line">            ModelAndView mv = null;</div><div class="line">            Exception dispatchException = null;</div><div class="line">            try &#123;</div><div class="line">                processedRequest = checkMultipart(request);</div><div class="line">                // 确定当前请求的处理器（HandlerExecutionChain 包含Handler和Interceptor列表）</div><div class="line">                mappedHandler = getHandler(processedRequest, false);</div><div class="line">                if (mappedHandler == null || mappedHandler.getHandler() == null) &#123;</div><div class="line">                    noHandlerFound(processedRequest, response);//404异常</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                // 确定当前请求的处理器适配器</div><div class="line">                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</div><div class="line">                //......省略诸多代码......</div><div class="line">                // 调用处理处理器方法，返回ModelAndView对象</div><div class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line">            &#125;//处理返回结果</div><div class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>  下面展开getHandler是怎么做的：<a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//这里有一个handlerMappings实例变量，如果你看过&amp;lt;mvc:annotation-driven/&amp;gt;那篇文章，相信你就知道这</span></div><div class="line">        <span class="comment">//个handlerMappings都包括哪些HandlerMapping实例了？</span></div><div class="line">        <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</div><div class="line">            HandlerExecutionChain handler = hm.getHandler(request);</div><div class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> handler;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   <mvc:annotation-driven>这篇博客中说明了在启用该标签时Spring会默认注册RequestMappingHandlerMapping实例在处理@RequestMapping注解，而@RequestMapping (1) 这篇博客说明了该HandlerMapping是如何处理@RequestMapping注解，以及怎么保存请求映射关系的。下面我们就看RequestMappingHandlerMapping的getHandler方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//.....</span></div><div class="line"><span class="comment">//AbstractHandlerMapping</span></div><div class="line"><span class="comment">//.....</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Object handler = getHandlerInternal(request);<span class="comment">//调用下面的方法</span></div><div class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</div><div class="line">            handler = getDefaultHandler();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Bean name or resolved handler?</span></div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</div><div class="line">            String handlerName = (String) handler;</div><div class="line">            handler = getApplicationContext().getBean(handlerName);</div><div class="line">        &#125;<span class="comment">//返回该请求对应的HandlerExecutionChain（包括处理器方法和拦截器）</span></div><div class="line">        <span class="keyword">return</span> getHandlerExecutionChain(handler, request);</div><div class="line">    &#125;</div><div class="line"><span class="comment">//.....</span></div><div class="line"><span class="comment">//AbstractHandlerMethodMapping(RequestMappingHandlerMapping 的祖先类)</span></div><div class="line"><span class="comment">//返回值是HandlerMethod</span></div><div class="line"><span class="comment">//.....</span></div><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</div><div class="line">        <span class="comment">///查找请求路径对应的HandlerMethod实例</span></div><div class="line">        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</div><div class="line">        <span class="comment">//确保HandlerMethod中的handler是处理器实例而不是处理器名字</span></div><div class="line">        <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span>) ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></mvc:annotation-driven></p>
<p>以上两个方法都是RequestMappingHandlerMapping的祖先类，逻辑很简单，先获取当前请求的路径，然后查找该路径对应的HandlerMethod实例。@RequestMapping (1)<br>这篇博客最后讲到了，RequestMappingHandlerMapping中的两个映射表实例，urlMap和handlerMethods，第一个是路径与RequestMappingInfo的映射，第二个是RequestMappingInfo和HandlerMethod的映射，lookupHandlerMethod方法负责检索这两个变量了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span></span>&#123;</div><div class="line">        List&amp;lt;Match&amp;gt; matches = <span class="keyword">new</span> ArrayList&amp;lt;Match&amp;gt;();</div><div class="line">        <span class="comment">//查找urlMap，获取直接匹配的RequestMappingInfo列表。如</span></div><div class="line">        <span class="comment">//URL 是/work/produce/2， @RequestMapping（&amp;quot;/work/produce/2&amp;quot;)直接匹配</span></div><div class="line">        List&amp;lt;T&amp;gt; directPathMatches = <span class="keyword">this</span>.urlMap.get(lookupPath);</div><div class="line">        <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</div><div class="line">            addMatchingMappings(directPathMatches, matches, request);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (matches.isEmpty()) &#123;<span class="comment">//如果没有找到直接匹配项，遍历所有的注册的RequestMappingInfo来查找</span></div><div class="line">            <span class="comment">//遍历所有可能的RequestMappingInfo，找到完全匹配的RequestMappingInfo实例，并生成Match对象</span></div><div class="line">            <span class="comment">//添加到Match列表中，Match是RequestMappingInfo和HandlerMethod的临时映射表。</span></div><div class="line">            <span class="comment">//举个例子：请求URL可能是GET:/work/produce/2,</span></div><div class="line">            <span class="comment">//而@RequestMapping(&amp;quot;/work/produce/&#123;no&#125;&amp;quot; &amp;quot;GET&amp;quot;)此时需要匹配是否是GET请求，以及模式是否匹配</span></div><div class="line">            addMatchingMappings(<span class="keyword">this</span>.handlerMethods.keySet(), matches, request);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!matches.isEmpty()) &#123;<span class="comment">//排序，找出最佳匹配</span></div><div class="line">            Comparator&amp;lt;Match&amp;gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</div><div class="line">            Collections.sort(matches, comparator);</div><div class="line">            Match bestMatch = matches.get(<span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (matches.size() &amp;gt; <span class="number">1</span>) &#123;<span class="comment">//如果可能的方法多余一个</span></div><div class="line">                Match secondBestMatch = matches.get(<span class="number">1</span>);<span class="comment">//并且两个方法的@RequestMapping内容相同</span></div><div class="line">                <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;<span class="comment">//抛出异常</span></div><div class="line">                    Method m1 = bestMatch.handlerMethod.getMethod();</div><div class="line">                    Method m2 = secondBestMatch.handlerMethod.getMethod();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                            &amp;quot;Ambiguous handler methods mapped <span class="keyword">for</span> HTTP path&amp;quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//这里是处理请求路径中的变量，如果/work/produce/&#123;no&#125;匹配的/work/produce/2中将no=2</span></div><div class="line">            <span class="comment">//添加到Request的属性表中，以便后面@PathVarible参数的处理</span></div><div class="line">            handleMatch(bestMatch.mapping, lookupPath, request);</div><div class="line">            <span class="keyword">return</span> bestMatch.handlerMethod;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> handleNoMatch(handlerMethods.keySet(), lookupPath, request);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   在进行URL匹配中，Spring会先查找是否存在直接匹配的RequestMappingInfo实例，即@RequestMapping中的value，method属性完全匹配请求的，如果没有找到通常是存在PathVariable的，如果/{no}和/222的情况等也是匹配的,  找到匹配项后，需要找出最优解，然后将路径中的变量存入Request的变量表中，我们分别详细的了解下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addMatchingMappings</span><span class="params">(Collection&amp;lt;T&amp;gt; mappings, List&amp;lt;Match&amp;gt; matches, </span></span></div><div class="line">                                                                HttpServletRequest request) &#123;</div><div class="line">        <span class="keyword">for</span> (T mapping : mappings) &#123;<span class="comment">//遍历所有的RequestMappingInfo列表</span></div><div class="line">            T match = getMatchingMapping(mapping, request);<span class="comment">//获取匹配的RequestMappingInfo实例</span></div><div class="line">            <span class="keyword">if</span> (match != <span class="keyword">null</span>) &#123;<span class="comment">//并生成匹配的RequestMappingInfo实例和对应HandlerMethod的Match实例</span></div><div class="line">                matches.add(<span class="keyword">new</span> Match(match, handlerMethods.get(mapping)));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   继续看getMatchingMapping的实现：</div><div class="line">```<span class="function">java</span></div><div class="line"><span class="keyword">public</span> RequestMappingInfo <span class="title">getMatchingCondition</span><span class="params">(HttpServletRequest request)</span> &#123;</div><div class="line">        <span class="comment">//查看RequestMappingInfo的所有属性是否匹配</span></div><div class="line">        RequestMethodsRequestCondition methods = methodsCondition.getMatchingCondition(request);</div><div class="line">        ParamsRequestCondition params = paramsCondition.getMatchingCondition(request);</div><div class="line">        HeadersRequestCondition headers = headersCondition.getMatchingCondition(request);</div><div class="line">        ConsumesRequestCondition consumes = consumesCondition.getMatchingCondition(request);</div><div class="line">        ProducesRequestCondition produces = producesCondition.getMatchingCondition(request);</div><div class="line">        <span class="keyword">if</span> (methods == <span class="keyword">null</span> || params == <span class="keyword">null</span> || headers == <span class="keyword">null</span> </div><div class="line">                                                    || consumes == <span class="keyword">null</span> || produces == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;<span class="comment">//我们重点看这个，路径是否匹配</span></div><div class="line">        PatternsRequestCondition patterns = patternsCondition.getMatchingCondition(request);</div><div class="line">        <span class="keyword">if</span> (patterns == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        RequestConditionHolder custom = customConditionHolder.getMatchingCondition(request);</div><div class="line">        <span class="keyword">if</span> (custom == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestMappingInfo(patterns, methods, params, headers, </div><div class="line">                                                        produces, custom.getCondition());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   我们知道RequestMappingInfo就是@RequestMapping注解的抽象，它包含@RequestMapping中的所有属性，因此在查找匹配项时，需要查看所有这些属性是否与请求匹配。我们这里只看路径模式是否匹配，都很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> PatternsRequestCondition <span class="title">getMatchingCondition</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.patterns.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;<span class="comment">//获取请求路径如/work/produce/2</span></div><div class="line">        String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);</div><div class="line">        List&amp;lt;String&amp;gt; matches = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;();</div><div class="line">        <span class="comment">//遍历@RequestMapping中的所有模式</span></div><div class="line">        <span class="keyword">for</span> (String pattern : patterns) &#123;</div><div class="line">            <span class="comment">//找出与请求路径匹配的模式，如/work/produce/&#123;no&#125;</span></div><div class="line">            String match = getMatchingPattern(pattern, lookupPath);</div><div class="line">            <span class="keyword">if</span> (match != <span class="keyword">null</span>) &#123;</div><div class="line">                matches.add(match);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="comment">//排序</span></div><div class="line">        Collections.sort(matches, <span class="keyword">this</span>.pathMatcher.getPatternComparator(lookupPath));</div><div class="line">        <span class="comment">//返回匹配的请求模式实例</span></div><div class="line">        <span class="keyword">return</span> matches.isEmpty() ? <span class="keyword">null</span> : </div><div class="line">            <span class="keyword">new</span> PatternsRequestCondition(matches, <span class="keyword">this</span>.urlPathHelper, <span class="keyword">this</span>.pathMatcher, </div><div class="line">                                       <span class="keyword">this</span>.useSuffixPatternMatch, <span class="keyword">this</span>.useTrailingSlashMatch);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getMatchingPattern</span><span class="params">(String pattern, String lookupPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pattern.equals(lookupPath)) &#123;</div><div class="line">            <span class="keyword">return</span> pattern;<span class="comment">//直接匹配</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.useSuffixPatternMatch) &#123;<span class="comment">//是否使用后缀模式，/abc/de匹配/abc</span></div><div class="line">            <span class="keyword">boolean</span> hasSuffix = pattern.indexOf(<span class="string">'.'</span>) != -<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (!hasSuffix &amp;amp;&amp;amp; <span class="keyword">this</span>.pathMatcher.match(pattern + &amp;quot;.*&amp;quot;, lookupPath)) &#123;</div><div class="line">                <span class="keyword">return</span> pattern + &amp;quot;.*&amp;quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="comment">//匹配/work/produce/&#123;no&#125; 和/work/produce/2</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pathMatcher.match(pattern, lookupPath)) &#123;</div><div class="line">            <span class="keyword">return</span> pattern;</div><div class="line">        &#125;<span class="comment">//是否使用结尾的斜线匹配</span></div><div class="line">        <span class="keyword">boolean</span> endsWithSlash = pattern.endsWith(&amp;quot;/&amp;quot;);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.useTrailingSlashMatch) &#123;</div><div class="line">            <span class="keyword">if</span> (!endsWithSlash &amp;amp;&amp;amp; <span class="keyword">this</span>.pathMatcher.match(pattern + &amp;quot;/&amp;quot;, lookupPath)) &#123;</div><div class="line">                <span class="keyword">return</span> pattern +&amp;quot;/&amp;quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   至于上面的pathMatcher.match方法这里就不分析了，可以自己看看，匹配算法还是比较复杂的，主要是尽可能的全面，除了进行匹配外，还会将路径中的变量保存起来以便@PathVariable参数使用。</p>
<pre><code>以上便是整个的匹配过程，好麻烦，或许你会说这会不会降低Spring的性能？实话说，在处理首次请求时，效率是很差，但是Spring使用了各种缓存策略，一旦程序进入正轨，效率就非常高了。
</code></pre><p>二、处理器方法的调用</p>
<pre><code>现在我们已经查找到了对应请求的处理器方法，下面我们就看Spring是如何在运行时动态地调用处理器方法的，并传递正确的参数。在doDispatch方法中，我们看到，确定了处理器（方法）后，Spring接着获取了该处理器方法的适配器（HandlerAdapter概念讲解中说到过，用来调用处理器方法的）
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        <span class="comment">//这个handlerAdapters跟handlerMappings一样，启用&amp;lt;mvc:annoation-driven/&amp;gt;后默认注册</span></div><div class="line">        <span class="comment">//RequestMappingHandlerAdapter（since3.1）</span></div><div class="line">        <span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</div><div class="line">            <span class="keyword">if</span> (ha.supports(handler)) &#123;</div><div class="line">                <span class="keyword">return</span> ha;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(&amp;quot;No adapter <span class="keyword">for</span> handler [&amp;quot; + handler +</div><div class="line">                &amp;quot;]: Does your handler implement a supported <span class="class"><span class="keyword">interface</span> <span class="title">like</span> <span class="title">Controller</span>?&amp;<span class="title">quot</span></span>;);</div><div class="line">    &#125;</div><div class="line"><span class="comment">//是否支持当前处理器，其实就是看看处理器是不是HandlerMethod实例</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> HandlerMethod &amp;amp;&amp;amp; supportsInternal((HandlerMethod) handler);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>   获取了HandlerAdapter后，Spring就会调用handlerAdapter实例的handle方法，并返回ModelAndView实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line">            HttpServletResponse response, HandlerMethod handlerMethod) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">//如果HandlerMethod所属的处理器被@SessionAttribute注解标记了</span></div><div class="line">        <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</div><div class="line">         <span class="comment">//设置响应头信息，防止缓存以便Session属性的管理</span></div><div class="line">         checkAndPrepare(request, response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//设置响应头，缓存默认时间</span></div><div class="line">            checkAndPrepare(request, response, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//要求在Session级别上进行同步，即同一个客户端的多个请求需要阻塞调用该处理器方法</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</div><div class="line">            HttpSession session = request.getSession(<span class="keyword">false</span>);</div><div class="line">            <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</div><div class="line">                Object mutex = WebUtils.getSessionMutex(session);</div><div class="line">                <span class="keyword">synchronized</span> (mutex) &#123;<span class="comment">//调用</span></div><div class="line">                    <span class="keyword">return</span> invokeHandleMethod(request, response, handlerMethod);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="comment">//调用</span></div><div class="line">        <span class="keyword">return</span> invokeHandleMethod(request, response, handlerMethod);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   我们接着看invokeHandlerMethod方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">invokeHandleMethod</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line">            HttpServletResponse response, HandlerMethod handlerMethod) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">//包装请求和响应对象</span></div><div class="line">        ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</div><div class="line">        <span class="comment">//获取与HandlerMethod对应的DataBinderFactory。</span></div><div class="line">        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</div><div class="line">        <span class="comment">//获取处理器方法所属处理器中被@ModelAttribute标记，但是没有被@RequestMapping标记的方法</span></div><div class="line">        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</div><div class="line">        <span class="comment">//创建请求映射方法，并将HandlerAdapter中的参数解析器列表和返回值处理器列表传递给它。</span></div><div class="line">        ServletInvocableHandlerMethod requestMappingMethod = </div><div class="line">                                      createRequestMappingMethod(handlerMethod, binderFactory);</div><div class="line">        <span class="comment">//创建ModelAndViewContainer</span></div><div class="line">        ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</div><div class="line">        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</div><div class="line">        modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</div><div class="line">        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</div><div class="line">        <span class="comment">//获取并设置当前请求的异步调用链实例</span></div><div class="line">        AsyncExecutionChain chain = AsyncExecutionChain.getForCurrentRequest(request);</div><div class="line">        chain.addDelegatingCallable(getAsyncCallable(mavContainer, modelFactory, webRequest));</div><div class="line">        chain.setAsyncWebRequest(createAsyncWebRequest(request, response));</div><div class="line">        chain.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</div><div class="line">        <span class="comment">//调用该处理器方法。</span></div><div class="line">        requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (chain.isAsyncStarted()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取并返回ModelAndView</span></div><div class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   关于异步调用链那块我们暂不关心，。从上面代码可以看到，在调用方法前，分别检查了处理器中存在的@InitBinder注解的方法和@ModelAttribute注解的方法，InitBinder方法用于类型转化，如将String转化为Date类型等，可以通过@InitBinder方法实现，感兴趣可以自己看看，不在详细分析。至于@ModelAttribute注解的方法，其返回值会被放入Model对象中供视图使用。下面我们看invokeAndHandle方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest,</span></span></div><div class="line">            ModelAndViewContainer mavContainer, Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">//....省略异步调用方法，暂不考虑</span></div><div class="line">        Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</div><div class="line">        <span class="comment">//....省略几行代码，暂不考虑</span></div><div class="line">        <span class="keyword">try</span> &#123;<span class="comment">//处理返回结果</span></div><div class="line">            <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, </div><div class="line">                                    getReturnValueType(returnValue), mavContainer, webRequest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   接着我们看下invokeForRequest方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request,</span></span></div><div class="line">                                         ModelAndViewContainer mavContainer,</div><div class="line">                                         Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">//获取方法参数值。</span></div><div class="line">        Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</div><div class="line">        <span class="comment">//传递参数值，调用，返回返回值</span></div><div class="line">        Object returnValue = invoke(args);</div><div class="line">        <span class="keyword">return</span> returnValue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   啊哈上面的代码貌似很简单，实则不是，重点就在getMethodArgumentValues方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Object[] getMethodArgumentValues(</div><div class="line">            NativeWebRequest request, ModelAndViewContainer mavContainer,</div><div class="line">            Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">//获取处理器方法的MethodParameter数组，就是方法的“参数定义”列表。</span></div><div class="line">        MethodParameter[] parameters = getMethodParameters();</div><div class="line">        Object[] args = <span class="keyword">new</span> Object[parameters.length];</div><div class="line">        <span class="comment">//遍历所有方法参数</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; parameters.length; i++) &#123;</div><div class="line">            MethodParameter parameter = parameters[i];</div><div class="line">            parameter.initParameterNameDiscovery(parameterNameDiscoverer);</div><div class="line">            <span class="comment">//确定泛型参数的类型</span></div><div class="line">            GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());</div><div class="line">            <span class="comment">//根据提供的参数值，解析当前参数的值</span></div><div class="line">            args[i] = resolveProvidedArgument(parameter, providedArgs);</div><div class="line">            <span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//根据内置的参数解析器，来解析当前的参数值</span></div><div class="line">            <span class="keyword">if</span> (argumentResolvers.supportsParameter(parameter)) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    args[i] = argumentResolvers.resolveArgument(parameter, mavContainer,</div><div class="line">                                                                 request, dataBinderFactory);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果参数值依旧为空，抛出异常。</span></div><div class="line">            <span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</div><div class="line">         String msg = getArgumentResolutionErrorMessage(&amp;quot;No suitable resolver <span class="keyword">for</span> argument&amp;quot;, i);</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> args;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   该方法是HandlerMethod中的方法，因此可以调用getMethodParameters()方法获取参数列表，然后遍历这些参数，分别用参数解析器来解析当前参数值，其中，argumentResolvers是HandlerMethodArgumentResolverComposite，它包含了所有的参数解析器的列表，以及参数类型和解析器的映射表，我们不妨看看到底什么怎么回事：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//是的，这个方法是HandlerAdapter中的方法，上一篇文章我们介绍了这是InitializingBean接口中的方法，</span></div><div class="line"><span class="comment">//会被自动调用</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//调用下面的方法，获取所有某人参数解析器。</span></div><div class="line">            List&amp;lt;HandlerMethodArgumentResolver&amp;gt; resolvers = getDefaultArgumentResolvers();</div><div class="line">            <span class="comment">//这个是HandlerAdapterComposite实例。</span></div><div class="line">            <span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite()</div><div class="line">                                                            .addResolvers(resolvers);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</div><div class="line">            List&amp;lt;HandlerMethodArgumentResolver&amp;gt; resolvers = </div><div class="line">                                                    getDefaultInitBinderArgumentResolvers();</div><div class="line">            <span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite()</div><div class="line">                                                                    .addResolvers(resolvers);</div><div class="line">        &#125;<span class="comment">//注册默认返回值处理器</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">            List&amp;lt;HandlerMethodReturnValueHandler&amp;gt; handlers = getDefaultReturnValueHandlers();</div><div class="line">            <span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite()</div><div class="line">                                                                    .addHandlers(handlers);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return the list of argument resolvers to use including built-in resolvers</div><div class="line">     * and custom resolvers provided via &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125;.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> List&amp;lt;HandlerMethodArgumentResolver&amp;gt; getDefaultArgumentResolvers() &#123;</div><div class="line">        List&amp;lt;HandlerMethodArgumentResolver&amp;gt; resolvers </div><div class="line">                                            = <span class="keyword">new</span> ArrayList&amp;lt;HandlerMethodArgumentResolver&amp;gt;();</div><div class="line"></div><div class="line">        <span class="comment">// Annotation-based argument resolution</span></div><div class="line">        resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</div><div class="line">        resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</div><div class="line">        resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</div><div class="line">        resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</div><div class="line">        resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</div><div class="line">        resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters()));</div><div class="line">        resolvers.add(<span class="keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters()));</div><div class="line">        resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</div><div class="line">        resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</div><div class="line">        resolvers.add(<span class="keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</div><div class="line">        resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</div><div class="line"></div><div class="line">        <span class="comment">// Type-based argument resolution</span></div><div class="line">        resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</div><div class="line">        resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</div><div class="line">        resolvers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters()));</div><div class="line">        resolvers.add(<span class="keyword">new</span> RedirectAttributesMethodArgumentResolver());</div><div class="line">        resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</div><div class="line">        resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</div><div class="line">        resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</div><div class="line">        resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</div><div class="line">        resolvers.add(<span class="keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</div><div class="line"></div><div class="line">        <span class="comment">// Custom arguments</span></div><div class="line">        <span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</div><div class="line">            resolvers.addAll(getCustomArgumentResolvers());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Catch-all</span></div><div class="line">        resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</div><div class="line">        resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</div><div class="line"></div><div class="line">        <span class="keyword">return</span> resolvers;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   这下清晰了吧，RequestMappingHandlerAdapter实现了InitializingBean接口，因此Spring启动是会调用它的afterPropertySet方法，进行上述参数解析器的注册。然后在处理器方法调用过程中会遍历这些解析器找到支持当前参数的解析器并解析参数。Perfect。我们再回到之前的resolveArgument方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(</span></span></div><div class="line">            MethodParameter parameter, ModelAndViewContainer mavContainer,</div><div class="line">            NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">//调用下面的方法回去支持当前参数类型的解析器。</span></div><div class="line">        HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);</div><div class="line">        <span class="comment">//调用该解析器的解析方法进行解析。</span></div><div class="line">        <span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//前面说过了，HandlerAdapterComposite会维护一个MethodParameter到解析器的映射关系。没错吧</span></div><div class="line">    <span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</div><div class="line">        HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (HandlerMethodArgumentResolver methodArgumentResolver : argumentResolvers) &#123;</div><div class="line">                <span class="comment">//判断解析器是否支持当前参数类型</span></div><div class="line">                <span class="keyword">if</span> (methodArgumentResolver.supportsParameter(parameter)) &#123;</div><div class="line">                    result = methodArgumentResolver;</div><div class="line">                    <span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   再往下就到某个解析器怎样解析具体参数了，有大约一二十个解析器，我们不可能全部分析，这里我们只分析其中常见的一个：@PathVariable注解的解析器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</div><div class="line">        <span class="comment">//如果该参数没有被@PathVariable注解标记，则返回false，不支持</span></div><div class="line">        <span class="keyword">if</span> (!parameter.hasParameterAnnotation(PathVariable.class)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果该参数是Map类型的。则判断@PathVariable是否设置了value属性</span></div><div class="line">        <span class="keyword">if</span> (Map.class.isAssignableFrom(parameter.getParameterType())) &#123;</div><div class="line">            String paramName = parameter.getParameterAnnotation(PathVariable.class).value();</div><div class="line">            <span class="keyword">return</span> StringUtils.hasText(paramName);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   从上面代码我们知道PathVariableMethodArgumentResolver支持被@PathVariable注解的参数。下面我们看它怎样解析参数值得：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">resolveArgument</span><span class="params">(</span></span></div><div class="line">            MethodParameter parameter, ModelAndViewContainer mavContainer,</div><div class="line">            NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">//获取参数类型</span></div><div class="line">        Class&amp;lt;?&amp;gt; paramType = parameter.getParameterType();</div><div class="line">        <span class="comment">//获取参数的名-值信息，如@PathVariable(&amp;quot;NO&amp;quot;) 则NO为名称，值为请求路径中对应</span></div><div class="line">        <span class="comment">//@RequestMapping(&amp;quot;/work/produce/NO&amp;quot;)中NO的值。</span></div><div class="line">        NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);</div><div class="line">        <span class="comment">//解析请求路径中对应名称的值。上例中NO对应的值。</span></div><div class="line">        Object arg = resolveName(namedValueInfo.name, parameter, webRequest);</div><div class="line">        <span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (namedValueInfo.defaultValue != <span class="keyword">null</span>) &#123;</div><div class="line">                arg = resolveDefaultValue(namedValueInfo.defaultValue);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (namedValueInfo.required) &#123;</div><div class="line">                handleMissingValue(namedValueInfo.name, parameter);</div><div class="line">            &#125;</div><div class="line">            arg = handleNullValue(namedValueInfo.name, arg, paramType);</div><div class="line">        &#125;<span class="comment">//DataBinder，后续讲解。</span></div><div class="line">        <span class="keyword">if</span> (binderFactory != <span class="keyword">null</span>) &#123;</div><div class="line">            WebDataBinder binder = binderFactory.createBinder(webRequest, <span class="keyword">null</span>, </div><div class="line">                                                                    namedValueInfo.name);</div><div class="line">            arg = binder.convertIfNecessary(arg, paramType, parameter);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将上面解析到的名称和值放到Request的属性表中。</span></div><div class="line">        handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</div><div class="line">        <span class="keyword">return</span> arg;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>   上面代码首先获取参数的@PathVariable的value属性值，如果value是空，则将参数的名称作为NameValueInfo的name值，然后用这个name值匹配请求路径中的变量值，作为NameValueInfo的value值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveName</span><span class="params">(String name, MethodParameter parameter, NativeWebRequest request)</span></span>&#123;</div><div class="line">        Map&amp;lt;String, String&amp;gt; uriTemplateVars =<span class="comment">//从请求的属性表中获取值</span></div><div class="line">            (Map&amp;lt;String, String&amp;gt;) request.getAttribute(</div><div class="line">             HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);</div><div class="line">        <span class="keyword">return</span> (uriTemplateVars != <span class="keyword">null</span>) ? uriTemplateVars.get(name) : <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>   上面再lookupHandlerMethod方法中，调用了handleMatch方法，我们说了它会将解析到的路径变量放到request的变量表中，这不，这里就用到了，这样我们就获取到了@PathVariable对应参数的值了。到此为止，@PathVariable参数的解析就算完成了，其他类型的参数解析思路一样不同的就是resolveArgument方法中的逻辑了，大家可以自行了解。</p>
<pre><code>注：这里Spring用到了多种设计模式，包括组合模式，策略模式，适配器模式等。其实这些实现都是3.1v的，之前的版本，参数解析这块相当乱，几乎完全在一个方法内实现的，拓展性，维护性相当差，3.1后我们可以很轻松的实现自己的参数解析器等，真的很棒。
</code></pre><p>三、返回值的处理</p>
<pre><code>上一节我们分析了参数的解析，及方法的调用，下面我们再来看返回值的处理，回到HandlerMethod的invokeAndHandle方法来，该方法的最后调用了returnValueHandlers.handleReturenValue方法，其中returnValueHandlers是HandlerMethodReturnValueHandlerComposite实例，就像HandlermethodArgumentResolverComposite一样，它包含了所有HandlerMethodReturnValueHandler的列表，并在Spring启动时完成注册。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(</span></span></div><div class="line">            Object returnValue, MethodParameter returnType,</div><div class="line">            ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">        HandlerMethodReturnValueHandler handler = getReturnValueHandler(returnType);</div><div class="line">        handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title">getReturnValueHandler</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (HandlerMethodReturnValueHandler returnValueHandler : returnValueHandlers) &#123;</div><div class="line">            <span class="keyword">if</span> (returnValueHandler.supportsReturnType(returnType)) &#123;</div><div class="line">                <span class="keyword">return</span> returnValueHandler;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//这个是处理String类型的返回值，即将返回值解析为视图名</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(</span></span></div><div class="line">            Object returnValue, MethodParameter returnType,</div><div class="line">            ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> String) &#123;</div><div class="line">            String viewName = (String) returnValue;</div><div class="line">            <span class="comment">//将返回值存储为视图名</span></div><div class="line">            mavContainer.setViewName(viewName);</div><div class="line">            <span class="keyword">if</span> (isRedirectViewName(viewName)) &#123;</div><div class="line">                mavContainer.setRedirectModelScenario(<span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(&amp;quot;Unexpected <span class="keyword">return</span> type: &amp;quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>   返回值的处理思路与参数的处理几乎一样了，根据不同的返回值类型，查找匹配的处理器，然后进行处理(主要就是设置Model和View了，如上面的代码将返回值解析为视图名)，这里就不多说了。返回值处理完了，剩下的就是将返回值响应给客户端了，再往下就是视图的解析了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、从头开始&lt;/p&gt;
&lt;p&gt;   SpringMvc会通过DispatcherServlet来处理所有的请求，展开这个方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        HttpServletRequest processedRequest = request;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        HandlerExecutionChain mappedHandler = null;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        AsyncExecutionChain asyncChain = AsyncExecutionChain.getForCurrentRequest(request);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        try &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            ModelAndView mv = null;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            Exception dispatchException = null;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            try &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                processedRequest = checkMultipart(request);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                // 确定当前请求的处理器（HandlerExecutionChain 包含Handler和Interceptor列表）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                mappedHandler = getHandler(processedRequest, false);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                if (mappedHandler == null || mappedHandler.getHandler() == null) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    noHandlerFound(processedRequest, response);//404异常&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    return;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                // 确定当前请求的处理器适配器&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                //......省略诸多代码......&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                // 调用处理处理器方法，返回ModelAndView对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;//处理返回结果&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  下面展开getHandler是怎么做的：
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 之 @RequestMapping（1）</title>
    <link href="http://yoursite.com/2015/06/02/Spring%20MVC%20%E4%B9%8B%20RequestMapping%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2015/06/02/Spring MVC 之 RequestMapping（1）/</id>
    <published>2015-06-02T05:04:16.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、从@AutoWaired开始</p>
<pre><code>在@AutoWaired中有下面的一段代码，其中populateBean负责属性的加载。而initializeBean完成属性属性加载后的自定义操作。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object exposedObject = bean;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            populateBean(beanName, mbd, instanceWrapper);</div><div class="line">            <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</div><div class="line">                exposedObject = initializeBean(beanName, exposedObject, mbd);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>来看一下initializeBean的实现。<a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</div><div class="line">		AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&amp;lt;Object&amp;gt;() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                <span class="comment">//这里检测当前Bean是否实现一些列Aware接口，并调用相关方法。</span></div><div class="line">				invokeAwareMethods(beanName, bean);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;, getAccessControlContext());</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		invokeAwareMethods(beanName, bean);</div><div class="line">	&#125;</div><div class="line">		Object wrappedBean = bean;</div><div class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</div><div class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//调用初始化方法的方法</span></div><div class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</div><div class="line">				(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</div><div class="line">				beanName, &amp;quot;Invocation of init method failed&amp;quot;, ex);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</div><div class="line">		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> wrappedBean;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着看下invokeInitMethods方法的实现。在<mvc:annotation-driven>的解析中，我们了解到Spring会默认为我们注册RequestMappingHandlerMapping等Bean定义。而RequestMappingHandlerMapping 实现了InitializingBean接口，因此，在初始化并装配该Bean实例时，执行到上述代码是，便会执行他的afterPropertySet方法。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)</div><div class="line">		throws Throwable &#123;</div><div class="line">        //判断是否是InitializingBean的实例</div><div class="line">	boolean isInitializingBean = (bean instanceof InitializingBean);</div><div class="line">	if (isInitializingBean &amp;amp;&amp;amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&amp;quot;afterPropertiesSet&amp;quot;))) &#123;</div><div class="line">		if (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(&amp;quot;Invoking afterPropertiesSet() on bean with name '&amp;quot; + beanName + &amp;quot;'&amp;quot;);</div><div class="line">		&#125;</div><div class="line">		if (System.getSecurityManager() != null) &#123;</div><div class="line">			try &#123;</div><div class="line">				AccessController.doPrivileged(new PrivilegedExceptionAction&amp;lt;Object&amp;gt;() &#123;</div><div class="line">					@Override</div><div class="line">					public Object run() throws Exception &#123;</div><div class="line">						((InitializingBean) bean).afterPropertiesSet();</div><div class="line">						return null;</div><div class="line">					&#125;</div><div class="line">				&#125;, getAccessControlContext());</div><div class="line">			&#125;</div><div class="line">			catch (PrivilegedActionException pae) &#123;</div><div class="line">				throw pae.getException();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			((InitializingBean) bean).afterPropertiesSet();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if (mbd != null) &#123;</div><div class="line">		String initMethodName = mbd.getInitMethodName();</div><div class="line">		if (initMethodName != null &amp;amp;&amp;amp; !(isInitializingBean &amp;amp;&amp;amp; &amp;quot;afterPropertiesSet&amp;quot;.equals(initMethodName)) &amp;amp;&amp;amp;</div><div class="line">				!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</div><div class="line">			invokeCustomInitMethod(beanName, bean, mbd);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></mvc:annotation-driven></p>
<p>接着看一下RequestMappingHandlerMapping的afterPropertySet方法。会进入AbstractHandlerMethodMapping中的initHandlerMethods方法，如下。该方法扫描ApplicationContext中的beans，检测并注册处理器方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">		logger.debug(&amp;quot;Looking <span class="keyword">for</span> request mappings in application context: &amp;quot; + getApplicationContext());</div><div class="line">	&#125;</div><div class="line">        <span class="comment">//扫描所有注册的Bean</span></div><div class="line">	String[] beanNames = (<span class="keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</div><div class="line">			BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :</div><div class="line">			getApplicationContext().getBeanNamesForType(Object.class));</div><div class="line">        <span class="comment">//遍历这些Bean，依次判断是否是处理器，并检测其HandlerMethod</span></div><div class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</div><div class="line">		<span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX) &amp;amp;&amp;amp;</div><div class="line">				isHandler(getApplicationContext().getType(beanName)))&#123;</div><div class="line">			detectHandlerMethods(beanName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	handlerMethodsInitialized(getHandlerMethods());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二、detectHandlerMethods</p>
<p>展开上一节中的detectHandlerMethods。一共分为以下步骤。<br>1）遍历Handler中的所有方法，找出其中被@RequestMapping注解标记的方法。<br>2）然后遍历这些方法，生成RequestMappingInfo实例。<br>3）将RequestMappingInfo实例以及处理器方法注册到缓存中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(<span class="keyword">final</span> Object handler)</span> </span>&#123;</div><div class="line">	Class&amp;lt;?&amp;gt; handlerType =</div><div class="line">			(handler <span class="keyword">instanceof</span> String ? getApplicationContext().getType((String) handler) : handler.getClass());</div><div class="line"></div><div class="line">	<span class="comment">// Avoid repeated calls to getMappingForMethod which would rebuild RequestMappingInfo instances</span></div><div class="line">	<span class="keyword">final</span> Map&amp;lt;Method, T&amp;gt; mappings = <span class="keyword">new</span> IdentityHashMap&amp;lt;Method, T&amp;gt;();</div><div class="line">	<span class="keyword">final</span> Class&amp;lt;?&amp;gt; userType = ClassUtils.getUserClass(handlerType);</div><div class="line"></div><div class="line">	Set&amp;lt;Method&amp;gt; methods = HandlerMethodSelector.selectMethods(userType, <span class="keyword">new</span> MethodFilter() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">                        <span class="comment">//根据方法上的@RequestMapping来创建RequestMappingInfo实例。</span></div><div class="line">			T mapping = getMappingForMethod(method, userType);</div><div class="line">			<span class="keyword">if</span> (mapping != <span class="keyword">null</span>) &#123;</div><div class="line">				mappings.put(method, mapping);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">        <span class="comment">//注册请求映射</span></div><div class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">		registerHandlerMethod(handler, method, mappings.get(method));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>展开getMappingForMethod。这一步根据注解生成RequestMappingInfo。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> RequestMappingInfo <span class="title">getMappingForMethod</span><span class="params">(Method method, Class&amp;lt;?&amp;gt; handlerType)</span> </span>&#123;</div><div class="line">	RequestMappingInfo info = <span class="keyword">null</span>;</div><div class="line">	RequestMapping methodAnnotation = AnnotationUtils.findAnnotation(method, RequestMapping.class);</div><div class="line">	<span class="keyword">if</span> (methodAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">		RequestCondition&amp;lt;?&amp;gt; methodCondition = getCustomMethodCondition(method);</div><div class="line">		info = createRequestMappingInfo(methodAnnotation, methodCondition);</div><div class="line">		RequestMapping typeAnnotation = AnnotationUtils.findAnnotation(handlerType, RequestMapping.class);</div><div class="line">		<span class="keyword">if</span> (typeAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">			RequestCondition&amp;lt;?&amp;gt; typeCondition = getCustomTypeCondition(handlerType);</div><div class="line">			info = createRequestMappingInfo(typeAnnotation, typeCondition).combine(info);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> info;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>展开createRequestMappingInfo。<br>其中涉及到了几个类，我们大致了解下含义：<br>PatternRequestCondition 它其实就是URL模式的封装，它包含了一个URL模式的Set集合。其实就是@RequestMapping注解中的value值得封装;<br>RequestMethodRequestCondition 它是@RequestMapping 注解中method属性的封装;<br>ParamsRequestCondition 它是@RequestMapping注解中params属性的封装;<br>等等，依次类推。因此RequestMappingInfo其实就是对@RquestMapping 的封装。<br>生成了RequestMappingInfo 对每一个元素都进行combine操作，不再详细讲解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> RequestMappingInfo <span class="title">createRequestMappingInfo</span><span class="params">(RequestMapping annotation, RequestCondition&amp;lt;?&amp;gt; customCondition)</span> </span>&#123;</div><div class="line">	String[] patterns = resolveEmbeddedValuesInPatterns(annotation.value());</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> RequestMappingInfo(</div><div class="line">			annotation.name(),</div><div class="line">			<span class="keyword">new</span> PatternsRequestCondition(patterns, getUrlPathHelper(), getPathMatcher(),</div><div class="line">					<span class="keyword">this</span>.useSuffixPatternMatch, <span class="keyword">this</span>.useTrailingSlashMatch, <span class="keyword">this</span>.fileExtensions),</div><div class="line">			<span class="keyword">new</span> RequestMethodsRequestCondition(annotation.method()),</div><div class="line">			<span class="keyword">new</span> ParamsRequestCondition(annotation.params()),</div><div class="line">			<span class="keyword">new</span> HeadersRequestCondition(annotation.headers()),</div><div class="line">			<span class="keyword">new</span> ConsumesRequestCondition(annotation.consumes(), annotation.headers()),</div><div class="line">			<span class="keyword">new</span> ProducesRequestCondition(annotation.produces(), annotation.headers(), <span class="keyword">this</span>.contentNegotiationManager),</div><div class="line">			customCondition);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再回到本节第一个方法中的registerHandlerMethod方法。这个方法就是生成新的HandlerMethod实例，然后加入handlerMethods中，接着生成mapping中所有的url放入urlMap中。当请求到达时，去urlMap中需找匹配的url，以及获取对应mapping实例，然后去handlerMethods中获取匹配HandlerMethod实例。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">protected void registerHandlerMethod(Object handler, Method method, T mapping) &#123;</div><div class="line">        //根据新的处理器实例，方法实例，RequestMappingInfo来生成新的HandlerMethod实例</div><div class="line">        //从缓存中查看是否有存在的HandlerMethod实例，如果有并且不相等则抛出异常</div><div class="line">	HandlerMethod newHandlerMethod = createHandlerMethod(handler, method);</div><div class="line">	HandlerMethod oldHandlerMethod = this.handlerMethods.get(mapping);</div><div class="line">	if (oldHandlerMethod != null &amp;amp;&amp;amp; !oldHandlerMethod.equals(newHandlerMethod)) &#123;</div><div class="line">		throw new IllegalStateException(&amp;quot;Ambiguous mapping found. Cannot map '&amp;quot; + newHandlerMethod.getBean() +</div><div class="line">				&amp;quot;' bean method \n&amp;quot; + newHandlerMethod + &amp;quot;\nto &amp;quot; + mapping + &amp;quot;: There is already '&amp;quot; +</div><div class="line">				oldHandlerMethod.getBean() + &amp;quot;' bean method\n&amp;quot; + oldHandlerMethod + &amp;quot; mapped.&amp;quot;);</div><div class="line">	&#125;</div><div class="line">        //handlerMethods 是一个Map键是RequestMappingInfo对象，值是HandlerMethod实例</div><div class="line">        //因此一个HandlerMethod实例可能处理多个mapping，而一个mapping实例只能由一个method处理</div><div class="line">	this.handlerMethods.put(mapping, newHandlerMethod);</div><div class="line">	if (logger.isInfoEnabled()) &#123;</div><div class="line">		logger.info(&amp;quot;Mapped \&amp;quot;&amp;quot; + mapping + &amp;quot;\&amp;quot; onto &amp;quot; + newHandlerMethod);</div><div class="line">	&#125;</div><div class="line">        //这里获取mapping实例中的所有url。</div><div class="line">	Set&amp;lt;String&amp;gt; patterns = getMappingPathPatterns(mapping);</div><div class="line">        //urlMap也是Map，键是url 模式，值是RequestMappingInfo实例</div><div class="line">        //因此一个mapping实例可能对应多个pattern，但是一个pattern只能对应一个mapping实例</div><div class="line">	for (String pattern : patterns) &#123;</div><div class="line">		if (!getPathMatcher().isPattern(pattern)) &#123;</div><div class="line">			this.urlMap.add(pattern, mapping);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if (this.namingStrategy != null) &#123;</div><div class="line">		String name = this.namingStrategy.getName(newHandlerMethod, mapping);</div><div class="line">		updateNameMap(name, newHandlerMethod);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着会分析Spring怎样处理客户发来的请求。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、从@AutoWaired开始&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在@AutoWaired中有下面的一段代码，其中populateBean负责属性的加载。而initializeBean完成属性属性加载后的自定义操作。
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Object exposedObject = bean;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            populateBean(beanName, mbd, instanceWrapper);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (exposedObject != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                exposedObject = initializeBean(beanName, exposedObject, mbd);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;来看一下initializeBean的实现。
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 之 &amp;lt;context:annotation-driven/&gt;</title>
    <link href="http://yoursite.com/2015/05/28/Spring%20MVC%20%E4%B9%8B%20contextannotation-driven/"/>
    <id>http://yoursite.com/2015/05/28/Spring MVC 之 contextannotation-driven/</id>
    <published>2015-05-28T05:03:12.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、解析类</p>
<p>通常如果我们希望通过注解的方式来进行Spring MVC开发，我们都会在<em>*</em>-servlet.xml中加入<mvc:annotation-driven>标签来告诉Spring我们的目的。找到对应的实现类是org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser。<br>通过阅读类注释文档，我们发现这个类主要是用来向工厂中注册了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RequestMappingHandlerMapping </div><div class="line">BeanNameUrlHandlerMapping</div><div class="line">RequestMappingHandlerAdapter</div><div class="line">HttpRequestHandlerAdapter</div><div class="line">SimpleControllerHandlerAdapter</div><div class="line">ExceptionHandlerExceptionResolver </div><div class="line">ResponseStatusExceptionResolver </div><div class="line">DefaultHandlerExceptionResolver</div></pre></td></tr></table></figure></mvc:annotation-driven></p>
<p>前两个是HandlerMapping接口的实现类，用来处理请求映射的。其中第一个是处理@RequestMapping注解的。第二个会将controller类的名字映射为请求url。</p>
<p>中间三个是用来处理请求的。具体点说就是确定调用哪个controller的哪个方法来处理当前请求。第一个处理@Controller注解的处理器，支持自定义方法参数和返回值（很酷）。第二个是处理继承HttpRequestHandler的处理器。第三个处理继承自Controller接口的处理器。</p>
<p>后面三个是用来处理异常的解析器。<a id="more"></a></p>
<p>二、实现流程</p>
<p>首先进入的是xml解析方法。由于annotation-driven不是默认的命名空间，会进入else，使用delegate解析元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Parse the elements at the root level in the document:</div><div class="line"> * &amp;quot;import&amp;quot;, &amp;quot;alias&amp;quot;, &amp;quot;bean&amp;quot;.</div><div class="line"> * <span class="doctag">@param</span> root the DOM root element of the document</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</div><div class="line">		NodeList nl = root.getChildNodes();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; nl.getLength(); i++) &#123;</div><div class="line">			Node node = nl.item(i);</div><div class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</div><div class="line">				Element ele = (Element) node;</div><div class="line">				<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</div><div class="line">					parseDefaultElement(ele, delegate);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					delegate.parseCustomElement(ele);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		delegate.parseCustomElement(root);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后会进入下面的方法。这里的Handler获取的是MvcNamespaceHandler。接着可以看到MvcNamespaceHandler中注册的annotation-driven的Parse是AnnotationDrivenBeanDefinitionParser。最后是Parse方法，该方法比较繁琐但是很好理解，注册了上面说的那几个类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>&#123;</div><div class="line">	String namespaceUri = getNamespaceURI(ele);</div><div class="line">	NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</div><div class="line">	<span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</div><div class="line">		error(&amp;quot;Unable to locate Spring NamespaceHandler <span class="keyword">for</span> XML schema namespace [&amp;quot; + namespaceUri + &amp;quot;]&amp;quot;, ele);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">	registerBeanDefinitionParser(&amp;quot;annotation-driven&amp;quot;, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;<span class="keyword">default</span>-servlet-handler&amp;quot;, <span class="keyword">new</span> DefaultServletHandlerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;interceptors&amp;quot;, <span class="keyword">new</span> InterceptorsBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;resources&amp;quot;, <span class="keyword">new</span> ResourcesBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;view-controller&amp;quot;, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;redirect-view-controller&amp;quot;, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;status-controller&amp;quot;, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;view-resolvers&amp;quot;, <span class="keyword">new</span> ViewResolversBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;tiles-configurer&amp;quot;, <span class="keyword">new</span> TilesConfigurerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;freemarker-configurer&amp;quot;, <span class="keyword">new</span> FreeMarkerConfigurerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;velocity-configurer&amp;quot;, <span class="keyword">new</span> VelocityConfigurerBeanDefinitionParser());</div><div class="line">	registerBeanDefinitionParser(&amp;quot;groovy-configurer&amp;quot;, <span class="keyword">new</span> GroovyMarkupConfigurerBeanDefinitionParser());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</div><div class="line">	Object source = parserContext.extractSource(element);</div><div class="line">	CompositeComponentDefinition compDefinition = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</div><div class="line">	parserContext.pushContainingComponent(compDefinition);</div><div class="line">	RuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, parserContext);</div><div class="line">        <span class="comment">//第一个在这 RequestMappingHandlerMapping</span></div><div class="line">	RootBeanDefinition handlerMappingDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerMapping.class);</div><div class="line">	handlerMappingDef.setSource(source);</div><div class="line">	handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div class="line">	handlerMappingDef.getPropertyValues().add(&amp;quot;order&amp;quot;, <span class="number">0</span>);</div><div class="line">	handlerMappingDef.getPropertyValues().add(&amp;quot;contentNegotiationManager&amp;quot;, contentNegotiationManager);</div><div class="line">	String methodMappingName = parserContext.getReaderContext().registerWithGeneratedName(handlerMappingDef);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (element.hasAttribute(&amp;quot;enable-matrix-variables&amp;quot;)) &#123;</div><div class="line">		Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute(&amp;quot;enable-matrix-variables&amp;quot;));</div><div class="line">		handlerMappingDef.getPropertyValues().add(&amp;quot;removeSemicolonContent&amp;quot;, !enableMatrixVariables);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (element.hasAttribute(&amp;quot;enableMatrixVariables&amp;quot;)) &#123;</div><div class="line">		Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute(&amp;quot;enableMatrixVariables&amp;quot;));</div><div class="line">		handlerMappingDef.getPropertyValues().add(&amp;quot;removeSemicolonContent&amp;quot;, !enableMatrixVariables);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	configurePathMatchingProperties(handlerMappingDef, element, parserContext);</div><div class="line"></div><div class="line">	RuntimeBeanReference conversionService = getConversionService(element, source, parserContext);</div><div class="line">	RuntimeBeanReference validator = getValidator(element, source, parserContext);</div><div class="line">	RuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element);</div><div class="line"></div><div class="line">	RootBeanDefinition bindingDef = <span class="keyword">new</span> RootBeanDefinition(ConfigurableWebBindingInitializer.class);</div><div class="line">	bindingDef.setSource(source);</div><div class="line">	bindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div class="line">	bindingDef.getPropertyValues().add(&amp;quot;conversionService&amp;quot;, conversionService);</div><div class="line">	bindingDef.getPropertyValues().add(&amp;quot;validator&amp;quot;, validator);</div><div class="line">	bindingDef.getPropertyValues().add(&amp;quot;messageCodesResolver&amp;quot;, messageCodesResolver);</div><div class="line"></div><div class="line">	ManagedList&amp;lt;?&amp;gt; messageConverters = getMessageConverters(element, source, parserContext);</div><div class="line">	ManagedList&amp;lt;?&amp;gt; argumentResolvers = getArgumentResolvers(element, parserContext);</div><div class="line">	ManagedList&amp;lt;?&amp;gt; returnValueHandlers = getReturnValueHandlers(element, parserContext);</div><div class="line">	String asyncTimeout = getAsyncTimeout(element);</div><div class="line">	RuntimeBeanReference asyncExecutor = getAsyncExecutor(element);</div><div class="line">	ManagedList&amp;lt;?&amp;gt; callableInterceptors = getCallableInterceptors(element, source, parserContext);</div><div class="line">	ManagedList&amp;lt;?&amp;gt; deferredResultInterceptors = getDeferredResultInterceptors(element, source, parserContext);</div><div class="line">        <span class="comment">//第二个在这 RequestMappingHandlerAdapter</span></div><div class="line">	RootBeanDefinition handlerAdapterDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerAdapter.class);</div><div class="line">	handlerAdapterDef.setSource(source);</div><div class="line">	handlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div class="line">	handlerAdapterDef.getPropertyValues().add(&amp;quot;contentNegotiationManager&amp;quot;, contentNegotiationManager);</div><div class="line">	handlerAdapterDef.getPropertyValues().add(&amp;quot;webBindingInitializer&amp;quot;, bindingDef);</div><div class="line">	handlerAdapterDef.getPropertyValues().add(&amp;quot;messageConverters&amp;quot;, messageConverters);</div><div class="line">	addResponseBodyAdvice(handlerAdapterDef);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (element.hasAttribute(&amp;quot;ignore-<span class="keyword">default</span>-model-on-redirect&amp;quot;)) &#123;</div><div class="line">		Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(&amp;quot;ignore-<span class="keyword">default</span>-model-on-redirect&amp;quot;));</div><div class="line">		handlerAdapterDef.getPropertyValues().add(&amp;quot;ignoreDefaultModelOnRedirect&amp;quot;, ignoreDefaultModel);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (element.hasAttribute(&amp;quot;ignoreDefaultModelOnRedirect&amp;quot;)) &#123;</div><div class="line">		<span class="comment">// &amp;quot;ignoreDefaultModelOnRedirect&amp;quot; spelling is deprecated</span></div><div class="line">		Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(&amp;quot;ignoreDefaultModelOnRedirect&amp;quot;));</div><div class="line">		handlerAdapterDef.getPropertyValues().add(&amp;quot;ignoreDefaultModelOnRedirect&amp;quot;, ignoreDefaultModel);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (argumentResolvers != <span class="keyword">null</span>) &#123;</div><div class="line">		handlerAdapterDef.getPropertyValues().add(&amp;quot;customArgumentResolvers&amp;quot;, argumentResolvers);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (returnValueHandlers != <span class="keyword">null</span>) &#123;</div><div class="line">		handlerAdapterDef.getPropertyValues().add(&amp;quot;customReturnValueHandlers&amp;quot;, returnValueHandlers);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (asyncTimeout != <span class="keyword">null</span>) &#123;</div><div class="line">		handlerAdapterDef.getPropertyValues().add(&amp;quot;asyncRequestTimeout&amp;quot;, asyncTimeout);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (asyncExecutor != <span class="keyword">null</span>) &#123;</div><div class="line">		handlerAdapterDef.getPropertyValues().add(&amp;quot;taskExecutor&amp;quot;, asyncExecutor);</div><div class="line">	&#125;</div><div class="line">	handlerAdapterDef.getPropertyValues().add(&amp;quot;callableInterceptors&amp;quot;, callableInterceptors);</div><div class="line">	handlerAdapterDef.getPropertyValues().add(&amp;quot;deferredResultInterceptors&amp;quot;, deferredResultInterceptors);</div><div class="line">	String handlerAdapterName = parserContext.getReaderContext().registerWithGeneratedName(handlerAdapterDef);</div><div class="line"></div><div class="line">	String uriCompContribName = MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;</div><div class="line">	RootBeanDefinition uriCompContribDef = <span class="keyword">new</span> RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);</div><div class="line">	uriCompContribDef.setSource(source);</div><div class="line">	uriCompContribDef.getPropertyValues().addPropertyValue(&amp;quot;handlerAdapter&amp;quot;, handlerAdapterDef);</div><div class="line">	uriCompContribDef.getPropertyValues().addPropertyValue(&amp;quot;conversionService&amp;quot;, conversionService);</div><div class="line">	parserContext.getReaderContext().getRegistry().registerBeanDefinition(uriCompContribName, uriCompContribDef);</div><div class="line"></div><div class="line">	RootBeanDefinition csInterceptorDef = <span class="keyword">new</span> RootBeanDefinition(ConversionServiceExposingInterceptor.class);</div><div class="line">	csInterceptorDef.setSource(source);</div><div class="line">	csInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, conversionService);</div><div class="line">	RootBeanDefinition mappedCsInterceptorDef = <span class="keyword">new</span> RootBeanDefinition(MappedInterceptor.class);</div><div class="line">	mappedCsInterceptorDef.setSource(source);</div><div class="line">	mappedCsInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div class="line">	mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, (Object) <span class="keyword">null</span>);</div><div class="line">	mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">1</span>, csInterceptorDef);</div><div class="line">	String mappedInterceptorName = parserContext.getReaderContext().registerWithGeneratedName(mappedCsInterceptorDef);</div><div class="line"></div><div class="line">	RootBeanDefinition exceptionHandlerExceptionResolver = <span class="keyword">new</span> RootBeanDefinition(ExceptionHandlerExceptionResolver.class);</div><div class="line">	exceptionHandlerExceptionResolver.setSource(source);</div><div class="line">	exceptionHandlerExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div class="line">	exceptionHandlerExceptionResolver.getPropertyValues().add(&amp;quot;contentNegotiationManager&amp;quot;, contentNegotiationManager);</div><div class="line">	exceptionHandlerExceptionResolver.getPropertyValues().add(&amp;quot;messageConverters&amp;quot;, messageConverters);</div><div class="line">	exceptionHandlerExceptionResolver.getPropertyValues().add(&amp;quot;order&amp;quot;, <span class="number">0</span>);</div><div class="line">	addResponseBodyAdvice(exceptionHandlerExceptionResolver);</div><div class="line"></div><div class="line">	String methodExceptionResolverName =</div><div class="line">			parserContext.getReaderContext().registerWithGeneratedName(exceptionHandlerExceptionResolver);</div><div class="line"></div><div class="line">	RootBeanDefinition responseStatusExceptionResolver = <span class="keyword">new</span> RootBeanDefinition(ResponseStatusExceptionResolver.class);</div><div class="line">	responseStatusExceptionResolver.setSource(source);</div><div class="line">	responseStatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div class="line">	responseStatusExceptionResolver.getPropertyValues().add(&amp;quot;order&amp;quot;, <span class="number">1</span>);</div><div class="line">	String responseStatusExceptionResolverName =</div><div class="line">			parserContext.getReaderContext().registerWithGeneratedName(responseStatusExceptionResolver);</div><div class="line"></div><div class="line">	RootBeanDefinition defaultExceptionResolver = <span class="keyword">new</span> RootBeanDefinition(DefaultHandlerExceptionResolver.class);</div><div class="line">	defaultExceptionResolver.setSource(source);</div><div class="line">	defaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</div><div class="line">	defaultExceptionResolver.getPropertyValues().add(&amp;quot;order&amp;quot;, <span class="number">2</span>);</div><div class="line">	String defaultExceptionResolverName =</div><div class="line">			parserContext.getReaderContext().registerWithGeneratedName(defaultExceptionResolver);</div><div class="line"></div><div class="line">	parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(handlerMappingDef, methodMappingName));</div><div class="line">	parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(handlerAdapterDef, handlerAdapterName));</div><div class="line">	parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(uriCompContribDef, uriCompContribName));</div><div class="line">	parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(exceptionHandlerExceptionResolver, methodExceptionResolverName));</div><div class="line">	parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(responseStatusExceptionResolver, responseStatusExceptionResolverName));</div><div class="line">	parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(defaultExceptionResolver, defaultExceptionResolverName));</div><div class="line">	parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(mappedCsInterceptorDef, mappedInterceptorName));</div><div class="line"></div><div class="line">	<span class="comment">// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not &amp;quot;turned off&amp;quot;</span></div><div class="line">	MvcNamespaceUtils.registerDefaultComponents(parserContext, source);</div><div class="line">	parserContext.popAndRegisterContainingComponent();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>三、总结<br>主要说明里面的两个，RequestMappingHandlerMapping和RequestMappingHandlerAdapter。</p>
<pre><code>第一个是HandlerMapping的实现类，它会处理@RequestMapping 注解，并将其注册到请求映射表中。（下片文章我们会详细介绍的）

第二个是HandlerAdapter的实现类，它是处理请求的适配器，说白了，就是确定调用哪个类的哪个方法，并且构造方法参数，返回值。（后面文章也会陆续详细介绍的）

那么它跟&lt;context:component-scan/&gt;的区别是，&lt;context:component-scan/&gt;标签是告诉Spring 来扫描指定包下的类，并注册被@Component，@Controller，@Service，@Repository等注解标记的组件。

而&lt;mvc:annotation-scan/&gt;是告知Spring，我们启用注解驱动。然后Spring会自动为我们注册上面说到的几个Bean到工厂中，来处理我们的请求。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、解析类&lt;/p&gt;
&lt;p&gt;通常如果我们希望通过注解的方式来进行Spring MVC开发，我们都会在&lt;em&gt;*&lt;/em&gt;-servlet.xml中加入&lt;mvc:annotation-driven/&gt;标签来告诉Spring我们的目的。找到对应的实现类是org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser。&lt;br&gt;通过阅读类注释文档，我们发现这个类主要是用来向工厂中注册了&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;RequestMappingHandlerMapping &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;BeanNameUrlHandlerMapping&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RequestMappingHandlerAdapter&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;HttpRequestHandlerAdapter&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;SimpleControllerHandlerAdapter&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ExceptionHandlerExceptionResolver &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ResponseStatusExceptionResolver &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;DefaultHandlerExceptionResolver&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;前两个是HandlerMapping接口的实现类，用来处理请求映射的。其中第一个是处理@RequestMapping注解的。第二个会将controller类的名字映射为请求url。&lt;/p&gt;
&lt;p&gt;中间三个是用来处理请求的。具体点说就是确定调用哪个controller的哪个方法来处理当前请求。第一个处理@Controller注解的处理器，支持自定义方法参数和返回值（很酷）。第二个是处理继承HttpRequestHandler的处理器。第三个处理继承自Controller接口的处理器。&lt;/p&gt;
&lt;p&gt;后面三个是用来处理异常的解析器。
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 之 @Autowired</title>
    <link href="http://yoursite.com/2015/05/21/Spring%20MVC%20%E4%B9%8B%20@Autowired/"/>
    <id>http://yoursite.com/2015/05/21/Spring MVC 之 @Autowired/</id>
    <published>2015-05-20T23:29:52.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、准备工作</p>
<p>POJO类Parent<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.mvc;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Controller类HomeController<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	Parent parent;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HomeController.class);</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Simply selects the home view to render by returning its name.</div><div class="line">	 */</div><div class="line">	<span class="meta">@RequestMapping</span>(value = &amp;quot;/&amp;quot;, method = RequestMethod.GET)</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(Locale locale, Model model)</span> </span>&#123;</div><div class="line">		logger.info(&amp;quot;Welcome home! The client locale is &#123;&#125;. &amp;quot;, locale);</div><div class="line">		logger.info(parent.toString());		</div><div class="line">		Date date = <span class="keyword">new</span> Date();</div><div class="line">		DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);		</div><div class="line">		String formattedDate = dateFormat.format(date);		</div><div class="line">		model.addAttribute(&amp;quot;serverTime&amp;quot;, formattedDate );</div><div class="line"></div><div class="line">		<span class="keyword">return</span> &amp;quot;home&amp;quot;; </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>root-context.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp;lt;bean id=&amp;quot;parent&amp;quot; class=&amp;quot;com.test.mvc.Parent&amp;quot; &amp;gt;&amp;lt;/bean&amp;gt;</div></pre></td></tr></table></figure></p>
<p>web.xml略。</p>
<p>二、回忆</p>
<p>在<a href="http://www.bugpointer.com/archives/521.html" target="_blank" rel="external">Spring 使用简单Demo进行源码调试（六）</a>这篇文章中介绍了bean参数的赋值，AutoWired也是在这个地方实现自动加载的。首先展开文章中的doCreateBean。这里省略了很多代码。首先看pplyMergedBeanDefinitionPostProcessors这个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">// Instantiate the bean.</span></div><div class="line">	BeanWrapper instanceWrapper = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</div><div class="line">		instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//.......</span></div><div class="line">        <span class="comment">//.......</span></div><div class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</div><div class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</div><div class="line">			applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</div><div class="line"> 			mbd.postProcessed = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//......</span></div><div class="line">        <span class="comment">//......</span></div><div class="line">	<span class="comment">// Initialize the bean instance.</span></div><div class="line">	Object exposedObject = bean;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		populateBean(beanName, mbd, instanceWrapper);</div><div class="line">		<span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</div><div class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</div><div class="line">			<span class="keyword">throw</span> (BeanCreationException) ex;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, &amp;quot;Initialization of bean failed&amp;quot;, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//......</span></div><div class="line">        <span class="comment">//......</span></div><div class="line">	<span class="comment">// Register bean as disposable.</span></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, &amp;quot;Invalid destruction signature&amp;quot;, ex);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> exposedObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>断点运行到后去homeController的，后处理为AutowiredAnnotationBeanPostProcessor，如下图。<br><img src="/images/断点在homeController-300x41.png" alt="断点在homeController"><br>展开AutowiredAnnotationBeanPostProcessor中的findAutowiringMetadata方法。这一步中的重点是在buildAutowiringMetadata，构建元数据。buildAutowiringMetadata首先去缓存里面找元数据，找不到就遍历bean的和父类的字段域和方法，如果别标记为@Autowired并且不是静态的就添加到InjectionMetadata中，并添加到缓存中。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private InjectionMetadata findAutowiringMetadata(String beanName, Class&amp;lt;?&amp;gt; clazz, PropertyValues pvs) &#123;</div><div class="line">	// 回到使用类名作为缓存键,保持自定义命令向后兼容性</div><div class="line">	String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</div><div class="line">	InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);</div><div class="line">	if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</div><div class="line">		synchronized (this.injectionMetadataCache) &#123;</div><div class="line">			metadata = this.injectionMetadataCache.get(cacheKey);</div><div class="line">			if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</div><div class="line">				if (metadata != null) &#123;</div><div class="line">					metadata.clear(pvs);</div><div class="line">				&#125;</div><div class="line">				try &#123;</div><div class="line">                                        //构建元数据</div><div class="line">					metadata = buildAutowiringMetadata(clazz);</div><div class="line">					this.injectionMetadataCache.put(cacheKey, metadata);</div><div class="line">				&#125;</div><div class="line">				catch (NoClassDefFoundError err) &#123;</div><div class="line">					throw new IllegalStateException(&amp;quot;Failed to introspect bean class [&amp;quot; + clazz.getName() +</div><div class="line">							&amp;quot;] for autowiring metadata: could not find class that it depends on&amp;quot;, err);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return metadata;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(Class&amp;lt;?&amp;gt; clazz)</span> </span>&#123;</div><div class="line">	LinkedList&amp;lt;InjectionMetadata.InjectedElement&amp;gt; elements = <span class="keyword">new</span> LinkedList&amp;lt;InjectionMetadata.InjectedElement&amp;gt;();</div><div class="line">	Class&amp;lt;?&amp;gt; targetClass = clazz;</div><div class="line">	do &#123;<span class="comment">//这里一个循环，因为要考虑父类的字段和方法</span></div><div class="line">		LinkedList&amp;lt;InjectionMetadata.InjectedElement&amp;gt; currElements = <span class="keyword">new</span> LinkedList&amp;lt;InjectionMetadata.InjectedElement&amp;gt;();</div><div class="line">                <span class="comment">//这里循环字段，找到被标记为@Autowired的字段</span></div><div class="line">		<span class="keyword">for</span> (Field field : targetClass.getDeclaredFields()) &#123;</div><div class="line">			AnnotationAttributes ann = findAutowiredAnnotation(field);</div><div class="line">			<span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</div><div class="line">					<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">						logger.warn(&amp;quot;Autowired annotation is not supported on <span class="keyword">static</span> fields: &amp;quot; + field);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">boolean</span> required = determineRequiredStatus(ann);</div><div class="line">                                <span class="comment">//创建AutowiredFieldElement。</span></div><div class="line">				currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">                 <span class="comment">//这里循环方法</span></div><div class="line">		<span class="keyword">for</span> (Method method : targetClass.getDeclaredMethods()) &#123;</div><div class="line">			Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</div><div class="line">			<span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</div><div class="line">			<span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;amp;&amp;amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</div><div class="line">				<span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</div><div class="line">					<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">						logger.warn(&amp;quot;Autowired annotation is not supported on <span class="keyword">static</span> methods: &amp;quot; + method);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">0</span>) &#123;</div><div class="line">					<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">						logger.warn(&amp;quot;Autowired annotation should be used on methods with actual parameters: &amp;quot; + method);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">boolean</span> required = determineRequiredStatus(ann);</div><div class="line">				PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</div><div class="line">                                <span class="comment">//创建AutowiredMethodElement。</span></div><div class="line">				currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		elements.addAll(<span class="number">0</span>, currElements);</div><div class="line">		targetClass = targetClass.getSuperclass();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;amp;&amp;amp; targetClass != Object.class);</div><div class="line"></div><div class="line">        <span class="comment">//将InjectionElement集合添加到新建的InjectionMetadata中。</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>三、自动装载</p>
<p>代码运行到populateBean方法。这个方法太长，这里就不贴出来了，直接走到postProcessPropertyValues方法,获得InjectionMetadata对象后便遍历其中的所有InjectionElement对象，调用其中的inject方法。接着对每一个injectedElement进行inject。最后的inject进行真正的属性赋值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></div><div class="line">		PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">	InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		metadata.inject(bean, beanName, pvs);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, &amp;quot;Injection of autowired dependencies failed&amp;quot;, ex);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> pvs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">	Collection&amp;lt;InjectedElement&amp;gt; elementsToIterate =</div><div class="line">			(<span class="keyword">this</span>.checkedElements != <span class="keyword">null</span> ? <span class="keyword">this</span>.checkedElements : <span class="keyword">this</span>.injectedElements);</div><div class="line">	<span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</div><div class="line">		<span class="keyword">boolean</span> debug = logger.isDebugEnabled();</div><div class="line">		<span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</div><div class="line">			<span class="keyword">if</span> (debug) &#123;</div><div class="line">				logger.debug(&amp;quot;Processing injected element of bean <span class="string">'&amp;quot; + beanName + &amp;quot;'</span>: &amp;quot; + element);</div><div class="line">			&#125;</div><div class="line">			element.inject(target, beanName, pvs);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		Field field = (Field) <span class="keyword">this</span>.member;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Object value;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.cached) &#123;</div><div class="line">				value = resolvedCachedArgument(beanName, <span class="keyword">this</span>.cachedFieldValue);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				DependencyDescriptor desc = <span class="keyword">new</span> DependencyDescriptor(field, <span class="keyword">this</span>.required);</div><div class="line">				desc.setContainingClass(bean.getClass());</div><div class="line">				Set&amp;lt;String&amp;gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&amp;lt;String&amp;gt;(<span class="number">1</span>);</div><div class="line">				TypeConverter typeConverter = beanFactory.getTypeConverter();</div><div class="line">                                <span class="comment">//获取真正的属性值。</span></div><div class="line">				value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</div><div class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">					<span class="keyword">if</span> (!<span class="keyword">this</span>.cached) &#123;</div><div class="line">						<span class="keyword">if</span> (value != <span class="keyword">null</span> || <span class="keyword">this</span>.required) &#123;</div><div class="line">							<span class="keyword">this</span>.cachedFieldValue = desc;</div><div class="line">							registerDependentBeans(beanName, autowiredBeanNames);</div><div class="line">							<span class="keyword">if</span> (autowiredBeanNames.size() == <span class="number">1</span>) &#123;</div><div class="line">								String autowiredBeanName = autowiredBeanNames.iterator().next();</div><div class="line">								<span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName)) &#123;</div><div class="line">									<span class="keyword">if</span> (beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;</div><div class="line">										<span class="keyword">this</span>.cachedFieldValue = <span class="keyword">new</span> RuntimeBeanReference(autowiredBeanName);</div><div class="line">									&#125;</div><div class="line">								&#125;</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">else</span> &#123;</div><div class="line">							<span class="keyword">this</span>.cachedFieldValue = <span class="keyword">null</span>;</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">this</span>.cached = <span class="keyword">true</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">				ReflectionUtils.makeAccessible(field);</div><div class="line">                                <span class="comment">//最终赋值</span></div><div class="line">				field.set(bean, value);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(&amp;quot;Could not autowire field: &amp;quot; + field, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下resolveDependency。 这个方法其实就是根据类型到bean工厂中查找类型匹配的bean实例，然后就看到了这几个条件分支语句，如果是数组，集合，映射表，自定义类型都执行了差不多的操作，findAutowireCandidate方法。这个方法会去工厂中执行类型匹配的查找，将匹配的结果集返回，不同的是，集合数组类型会通过TypeConverter进行结果的转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, String beanName,</span></span></div><div class="line">	Set&amp;lt;String&amp;gt; autowiredBeanNames, TypeConverter typeConverter) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">	Class&amp;lt;?&amp;gt; type = descriptor.getDependencyType();</div><div class="line">	Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</div><div class="line">	<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</div><div class="line">			String strVal = resolveEmbeddedValue((String) value);</div><div class="line">			BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;amp;&amp;amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</div><div class="line">			value = evaluateBeanDefinitionString(strVal, bd);</div><div class="line">		&#125;</div><div class="line">		TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</div><div class="line">		<span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</div><div class="line">				converter.convertIfNecessary(value, type, descriptor.getField()) :</div><div class="line">				converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (type.isArray()) &#123;</div><div class="line">                <span class="comment">//如果属性类型是数组</span></div><div class="line">		<span class="comment">//......</span></div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Collection.class.isAssignableFrom(type) &amp;amp;&amp;amp; type.isInterface()) &#123;</div><div class="line">                <span class="comment">//如果属性是集合，并且是接口</span></div><div class="line">		<span class="comment">//......</span></div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Map.class.isAssignableFrom(type) &amp;amp;&amp;amp; type.isInterface()) &#123;</div><div class="line">                <span class="comment">//如果属性是Map并且是接口</span></div><div class="line">		<span class="comment">//......</span></div><div class="line">		<span class="keyword">return</span> matchingBeans;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;<span class="comment">//自定义类型</span></div><div class="line">		Map&amp;lt;String, Object&amp;gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</div><div class="line">		<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</div><div class="line">			<span class="keyword">if</span> (descriptor.isRequired()) &#123;</div><div class="line">				raiseNoSuchBeanDefinitionException(type, &amp;quot;&amp;quot;, descriptor);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (matchingBeans.size() &amp;gt; <span class="number">1</span>) &#123;</div><div class="line">			String primaryBeanName = determineAutowireCandidate(matchingBeans, descriptor);</div><div class="line">			<span class="keyword">if</span> (primaryBeanName == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(type, matchingBeans.keySet());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</div><div class="line">				autowiredBeanNames.add(primaryBeanName);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> matchingBeans.get(primaryBeanName);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// We have exactly one match.</span></div><div class="line">		Map.Entry&amp;lt;String, Object&amp;gt; entry = matchingBeans.entrySet().iterator().next();</div><div class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</div><div class="line">			autowiredBeanNames.add(entry.getKey());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> entry.getValue();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此为止，找到了属性的匹配值，然后反射赋值就完成了整个的自动装配过程。可以看出，@Autowired是通过类型来进行自动装配的。</p>
<p>上面是属性的赋值过程也就是InjectionFieldElement的inject方法，InjectionMethodElement的inject方法大致相同只是对每一个方法参数执行一次resolveDependency方法来获取参数值，然后反射执行方法。</p>
<p>到此为止，整个实例化和装配过程也就讲完了，我们总结一下：</p>
<p>1）一切都是从bean工厂的getBean方法开始的，一旦该方法调用总会返回一个bean实例，无论当前是否存在，不存在就实例化一个并装配，否则直接返回。</p>
<p>2）实例化和装配过程中会多次递归调用getBean方法来解决类之间的依赖。</p>
<p>3）Spring几乎考虑了所有可能性，所以方法特别复杂但完整有条理。</p>
<p>4）@Autowired最终是根据类型来查找和装配元素的，但是我们设置了<beans default-autowire="byName">后会影响最终的类型匹配查找。因为在前面有根据BeanDefinition的autowire类型设置PropertyValue值得一步，其中会有新实例的创建和注册。就是那个autowireByName方法。</beans></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、准备工作&lt;/p&gt;
&lt;p&gt;POJO类Parent&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 之 &amp;lt;context:component-scan/&gt;</title>
    <link href="http://yoursite.com/2015/05/19/Spring%20MVC%20%E4%B9%8B%20contextcomponent-scan/"/>
    <id>http://yoursite.com/2015/05/19/Spring MVC 之 contextcomponent-scan/</id>
    <published>2015-05-19T02:04:40.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、ContextLoader<br>通过阅读SpringMVC的源码可知，SpringMVC的初始化在ContextLoaderListener类中的contextInitialized方法，跟一下代码发现实际上是在ContextLoader中的initWebApplicationContext方法中进行初始化。初始化的代码如下,首先会创建一个WebApplicationContext对象，然后加载父类，接着使用configureAndRefreshWebApplicationContext初始化这个WebApplicactionContext对象，是在configureAndRefreshWebApplicationContext方法中进行了配置文件的加载和组件的扫描。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</div><div class="line">	ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</div><div class="line">	<span class="keyword">if</span> (!cwac.isActive()) &#123;</div><div class="line">		<span class="comment">// The context has not yet been refreshed -&amp;gt; provide services such as</span></div><div class="line">		<span class="comment">// setting the parent context, setting the application context id, etc</span></div><div class="line">		<span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">// The context instance was injected without an explicit parent -&amp;gt;</span></div><div class="line">			<span class="comment">// determine parent for root web application context, if any.</span></div><div class="line">			ApplicationContext parent = loadParentContext(servletContext);</div><div class="line">			cwac.setParent(parent);</div><div class="line">		&#125;</div><div class="line">		configureAndRefreshWebApplicationContext(cwac, servletContext);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>展开createWebApplicationContext方法。该方法初始化根WebApplicationContext，这个WebApplicationContext可以使默认的context也尅进行定制。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">protected WebApplicationContext createWebApplicationContext(ServletContext sc) &#123;</div><div class="line">	Class&amp;lt;?&amp;gt; contextClass = determineContextClass(sc);</div><div class="line">	if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</div><div class="line">		throw new ApplicationContextException(&amp;quot;Custom context class [&amp;quot; + contextClass.getName() +</div><div class="line">				&amp;quot;] is not of type [&amp;quot; + ConfigurableWebApplicationContext.class.getName() + &amp;quot;]&amp;quot;);</div><div class="line">	&#125;</div><div class="line">	return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>展开determineContextClass方法。这个方法比较简单，首先查看有没有配置CONTEXT_CLASS_PARAM这个属性，有的话使用这个属性配置的类进行加载，否则使用默认的类。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">protected Class&amp;lt;?&amp;gt; determineContextClass(ServletContext servletContext) &#123;</div><div class="line">	String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</div><div class="line">	if (contextClassName != null) &#123;</div><div class="line">		try &#123;</div><div class="line">			return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</div><div class="line">		&#125;</div><div class="line">		catch (ClassNotFoundException ex) &#123;</div><div class="line">			throw new ApplicationContextException(</div><div class="line">					&amp;quot;Failed to load custom context class [&amp;quot; + contextClassName + &amp;quot;]&amp;quot;, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());</div><div class="line">		try &#123;</div><div class="line">			return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</div><div class="line">		&#125;</div><div class="line">		catch (ClassNotFoundException ex) &#123;</div><div class="line">			throw new ApplicationContextException(</div><div class="line">					&amp;quot;Failed to load default context class [&amp;quot; + contextClassName + &amp;quot;]&amp;quot;, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再看configureAndRefreshWebApplicationContext方法。configureAndRefreshWebApplicationContext最后的refresh方法已经在前面的<a href="http://www.bugpointer.com/archives/491.html" target="_blank" rel="external">Spring 使用简单Demo进行源码调试</a>系列文章里进行了简单的分析调试。</p>
<p>二、 &lt;context:component-scan/&gt;<br> 我们在SpringMVC开发项目中，有的用注解和XML配置Bean,这两种都各有自己的优势，数据源配置比较经常用XML配置，控制层依赖的service比较经常用注解等（在部署时比较不会改变的），我们经常比较常用的注解有@Component是通用标注，@Controller标注web控制器，@Service标注Servicec层的服务，@Respository标注DAO层的数据访问。SpringMVC启动时怎么被自动扫描然后解析并注册到Bean工厂中去（放到DefaultListableBeanFactory中的Map<string, beandefinition=""> beanDefinitionMap中 以BeanName为key）？我们今天带着这些问题来了解分析这实现的过程，我们在分析之前先了解一下这些注解。<br>   @Controller标注web控制器，@Service标注Service层的服务，@Respository标注DAO层的数据访问。@Component是通用标注，只是定义为一个类为Bean，SpringMVC会把所有添加@Component注解的类作为使用自动扫描注入配置路径下的备选对象。@Controller、@Service\@Respository只是更加的细化，都是被@Component标注，所以我们比较不推荐使用@Component。源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)  </div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  </div><div class="line"><span class="meta">@Documented</span>  </div><div class="line"><span class="meta">@Component</span>  </div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;  </div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &amp;quot</span>;&amp;quot;;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)  </div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  </div><div class="line"><span class="meta">@Documented</span>  </div><div class="line"><span class="meta">@Component</span>  </div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;  </div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &amp;quot</span>;&amp;quot;;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)  </div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  </div><div class="line"><span class="meta">@Documented</span>  </div><div class="line"><span class="meta">@Component</span>  </div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;  </div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &amp;quot</span>;&amp;quot;;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></string,></p>
<p>都是有标示@Component<br> 我们在配置文件中，标示配置需要扫描哪些包下，也可以配置对某个包下不扫描，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&amp;lt;context:component-scan base-<span class="keyword">package</span>=&amp;quot;cn.test&amp;quot;&amp;gt;  </div><div class="line">        &amp;lt;context:exclude-filter type=&amp;quot;regex&amp;quot; expression=&amp;quot;cn.test.*.*.controller&amp;quot;/&amp;gt;  </div><div class="line">        &amp;lt;context:exclude-filter type=&amp;quot;regex&amp;quot; expression=&amp;quot;cn.test.*.*.controller2&amp;quot;/&amp;gt;  </div><div class="line">&amp;lt;/context:component-scan&amp;gt;</div></pre></td></tr></table></figure></p>
<p>说明：<br>   <context:exclude-filter>指定的不扫描包，<context:exclude-filter>指定的扫描包<br>SpringMVC先读取配置文件，然后根据context:component-scan中属性base-package去扫描指定包下的class和jar文件，把标示@Controller标注web控制器，@Service标注Servicec层的服务，@Respository标注DAO层的数据访问等注解的都获取，并注册为Bean类放到Bean工厂。</context:exclude-filter></context:exclude-filter></p>
<p>三、ComponentScanBeanDefinitionParser<br>通过阅读源码，知道接口BeanDefinitionParser可以实现将自定义的标签转化为 BeanDefinition类。而<context:component-scan>则是由ComponentScanBeanDefinitionParser进行解析的。</context:component-scan></p>
<p>展开ComponentScanBeanDefinitionParser中的parse方法。可以看到主要完成以下工作。<br>    （1）获取context:component-scan 配置的属性base-package的值，然后放到数组。<br>    （2）创建扫描对应包下的class和jar文件的对象ClassPathBeanDefinitionScanner ，由这个类来实现扫描包下的class和jar文件并把注解的Bean包装成BeanDefinition。<br>    （3）BeanDefinition注册到Bean工厂。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</div><div class="line">	String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</div><div class="line">	basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</div><div class="line">	String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</div><div class="line">			ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</div><div class="line">	<span class="comment">// Actually scan for bean definitions and register them.</span></div><div class="line">	ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</div><div class="line">	Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = scanner.doScan(basePackages);</div><div class="line">	registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再展开configureScanner方法。首先通过findCandidateComponents获取候选bean definition。然后注册到registry中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Set&amp;lt;BeanDefinitionHolder&amp;gt; doScan(String... basePackages) &#123;</div><div class="line">	Assert.notEmpty(basePackages, &amp;quot;At least one base <span class="keyword">package</span> must be specified&amp;quot;);</div><div class="line">	Set&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&amp;lt;BeanDefinitionHolder&amp;gt;();</div><div class="line">	<span class="keyword">for</span> (String basePackage : basePackages) &#123;</div><div class="line">		Set&amp;lt;BeanDefinition&amp;gt; candidates = findCandidateComponents(basePackage);</div><div class="line">		<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</div><div class="line">			ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</div><div class="line">			candidate.setScope(scopeMetadata.getScopeName());</div><div class="line">			String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</div><div class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</div><div class="line">				postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</div><div class="line">				AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</div><div class="line">				BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</div><div class="line">				definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</div><div class="line">				beanDefinitions.add(definitionHolder);</div><div class="line">				registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> beanDefinitions;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>四、筛选类<br>展开findCandidateComponents方法。首先获取路径下的资源Resource，然后判断资源是否可读，并且获取可读资源的MetadataReader对象，然后再调用isCandidateComponent(MetadataReader)判段是否是候选组件，如果是，则生成该metadataReader的ScannedGenericBeanDefinition对象。最后判断ScannedGenericBeanDefinition是否为候选的，如果是则添加到工厂中。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public Set&amp;lt;BeanDefinition&amp;gt; findCandidateComponents(String basePackage) &#123;</div><div class="line">	Set&amp;lt;BeanDefinition&amp;gt; candidates = new LinkedHashSet&amp;lt;BeanDefinition&amp;gt;();</div><div class="line">	try &#123;</div><div class="line">		String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</div><div class="line">				resolveBasePackage(basePackage) + &amp;quot;/&amp;quot; + this.resourcePattern;</div><div class="line">		Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);</div><div class="line">		boolean traceEnabled = logger.isTraceEnabled();</div><div class="line">		boolean debugEnabled = logger.isDebugEnabled();</div><div class="line">		for (Resource resource : resources) &#123;</div><div class="line">			if (traceEnabled) &#123;</div><div class="line">				logger.trace(&amp;quot;Scanning &amp;quot; + resource);</div><div class="line">			&#125;</div><div class="line">			if (resource.isReadable()) &#123;</div><div class="line">				try &#123;</div><div class="line">					MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);</div><div class="line">					if (isCandidateComponent(metadataReader)) &#123;</div><div class="line">						ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);</div><div class="line">						sbd.setResource(resource);</div><div class="line">						sbd.setSource(resource);</div><div class="line">						if (isCandidateComponent(sbd)) &#123;</div><div class="line">							if (debugEnabled) &#123;</div><div class="line">								logger.debug(&amp;quot;Identified candidate component class: &amp;quot; + resource);</div><div class="line">							&#125;</div><div class="line">							candidates.add(sbd);</div><div class="line">						&#125;</div><div class="line">						else &#123;</div><div class="line">							if (debugEnabled) &#123;</div><div class="line">								logger.debug(&amp;quot;Ignored because not a concrete top-level class: &amp;quot; + resource);</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					else &#123;</div><div class="line">						if (traceEnabled) &#123;</div><div class="line">							logger.trace(&amp;quot;Ignored because not matching any filter: &amp;quot; + resource);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				catch (Throwable ex) &#123;</div><div class="line">					throw new BeanDefinitionStoreException(</div><div class="line">							&amp;quot;Failed to read candidate component class: &amp;quot; + resource, ex);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				if (traceEnabled) &#123;</div><div class="line">					logger.trace(&amp;quot;Ignored because not readable: &amp;quot; + resource);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">        catch (IOException ex) &#123;</div><div class="line">	       throw new BeanDefinitionStoreException(&amp;quot;I/O failure during classpath scanning&amp;quot;, ex);</div><div class="line">	&#125;</div><div class="line">	return candidates;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>展开isCandidateComponent方法。通过变量excludeFilters, includeFilters去匹配传递进来的MetadataReader，如果与excludeFilter匹配成功返回false， 与includeFilter匹配成功返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</div><div class="line">		<span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</div><div class="line">		<span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</div><div class="line">			<span class="keyword">return</span> isConditionMatch(metadataReader);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>五、注册bean factory</p>
<p>在上面doScan方法中有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注册到工厂中</span></div><div class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</div></pre></td></tr></table></figure></p>
<pre><code>这样一行代码将beanDefinition注册到registry中,这是一个BeanDefinitionRegistry，下面是它的接口定义及继承结构：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></div><div class="line">            <span class="keyword">throws</span> BeanDefinitionStoreException;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</div><div class="line">    String[] getBeanDefinitionNames();</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到接口中定义了诸多beandefinition的注册，删除，获取等方法，并且Spring为我们提供了三个内部实现，那么运行时，和之前文章的分析一样，使用了DefaultListableBeanFactory。<br>展开registerBeanDefinition方法。可以看出，所有的beanDefinition都由实例变量beanDefinitionMap来保存管理，他是一个ConcurrentHashMap，beanName作为键，beanDefinition对象作为值。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</div><div class="line">		throws BeanDefinitionStoreException &#123;</div><div class="line">	Assert.hasText(beanName, &amp;quot;Bean name must not be empty&amp;quot;);</div><div class="line">	Assert.notNull(beanDefinition, &amp;quot;BeanDefinition must not be null&amp;quot;);</div><div class="line">	if (beanDefinition instanceof AbstractBeanDefinition) &#123;</div><div class="line">		try &#123;</div><div class="line">			((AbstractBeanDefinition) beanDefinition).validate();</div><div class="line">		&#125;</div><div class="line">		catch (BeanDefinitionValidationException ex) &#123;</div><div class="line">			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</div><div class="line">					&amp;quot;Validation of bean definition failed&amp;quot;, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	BeanDefinition oldBeanDefinition;</div><div class="line"></div><div class="line">	oldBeanDefinition = this.beanDefinitionMap.get(beanName);</div><div class="line">	if (oldBeanDefinition != null) &#123;</div><div class="line">		if (!isAllowBeanDefinitionOverriding()) &#123;</div><div class="line">			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</div><div class="line">					&amp;quot;Cannot register bean definition [&amp;quot; + beanDefinition + &amp;quot;] for bean '&amp;quot; + beanName +</div><div class="line">					&amp;quot;': There is already [&amp;quot; + oldBeanDefinition + &amp;quot;] bound.&amp;quot;);</div><div class="line">		&#125;</div><div class="line">		else if (oldBeanDefinition.getRole() &amp;lt; beanDefinition.getRole()) &#123;</div><div class="line">			// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</div><div class="line">			if (this.logger.isWarnEnabled()) &#123;</div><div class="line">				this.logger.warn(&amp;quot;Overriding user-defined bean definition for bean '&amp;quot; + beanName +</div><div class="line">						&amp;quot;' with a framework-generated bean definition: replacing [&amp;quot; +</div><div class="line">						oldBeanDefinition + &amp;quot;] with [&amp;quot; + beanDefinition + &amp;quot;]&amp;quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			if (this.logger.isInfoEnabled()) &#123;</div><div class="line">				this.logger.info(&amp;quot;Overriding bean definition for bean '&amp;quot; + beanName +</div><div class="line">						&amp;quot;': replacing [&amp;quot; + oldBeanDefinition + &amp;quot;] with [&amp;quot; + beanDefinition + &amp;quot;]&amp;quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	else &#123;</div><div class="line">		this.beanDefinitionNames.add(beanName);</div><div class="line">		this.manualSingletonNames.remove(beanName);</div><div class="line">		this.frozenBeanDefinitionNames = null;</div><div class="line">	&#125;</div><div class="line">	this.beanDefinitionMap.put(beanName, beanDefinition);</div><div class="line">	if (oldBeanDefinition != null || containsSingleton(beanName)) &#123;</div><div class="line">		resetBeanDefinition(beanName);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、ContextLoader&lt;br&gt;通过阅读SpringMVC的源码可知，SpringMVC的初始化在ContextLoaderListener类中的contextInitialized方法，跟一下代码发现实际上是在ContextLoader中的initWebApplic
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 使用简单Demo进行源码调试（七）</title>
    <link href="http://yoursite.com/2015/05/18/Spring%20%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95Demo%E8%BF%9B%E8%A1%8C%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://yoursite.com/2015/05/18/Spring 使用简单Demo进行源码调试（七）/</id>
    <published>2015-05-17T23:53:08.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>手码不易，转载请注明：<a href="http://www.bugpointer.com/" target="_blank" rel="external">BUG指南</a></p>
<p>接上篇日志<a href="http://www.bugpointer.com/archives/521.html" target="_blank" rel="external">Spring 使用简单Demo进行源码调试（六）</a>继续。</p>
<p>经过前面几章详（gai）细（kuo）的调试，最后来到了Demo中的第二步，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Animal a = ctx.getBean(&amp;quot;animal&amp;quot;, Animal.class);<span class="comment">// 创建bean的引用对象</span></div></pre></td></tr></table></figure></p>
<p>展开getBean，代码如下。这一步通过getBeanFactory方法获取bean factory，然后使用bean factory获取对应的bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &amp;lt;T&amp;gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&amp;lt;T&amp;gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="keyword">return</span> getBeanFactory().getBean(name, requiredType);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>继续展开getBean。会走到之前初始化时候走到的方法,如下。由于已经初始化完毕，所以这一步走到Object sharedInstance = getSingleton(beanName);就会获取对应的bean实例。getSingleton这个函数的功能就是从已加载的实例中知道对应名称的bean实例，然后返回。接着代码进入if (sharedInstance != null &amp;&amp; args == null)这个if中，通过getObjectForBeanInstance获取bean，这个函数说简单简单，简单的时候就是把前面获取的bean返回，说复杂复杂，前面获取的bean并不是需要的bean，而是一个factory的情况下，则使用这个factoy生成一个bean，然后返回。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div></pre></td><td class="code"><pre><div class="line">protected &amp;lt;T&amp;gt; T doGetBean(</div><div class="line">			final String name, final Class&amp;lt;T&amp;gt; requiredType, final Object[] args, boolean typeCheckOnly)</div><div class="line">			throws BeansException &#123;</div><div class="line"></div><div class="line">		final String beanName = transformedBeanName(name);</div><div class="line">		Object bean;</div><div class="line"></div><div class="line">		// Eagerly check singleton cache for manually registered singletons.</div><div class="line">		Object sharedInstance = getSingleton(beanName);</div><div class="line">		if (sharedInstance != null &amp;amp;&amp;amp; args == null) &#123;</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				if (isSingletonCurrentlyInCreation(beanName)) &#123;</div><div class="line">					logger.debug(&amp;quot;Returning eagerly cached instance of singleton bean '&amp;quot; + beanName +</div><div class="line">							&amp;quot;' that is not fully initialized yet - a consequence of a circular reference&amp;quot;);</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					logger.debug(&amp;quot;Returning cached instance of singleton bean '&amp;quot; + beanName + &amp;quot;'&amp;quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		else &#123;</div><div class="line">			// Fail if we're already creating this bean instance:</div><div class="line">			// We're assumably within a circular reference.</div><div class="line">			if (isPrototypeCurrentlyInCreation(beanName)) &#123;</div><div class="line">				throw new BeanCurrentlyInCreationException(beanName);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			// Check if bean definition exists in this factory.</div><div class="line">			BeanFactory parentBeanFactory = getParentBeanFactory();</div><div class="line">			if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) &#123;</div><div class="line">				// Not found -&amp;gt; check parent.</div><div class="line">				String nameToLookup = originalBeanName(name);</div><div class="line">				if (args != null) &#123;</div><div class="line">					// Delegation to parent with explicit args.</div><div class="line">					return (T) parentBeanFactory.getBean(nameToLookup, args);</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					// No args -&amp;gt; delegate to standard getBean method.</div><div class="line">					return parentBeanFactory.getBean(nameToLookup, requiredType);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			if (!typeCheckOnly) &#123;</div><div class="line">				markBeanAsCreated(beanName);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			try &#123;</div><div class="line">				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</div><div class="line">				checkMergedBeanDefinition(mbd, beanName, args);</div><div class="line"></div><div class="line">				// Guarantee initialization of beans that the current bean depends on.</div><div class="line">				String[] dependsOn = mbd.getDependsOn();</div><div class="line">				if (dependsOn != null) &#123;</div><div class="line">					for (String dependsOnBean : dependsOn) &#123;</div><div class="line">						getBean(dependsOnBean);</div><div class="line">						registerDependentBean(dependsOnBean, beanName);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				// Create bean instance.</div><div class="line">				if (mbd.isSingleton()) &#123;</div><div class="line">					sharedInstance = getSingleton(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() &#123;</div><div class="line">						public Object getObject() throws BeansException &#123;</div><div class="line">							try &#123;</div><div class="line">								return createBean(beanName, mbd, args);</div><div class="line">							&#125;</div><div class="line">							catch (BeansException ex) &#123;</div><div class="line">								// Explicitly remove instance from singleton cache: It might have been put there</div><div class="line">								// eagerly by the creation process, to allow for circular reference resolution.</div><div class="line">								// Also remove any beans that received a temporary reference to the bean.</div><div class="line">								destroySingleton(beanName);</div><div class="line">								throw ex;</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">					&#125;);</div><div class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				else if (mbd.isPrototype()) &#123;</div><div class="line">					// It's a prototype -&amp;gt; create a new instance.</div><div class="line">					Object prototypeInstance = null;</div><div class="line">					try &#123;</div><div class="line">						beforePrototypeCreation(beanName);</div><div class="line">						prototypeInstance = createBean(beanName, mbd, args);</div><div class="line">					&#125;</div><div class="line">					finally &#123;</div><div class="line">						afterPrototypeCreation(beanName);</div><div class="line">					&#125;</div><div class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				else &#123;</div><div class="line">					String scopeName = mbd.getScope();</div><div class="line">					final Scope scope = this.scopes.get(scopeName);</div><div class="line">					if (scope == null) &#123;</div><div class="line">						throw new IllegalStateException(&amp;quot;No Scope registered for scope '&amp;quot; + scopeName + &amp;quot;'&amp;quot;);</div><div class="line">					&#125;</div><div class="line">					try &#123;</div><div class="line">						Object scopedInstance = scope.get(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() &#123;</div><div class="line">							public Object getObject() throws BeansException &#123;</div><div class="line">								beforePrototypeCreation(beanName);</div><div class="line">								try &#123;</div><div class="line">									return createBean(beanName, mbd, args);</div><div class="line">								&#125;</div><div class="line">								finally &#123;</div><div class="line">									afterPrototypeCreation(beanName);</div><div class="line">								&#125;</div><div class="line">							&#125;</div><div class="line">						&#125;);</div><div class="line">						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</div><div class="line">					&#125;</div><div class="line">					catch (IllegalStateException ex) &#123;</div><div class="line">						throw new BeanCreationException(beanName,</div><div class="line">								&amp;quot;Scope '&amp;quot; + scopeName + &amp;quot;' is not active for the current thread; &amp;quot; +</div><div class="line">								&amp;quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&amp;quot;,</div><div class="line">								ex);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			catch (BeansException ex) &#123;</div><div class="line">				cleanupAfterBeanCreationFailure(beanName);</div><div class="line">				throw ex;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Check if required type matches the type of the actual bean instance.</div><div class="line">		if (requiredType != null &amp;amp;&amp;amp; bean != null &amp;amp;&amp;amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</div><div class="line">			try &#123;</div><div class="line">				return getTypeConverter().convertIfNecessary(bean, requiredType);</div><div class="line">			&#125;</div><div class="line">			catch (TypeMismatchException ex) &#123;</div><div class="line">				if (logger.isDebugEnabled()) &#123;</div><div class="line">					logger.debug(&amp;quot;Failed to convert bean '&amp;quot; + name + &amp;quot;' to required type [&amp;quot; +</div><div class="line">							ClassUtils.getQualifiedName(requiredType) + &amp;quot;]&amp;quot;, ex);</div><div class="line">				&#125;</div><div class="line">				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return (T) bean;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public boolean containsBean(String name) &#123;</div><div class="line">		String beanName = transformedBeanName(name);</div><div class="line">		if (containsSingleton(beanName) || containsBeanDefinition(beanName)) &#123;</div><div class="line">			return (!BeanFactoryUtils.isFactoryDereference(name) || isFactoryBean(name));</div><div class="line">		&#125;</div><div class="line">		// Not found -&amp;gt; check parent.</div><div class="line">		BeanFactory parentBeanFactory = getParentBeanFactory();</div><div class="line">		return (parentBeanFactory != null &amp;amp;&amp;amp; parentBeanFactory.containsBean(originalBeanName(name)));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public boolean isSingleton(String name) throws NoSuchBeanDefinitionException &#123;</div><div class="line">		String beanName = transformedBeanName(name);</div><div class="line"></div><div class="line">		Object beanInstance = getSingleton(beanName, false);</div><div class="line">		if (beanInstance != null) &#123;</div><div class="line">			if (beanInstance instanceof FactoryBean) &#123;</div><div class="line">				return (BeanFactoryUtils.isFactoryDereference(name) || ((FactoryBean&amp;lt;?&amp;gt;) beanInstance).isSingleton());</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				return !BeanFactoryUtils.isFactoryDereference(name);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else if (containsSingleton(beanName)) &#123;</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		else &#123;</div><div class="line">			// No singleton instance found -&amp;gt; check bean definition.</div><div class="line">			BeanFactory parentBeanFactory = getParentBeanFactory();</div><div class="line">			if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) &#123;</div><div class="line">				// No bean definition found in this factory -&amp;gt; delegate to parent.</div><div class="line">				return parentBeanFactory.isSingleton(originalBeanName(name));</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</div><div class="line"></div><div class="line">			// In case of FactoryBean, return singleton status of created object if not a dereference.</div><div class="line">			if (mbd.isSingleton()) &#123;</div><div class="line">				if (isFactoryBean(beanName, mbd)) &#123;</div><div class="line">					if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</div><div class="line">						return true;</div><div class="line">					&#125;</div><div class="line">					FactoryBean&amp;lt;?&amp;gt; factoryBean = (FactoryBean&amp;lt;?&amp;gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</div><div class="line">					return factoryBean.isSingleton();</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					return !BeanFactoryUtils.isFactoryDereference(name);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				return false;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>在获取了bean以后，就可以使用这个bean了。简单的demo的分析就到此了，还有很多的问题和不足，Spring作为一个强大的java框架，复杂程度难以想象，在每一步的处理中到包含了大量的错误处理等目前没有分析到的部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手码不易，转载请注明：&lt;a href=&quot;http://www.bugpointer.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BUG指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接上篇日志&lt;a href=&quot;http://www.bugpointer.com/a
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 使用简单Demo进行源码调试（六）</title>
    <link href="http://yoursite.com/2015/05/15/Spring%20%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95Demo%E8%BF%9B%E8%A1%8C%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2015/05/15/Spring 使用简单Demo进行源码调试（六）/</id>
    <published>2015-05-15T00:34:58.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>手码不易，转载请注明：<a href="http://www.bugpointer.com/" target="_blank" rel="external">BUG指南</a></p>
<p>接上篇日志<a href="http://www.bugpointer.com/archives/517.html" target="_blank" rel="external">Spring 使用简单Demo进行源码调试（五）</a>继续。</p>
<p>接上一篇转日志的第十一步，这一步主要完成单例的初始化。直接进入这一步中的beanFactory.preInstantiateSingletons();这一步的功能主要在对每一个bean进行getBean(beanName);操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</div><div class="line">			<span class="keyword">this</span>.logger.info(&amp;quot;Pre-instantiating singletons in &amp;quot; + <span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		List&amp;lt;String&amp;gt; beanNames;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</div><div class="line">			<span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></div><div class="line">			<span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></div><div class="line">			beanNames = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;(<span class="keyword">this</span>.beanDefinitionNames);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></div><div class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</div><div class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</div><div class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !bd.isLazyInit()) &#123;</div><div class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</div><div class="line">					<span class="keyword">final</span> FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</div><div class="line">					<span class="keyword">boolean</span> isEagerInit;</div><div class="line">					<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;amp;&amp;amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</div><div class="line">						isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&amp;lt;Boolean&amp;gt;() &#123;</div><div class="line">							<span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">								<span class="keyword">return</span> ((SmartFactoryBean&amp;lt;?&amp;gt;) factory).isEagerInit();</div><div class="line">							&#125;</div><div class="line">						&#125;, getAccessControlContext());</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">else</span> &#123;</div><div class="line">						isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;amp;&amp;amp;</div><div class="line">								((SmartFactoryBean&amp;lt;?&amp;gt;) factory).isEagerInit());</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> (isEagerInit) &#123;</div><div class="line">						getBean(beanName);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					getBean(beanName);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>展开getBean(beanName);，再展开其中的doGetBean方法，首先检查单例缓存中是否存在这个单例，是则返回这个实例。否则创建这个实例，详见return createBean(beanName, mbd, args);这一句。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 返回实例</div><div class="line"> */</div><div class="line">@SuppressWarnings(&amp;quot;unchecked&amp;quot;)</div><div class="line">protected &amp;lt;T&amp;gt; T doGetBean(</div><div class="line">		final String name, final Class&amp;lt;T&amp;gt; requiredType, final Object[] args, boolean typeCheckOnly)</div><div class="line">		throws BeansException &#123;</div><div class="line"></div><div class="line">	final String beanName = transformedBeanName(name);</div><div class="line">	Object bean;</div><div class="line"></div><div class="line">	// 为了手动注册的单例，检查单例缓存.</div><div class="line">	Object sharedInstance = getSingleton(beanName);</div><div class="line">	if (sharedInstance != null &amp;amp;&amp;amp; args == null) &#123;</div><div class="line">		if (logger.isDebugEnabled()) &#123;</div><div class="line">			if (isSingletonCurrentlyInCreation(beanName)) &#123;</div><div class="line">				logger.debug(&amp;quot;Returning eagerly cached instance of singleton bean '&amp;quot; + beanName +</div><div class="line">						&amp;quot;' that is not fully initialized yet - a consequence of a circular reference&amp;quot;);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				logger.debug(&amp;quot;Returning cached instance of singleton bean '&amp;quot; + beanName + &amp;quot;'&amp;quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	else &#123;</div><div class="line">		// Fail if we're already creating this bean instance:</div><div class="line">		// We're assumably within a circular reference.</div><div class="line">		if (isPrototypeCurrentlyInCreation(beanName)) &#123;</div><div class="line">			throw new BeanCurrentlyInCreationException(beanName);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Check if bean definition exists in this factory.</div><div class="line">		BeanFactory parentBeanFactory = getParentBeanFactory();</div><div class="line">		if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) &#123;</div><div class="line">			// Not found -&amp;gt; check parent.</div><div class="line">			String nameToLookup = originalBeanName(name);</div><div class="line">			if (args != null) &#123;</div><div class="line">				// Delegation to parent with explicit args.</div><div class="line">				return (T) parentBeanFactory.getBean(nameToLookup, args);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				// No args -&amp;gt; delegate to standard getBean method.</div><div class="line">				return parentBeanFactory.getBean(nameToLookup, requiredType);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (!typeCheckOnly) &#123;</div><div class="line">			markBeanAsCreated(beanName);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</div><div class="line">			checkMergedBeanDefinition(mbd, beanName, args);</div><div class="line"></div><div class="line">			// Guarantee initialization of beans that the current bean depends on.</div><div class="line">			String[] dependsOn = mbd.getDependsOn();</div><div class="line">			if (dependsOn != null) &#123;</div><div class="line">				for (String dependsOnBean : dependsOn) &#123;</div><div class="line">					getBean(dependsOnBean);</div><div class="line">					registerDependentBean(dependsOnBean, beanName);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			// Create bean instance.</div><div class="line">			if (mbd.isSingleton()) &#123;</div><div class="line">				sharedInstance = getSingleton(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() &#123;</div><div class="line">					public Object getObject() throws BeansException &#123;</div><div class="line">						try &#123;</div><div class="line">							return createBean(beanName, mbd, args);</div><div class="line">						&#125;</div><div class="line">						catch (BeansException ex) &#123;</div><div class="line">							// Explicitly remove instance from singleton cache: It might have been put there</div><div class="line">							// eagerly by the creation process, to allow for circular reference resolution.</div><div class="line">							// Also remove any beans that received a temporary reference to the bean.</div><div class="line">							destroySingleton(beanName);</div><div class="line">							throw ex;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			else if (mbd.isPrototype()) &#123;</div><div class="line">				// It's a prototype -&amp;gt; create a new instance.</div><div class="line">				Object prototypeInstance = null;</div><div class="line">				try &#123;</div><div class="line">					beforePrototypeCreation(beanName);</div><div class="line">					prototypeInstance = createBean(beanName, mbd, args);</div><div class="line">				&#125;</div><div class="line">				finally &#123;</div><div class="line">					afterPrototypeCreation(beanName);</div><div class="line">				&#125;</div><div class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			else &#123;</div><div class="line">				String scopeName = mbd.getScope();</div><div class="line">				final Scope scope = this.scopes.get(scopeName);</div><div class="line">				if (scope == null) &#123;</div><div class="line">					throw new IllegalStateException(&amp;quot;No Scope registered for scope '&amp;quot; + scopeName + &amp;quot;'&amp;quot;);</div><div class="line">				&#125;</div><div class="line">				try &#123;</div><div class="line">					Object scopedInstance = scope.get(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() &#123;</div><div class="line">						public Object getObject() throws BeansException &#123;</div><div class="line">							beforePrototypeCreation(beanName);</div><div class="line">							try &#123;</div><div class="line">								return createBean(beanName, mbd, args);</div><div class="line">							&#125;</div><div class="line">							finally &#123;</div><div class="line">								afterPrototypeCreation(beanName);</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">					&#125;);</div><div class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</div><div class="line">				&#125;</div><div class="line">				catch (IllegalStateException ex) &#123;</div><div class="line">					throw new BeanCreationException(beanName,</div><div class="line">							&amp;quot;Scope '&amp;quot; + scopeName + &amp;quot;' is not active for the current thread; &amp;quot; +</div><div class="line">							&amp;quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&amp;quot;,</div><div class="line">							ex);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		catch (BeansException ex) &#123;</div><div class="line">			cleanupAfterBeanCreationFailure(beanName);</div><div class="line">			throw ex;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Check if required type matches the type of the actual bean instance.</div><div class="line">	if (requiredType != null &amp;amp;&amp;amp; bean != null &amp;amp;&amp;amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</div><div class="line">		try &#123;</div><div class="line">			return getTypeConverter().convertIfNecessary(bean, requiredType);</div><div class="line">		&#125;</div><div class="line">		catch (TypeMismatchException ex) &#123;</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&amp;quot;Failed to convert bean '&amp;quot; + name + &amp;quot;' to required type [&amp;quot; +</div><div class="line">						ClassUtils.getQualifiedName(requiredType) + &amp;quot;]&amp;quot;, ex);</div><div class="line">			&#125;</div><div class="line">			throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return (T) bean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>展开return createBean(beanName, mbd, args);辗转反侧，我们进入AbstractAutowireCapableBeanFactory类中的doCreateBean方法，展开这个方法，这个方法是实际用来创建bean。这个方法还是很复杂，就不一步步的进行分析了，大概来看就是首先对bean definition进行后处理，然后检查cache避免循环初始化，填充Bean，最后bean注册为一次性。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 */</div><div class="line">	protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123;</div><div class="line">		// Instantiate the bean.</div><div class="line">		BeanWrapper instanceWrapper = null;</div><div class="line">		if (mbd.isSingleton()) &#123;</div><div class="line">			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</div><div class="line">		&#125;</div><div class="line">		if (instanceWrapper == null) &#123;</div><div class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</div><div class="line">		&#125;</div><div class="line">		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</div><div class="line">		Class&amp;lt;?&amp;gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</div><div class="line"></div><div class="line">		// Allow post-processors to modify the merged bean definition.</div><div class="line">		synchronized (mbd.postProcessingLock) &#123;</div><div class="line">			if (!mbd.postProcessed) &#123;</div><div class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</div><div class="line">				mbd.postProcessed = true;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Eagerly cache singletons to be able to resolve circular references</div><div class="line">		// even when triggered by lifecycle interfaces like BeanFactoryAware.</div><div class="line">		boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;</div><div class="line">				isSingletonCurrentlyInCreation(beanName));</div><div class="line">		if (earlySingletonExposure) &#123;</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&amp;quot;Eagerly caching bean '&amp;quot; + beanName +</div><div class="line">						&amp;quot;' to allow for resolving potential circular references&amp;quot;);</div><div class="line">			&#125;</div><div class="line">			addSingletonFactory(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() &#123;</div><div class="line">				public Object getObject() throws BeansException &#123;</div><div class="line">					return getEarlyBeanReference(beanName, mbd, bean);</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Initialize the bean instance.</div><div class="line">		Object exposedObject = bean;</div><div class="line">		try &#123;</div><div class="line">			populateBean(beanName, mbd, instanceWrapper);</div><div class="line">			if (exposedObject != null) &#123;</div><div class="line">				exposedObject = initializeBean(beanName, exposedObject, mbd);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		catch (Throwable ex) &#123;</div><div class="line">			if (ex instanceof BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</div><div class="line">				throw (BeanCreationException) ex;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				throw new BeanCreationException(mbd.getResourceDescription(), beanName, &amp;quot;Initialization of bean failed&amp;quot;, ex);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (earlySingletonExposure) &#123;</div><div class="line">			Object earlySingletonReference = getSingleton(beanName, false);</div><div class="line">			if (earlySingletonReference != null) &#123;</div><div class="line">				if (exposedObject == bean) &#123;</div><div class="line">					exposedObject = earlySingletonReference;</div><div class="line">				&#125;</div><div class="line">				else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) &#123;</div><div class="line">					String[] dependentBeans = getDependentBeans(beanName);</div><div class="line">					Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;String&amp;gt;(dependentBeans.length);</div><div class="line">					for (String dependentBean : dependentBeans) &#123;</div><div class="line">						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</div><div class="line">							actualDependentBeans.add(dependentBean);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					if (!actualDependentBeans.isEmpty()) &#123;</div><div class="line">						throw new BeanCurrentlyInCreationException(beanName,</div><div class="line">								&amp;quot;Bean with name '&amp;quot; + beanName + &amp;quot;' has been injected into other beans [&amp;quot; +</div><div class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</div><div class="line">								&amp;quot;] in its raw version as part of a circular reference, but has eventually been &amp;quot; +</div><div class="line">								&amp;quot;wrapped. This means that said other beans do not use the final version of the &amp;quot; +</div><div class="line">								&amp;quot;bean. This is often the result of over-eager type matching - consider using &amp;quot; +</div><div class="line">								&amp;quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&amp;quot;);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// Register bean as disposable.</div><div class="line">		try &#123;</div><div class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</div><div class="line">		&#125;</div><div class="line">		catch (BeanDefinitionValidationException ex) &#123;</div><div class="line">			throw new BeanCreationException(mbd.getResourceDescription(), beanName, &amp;quot;Invalid destruction signature&amp;quot;, ex);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return exposedObject;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>接着我们一直走，走到applyPropertyValues方法，该方法给予bean指定的属性。这个方法首先从pvs中获取所有的属性信息，对每一个属性信息获取对应的属性值，这里的属性值是通过一系列转换得到的。最后通过包装类的setPropertyValues方法设置属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 给予bean指定的属性</div><div class="line">	 * <span class="doctag">@param</span> beanName bean 名称</div><div class="line">	 * <span class="doctag">@param</span> mbd bean定义</div><div class="line">	 * <span class="doctag">@param</span> bw 目标对象的包装类</div><div class="line">	 * <span class="doctag">@param</span> pvs 属性</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		MutablePropertyValues mpvs = <span class="keyword">null</span>;</div><div class="line">		List&amp;lt;PropertyValue&amp;gt; original;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</div><div class="line">				((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</div><div class="line">			mpvs = (MutablePropertyValues) pvs;</div><div class="line">			<span class="keyword">if</span> (mpvs.isConverted()) &#123;</div><div class="line">				<span class="comment">// Shortcut: use the pre-converted values as-is.</span></div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					bw.setPropertyValues(mpvs);</div><div class="line">					<span class="keyword">return</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</div><div class="line">							mbd.getResourceDescription(), beanName, &amp;quot;Error setting property values&amp;quot;, ex);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			original = mpvs.getPropertyValueList();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			original = Arrays.asList(pvs.getPropertyValues());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		TypeConverter converter = getCustomTypeConverter();</div><div class="line">		<span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</div><div class="line">			converter = bw;</div><div class="line">		&#125;</div><div class="line">		BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</div><div class="line"></div><div class="line">		<span class="comment">// Create a deep copy, resolving any references for values.</span></div><div class="line">		List&amp;lt;PropertyValue&amp;gt; deepCopy = <span class="keyword">new</span> ArrayList&amp;lt;PropertyValue&amp;gt;(original.size());</div><div class="line">		<span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">for</span> (PropertyValue pv : original) &#123;</div><div class="line">			<span class="keyword">if</span> (pv.isConverted()) &#123;</div><div class="line">				deepCopy.add(pv);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				String propertyName = pv.getName();</div><div class="line">				Object originalValue = pv.getValue();</div><div class="line">				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</div><div class="line">				Object convertedValue = resolvedValue;</div><div class="line">				<span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;amp;&amp;amp;</div><div class="line">						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</div><div class="line">				<span class="keyword">if</span> (convertible) &#123;</div><div class="line">					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">// Possibly store converted value in merged bean definition,</span></div><div class="line">				<span class="comment">// in order to avoid re-conversion for every created bean instance.</span></div><div class="line">				<span class="keyword">if</span> (resolvedValue == originalValue) &#123;</div><div class="line">					<span class="keyword">if</span> (convertible) &#123;</div><div class="line">						pv.setConvertedValue(convertedValue);</div><div class="line">					&#125;</div><div class="line">					deepCopy.add(pv);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;amp;&amp;amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;amp;&amp;amp;</div><div class="line">						!((TypedStringValue) originalValue).isDynamic() &amp;amp;&amp;amp;</div><div class="line">						!(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</div><div class="line">					pv.setConvertedValue(convertedValue);</div><div class="line">					deepCopy.add(pv);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					resolveNecessary = <span class="keyword">true</span>;</div><div class="line">					deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;amp;&amp;amp; !resolveNecessary) &#123;</div><div class="line">			mpvs.setConverted();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Set our (possibly massaged) deep copy.</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</div><div class="line">					mbd.getResourceDescription(), beanName, &amp;quot;Error setting property values&amp;quot;, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>最后辗转反侧到了BeanWrapperImpl中的setPropertyValue方法，首先获取属性名称，这里的tokens.keys我也不知道是什么。可以看到最后使用writeMethod.invoke(this.object, value);方法设置了属性值，这里使用的java的反射思想。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div></pre></td><td class="code"><pre><div class="line">private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException &#123;</div><div class="line">		String propertyName = tokens.canonicalName;</div><div class="line">		String actualName = tokens.actualName;</div><div class="line"></div><div class="line">		if (tokens.keys != null) &#123;</div><div class="line">			// Apply indexes and map keys: fetch value for all keys but the last one.</div><div class="line">			PropertyTokenHolder getterTokens = new PropertyTokenHolder();</div><div class="line">			getterTokens.canonicalName = tokens.canonicalName;</div><div class="line">			getterTokens.actualName = tokens.actualName;</div><div class="line">			getterTokens.keys = new String[tokens.keys.length - 1];</div><div class="line">			System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);</div><div class="line">			Object propValue;</div><div class="line">			try &#123;</div><div class="line">				propValue = getPropertyValue(getterTokens);</div><div class="line">			&#125;</div><div class="line">			catch (NotReadablePropertyException ex) &#123;</div><div class="line">				throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,</div><div class="line">						&amp;quot;Cannot access indexed value in property referenced &amp;quot; +</div><div class="line">						&amp;quot;in indexed property path '&amp;quot; + propertyName + &amp;quot;'&amp;quot;, ex);</div><div class="line">			&#125;</div><div class="line">			// Set value for last key.</div><div class="line">			String key = tokens.keys[tokens.keys.length - 1];</div><div class="line">			if (propValue == null) &#123;</div><div class="line">				// null map value case</div><div class="line">				if (this.autoGrowNestedPaths) &#123;</div><div class="line">					// TODO: cleanup, this is pretty hacky</div><div class="line">					int lastKeyIndex = tokens.canonicalName.lastIndexOf('[');</div><div class="line">					getterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);</div><div class="line">					propValue = setDefaultValue(getterTokens);</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,</div><div class="line">							&amp;quot;Cannot access indexed value in property referenced &amp;quot; +</div><div class="line">							&amp;quot;in indexed property path '&amp;quot; + propertyName + &amp;quot;': returned null&amp;quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			if (propValue.getClass().isArray()) &#123;</div><div class="line">				PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</div><div class="line">				Class&amp;lt;?&amp;gt; requiredType = propValue.getClass().getComponentType();</div><div class="line">				int arrayIndex = Integer.parseInt(key);</div><div class="line">				Object oldValue = null;</div><div class="line">				try &#123;</div><div class="line">					if (isExtractOldValueForEditor() &amp;amp;&amp;amp; arrayIndex &amp;lt; Array.getLength(propValue)) &#123;</div><div class="line">						oldValue = Array.get(propValue, arrayIndex);</div><div class="line">					&#125;</div><div class="line">					Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</div><div class="line">							requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));</div><div class="line">					Array.set(propValue, arrayIndex, convertedValue);</div><div class="line">				&#125;</div><div class="line">				catch (IndexOutOfBoundsException ex) &#123;</div><div class="line">					throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,</div><div class="line">							&amp;quot;Invalid array index in property path '&amp;quot; + propertyName + &amp;quot;'&amp;quot;, ex);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			else if (propValue instanceof List) &#123;</div><div class="line">				PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</div><div class="line">				Class&amp;lt;?&amp;gt; requiredType = GenericCollectionTypeResolver.getCollectionReturnType(</div><div class="line">						pd.getReadMethod(), tokens.keys.length);</div><div class="line">				List&amp;lt;Object&amp;gt; list = (List&amp;lt;Object&amp;gt;) propValue;</div><div class="line">				int index = Integer.parseInt(key);</div><div class="line">				Object oldValue = null;</div><div class="line">				if (isExtractOldValueForEditor() &amp;amp;&amp;amp; index &amp;lt; list.size()) &#123;</div><div class="line">					oldValue = list.get(index);</div><div class="line">				&#125;</div><div class="line">				Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</div><div class="line">						requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));</div><div class="line">				int size = list.size();</div><div class="line">				if (index &amp;gt;= size &amp;amp;&amp;amp; index &amp;lt; this.autoGrowCollectionLimit) &#123;</div><div class="line">					for (int i = size; i &amp;lt; index; i++) &#123;</div><div class="line">						try &#123;</div><div class="line">							list.add(null);</div><div class="line">						&#125;</div><div class="line">						catch (NullPointerException ex) &#123;</div><div class="line">							throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,</div><div class="line">									&amp;quot;Cannot set element with index &amp;quot; + index + &amp;quot; in List of size &amp;quot; +</div><div class="line">									size + &amp;quot;, accessed using property path '&amp;quot; + propertyName +</div><div class="line">									&amp;quot;': List does not support filling up gaps with null elements&amp;quot;);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					list.add(convertedValue);</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					try &#123;</div><div class="line">						list.set(index, convertedValue);</div><div class="line">					&#125;</div><div class="line">					catch (IndexOutOfBoundsException ex) &#123;</div><div class="line">						throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,</div><div class="line">								&amp;quot;Invalid list index in property path '&amp;quot; + propertyName + &amp;quot;'&amp;quot;, ex);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			else if (propValue instanceof Map) &#123;</div><div class="line">				PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</div><div class="line">				Class&amp;lt;?&amp;gt; mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(</div><div class="line">						pd.getReadMethod(), tokens.keys.length);</div><div class="line">				Class&amp;lt;?&amp;gt; mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(</div><div class="line">						pd.getReadMethod(), tokens.keys.length);</div><div class="line">				Map&amp;lt;Object, Object&amp;gt; map = (Map&amp;lt;Object, Object&amp;gt;) propValue;</div><div class="line">				// IMPORTANT: Do not pass full property name in here - property editors</div><div class="line">				// must not kick in for map keys but rather only for map values.</div><div class="line">				TypeDescriptor typeDescriptor = (mapKeyType != null ?</div><div class="line">						TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));</div><div class="line">				Object convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);</div><div class="line">				Object oldValue = null;</div><div class="line">				if (isExtractOldValueForEditor()) &#123;</div><div class="line">					oldValue = map.get(convertedMapKey);</div><div class="line">				&#125;</div><div class="line">				// Pass full property name and old value in here, since we want full</div><div class="line">				// conversion ability for map values.</div><div class="line">				Object convertedMapValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</div><div class="line">						mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));</div><div class="line">				map.put(convertedMapKey, convertedMapValue);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,</div><div class="line">						&amp;quot;Property referenced in indexed property path '&amp;quot; + propertyName +</div><div class="line">						&amp;quot;' is neither an array nor a List nor a Map; returned value was [&amp;quot; + pv.getValue() + &amp;quot;]&amp;quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		else &#123;</div><div class="line">			PropertyDescriptor pd = pv.resolvedDescriptor;</div><div class="line">			if (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) &#123;</div><div class="line">				pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</div><div class="line">				if (pd == null || pd.getWriteMethod() == null) &#123;</div><div class="line">					if (pv.isOptional()) &#123;</div><div class="line">						logger.debug(&amp;quot;Ignoring optional value for property '&amp;quot; + actualName +</div><div class="line">								&amp;quot;' - property not found on bean class [&amp;quot; + getRootClass().getName() + &amp;quot;]&amp;quot;);</div><div class="line">						return;</div><div class="line">					&#125;</div><div class="line">					else &#123;</div><div class="line">						PropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());</div><div class="line">						throw new NotWritablePropertyException(</div><div class="line">								getRootClass(), this.nestedPath + propertyName,</div><div class="line">								matches.buildErrorMessage(), matches.getPossibleMatches());</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				pv.getOriginalPropertyValue().resolvedDescriptor = pd;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			Object oldValue = null;</div><div class="line">			try &#123;</div><div class="line">				Object originalValue = pv.getValue();</div><div class="line">				Object valueToApply = originalValue;</div><div class="line">				if (!Boolean.FALSE.equals(pv.conversionNecessary)) &#123;</div><div class="line">					if (pv.isConverted()) &#123;</div><div class="line">						valueToApply = pv.getConvertedValue();</div><div class="line">					&#125;</div><div class="line">					else &#123;</div><div class="line">						if (isExtractOldValueForEditor() &amp;amp;&amp;amp; pd.getReadMethod() != null) &#123;</div><div class="line">							final Method readMethod = pd.getReadMethod();</div><div class="line">							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &amp;amp;&amp;amp;</div><div class="line">									!readMethod.isAccessible()) &#123;</div><div class="line">								if (System.getSecurityManager()!= null) &#123;</div><div class="line">									AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() &#123;</div><div class="line">										public Object run() &#123;</div><div class="line">											readMethod.setAccessible(true);</div><div class="line">											return null;</div><div class="line">										&#125;</div><div class="line">									&#125;);</div><div class="line">								&#125;</div><div class="line">								else &#123;</div><div class="line">									readMethod.setAccessible(true);</div><div class="line">								&#125;</div><div class="line">							&#125;</div><div class="line">							try &#123;</div><div class="line">								if (System.getSecurityManager() != null) &#123;</div><div class="line">									oldValue = AccessController.doPrivileged(new PrivilegedExceptionAction&amp;lt;Object&amp;gt;() &#123;</div><div class="line">										public Object run() throws Exception &#123;</div><div class="line">											return readMethod.invoke(object);</div><div class="line">										&#125;</div><div class="line">									&#125;, acc);</div><div class="line">								&#125;</div><div class="line">								else &#123;</div><div class="line">									oldValue = readMethod.invoke(object);</div><div class="line">								&#125;</div><div class="line">							&#125;</div><div class="line">							catch (Exception ex) &#123;</div><div class="line">								if (ex instanceof PrivilegedActionException) &#123;</div><div class="line">									ex = ((PrivilegedActionException) ex).getException();</div><div class="line">								&#125;</div><div class="line">								if (logger.isDebugEnabled()) &#123;</div><div class="line">									logger.debug(&amp;quot;Could not read previous value of property '&amp;quot; +</div><div class="line">											this.nestedPath + propertyName + &amp;quot;'&amp;quot;, ex);</div><div class="line">								&#125;</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">						valueToApply = convertForProperty(</div><div class="line">								propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));</div><div class="line">					&#125;</div><div class="line">					pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);</div><div class="line">				&#125;</div><div class="line">				final Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?</div><div class="line">						((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :</div><div class="line">						pd.getWriteMethod());</div><div class="line">				if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) &amp;amp;&amp;amp; !writeMethod.isAccessible()) &#123;</div><div class="line">					if (System.getSecurityManager()!= null) &#123;</div><div class="line">						AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() &#123;</div><div class="line">							public Object run() &#123;</div><div class="line">								writeMethod.setAccessible(true);</div><div class="line">								return null;</div><div class="line">							&#125;</div><div class="line">						&#125;);</div><div class="line">					&#125;</div><div class="line">					else &#123;</div><div class="line">						writeMethod.setAccessible(true);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				final Object value = valueToApply;</div><div class="line">				if (System.getSecurityManager() != null) &#123;</div><div class="line">					try &#123;</div><div class="line">						AccessController.doPrivileged(new PrivilegedExceptionAction&amp;lt;Object&amp;gt;() &#123;</div><div class="line">							public Object run() throws Exception &#123;</div><div class="line">								writeMethod.invoke(object, value);</div><div class="line">								return null;</div><div class="line">							&#125;</div><div class="line">						&#125;, acc);</div><div class="line">					&#125;</div><div class="line">					catch (PrivilegedActionException ex) &#123;</div><div class="line">						throw ex.getException();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					writeMethod.invoke(this.object, value);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			catch (TypeMismatchException ex) &#123;</div><div class="line">				throw ex;</div><div class="line">			&#125;</div><div class="line">			catch (InvocationTargetException ex) &#123;</div><div class="line">				PropertyChangeEvent propertyChangeEvent =</div><div class="line">						new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());</div><div class="line">				if (ex.getTargetException() instanceof ClassCastException) &#123;</div><div class="line">					throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			catch (Exception ex) &#123;</div><div class="line">				PropertyChangeEvent pce =</div><div class="line">						new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());</div><div class="line">				throw new MethodInvocationException(pce, ex);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>由于Spring代码过于庞大，工作忙，时间有限，只能进行打开的代码流程分析，希望以后会有时间进行更加详细的分析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手码不易，转载请注明：&lt;a href=&quot;http://www.bugpointer.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BUG指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接上篇日志&lt;a href=&quot;http://www.bugpointer.com/a
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 使用简单Demo进行源码调试（五）</title>
    <link href="http://yoursite.com/2015/05/12/Spring%20%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95Demo%E8%BF%9B%E8%A1%8C%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2015/05/12/Spring 使用简单Demo进行源码调试（五）/</id>
    <published>2015-05-12T00:24:35.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>手码不易，转载请注明：<a href="http://www.bugpointer.com/" target="_blank" rel="external">BUG指南</a></p>
<p>接上篇日志<a href="http://www.bugpointer.com/archives/511.html" target="_blank" rel="external">Spring 使用简单Demo进行源码调试（四）</a>继续。</p>
<p>还记得refresh()函数嘛，记得也模糊了吧，贴出来好了。其中的第二步 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()已经用大篇幅描述了基本流程。接着看以下几步。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">            <span class="comment">// 为了刷新准备上下文</span></div><div class="line">            prepareRefresh();</div><div class="line"></div><div class="line">            <span class="comment">// 利用子类完成内部bean factory的刷新</span></div><div class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class="line"></div><div class="line">            <span class="comment">// 使用本地上下文准备bean factory</span></div><div class="line">            prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 允许在上下文子类中完成bean factory后处理</span></div><div class="line">                postProcessBeanFactory(beanFactory);</div><div class="line"></div><div class="line">                <span class="comment">// 调用上下文注册的bean factory处理器</span></div><div class="line">                invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line"></div><div class="line">                <span class="comment">// 注册拦截bean创建的bean处理器</span></div><div class="line">                registerBeanPostProcessors(beanFactory);</div><div class="line"></div><div class="line">                <span class="comment">// 初始化上下文中消息源</span></div><div class="line">                initMessageSource();</div><div class="line"></div><div class="line">                <span class="comment">// 初始化上下文中的事件多播</span></div><div class="line">                initApplicationEventMulticaster();</div><div class="line"></div><div class="line">                <span class="comment">// 在特定上下文子类中初始化其他特殊bean</span></div><div class="line">                onRefresh();</div><div class="line"></div><div class="line">                <span class="comment">// 检查监听器bean并注册 </span></div><div class="line">                registerListeners();</div><div class="line"></div><div class="line">                <span class="comment">// 实例化所有剩余(non-lazy-init)单例</span></div><div class="line">                finishBeanFactoryInitialization(beanFactory);</div><div class="line"></div><div class="line">                <span class="comment">// 发布相应的事件</span></div><div class="line">                finishRefresh();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">                logger.warn(&amp;quot;Exception encountered during context initialization - cancelling refresh attempt&amp;quot;, ex);</div><div class="line"></div><div class="line">                <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></div><div class="line">                destroyBeans();</div><div class="line"></div><div class="line">                <span class="comment">// Reset 'active' flag.</span></div><div class="line">                cancelRefresh(ex);</div><div class="line"></div><div class="line">                <span class="comment">// Propagate exception to caller.</span></div><div class="line">                <span class="keyword">throw</span> ex;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>第三步<br>展开 prepareBeanFactory(beanFactory)。有以下几步：<br>1. 使内部bean factory使用上下文类加载器等；<br>2. 使用上下文回调配置bean factory；<br>3. BeanFactory接口没有在在一个普通的工厂内注册为可解析类型；<br>4. 检测LoadTimeWeaver并准备织入；<br>5. 注册默认的环境beans。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 配置factory标准上下文特征</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class="line">		<span class="comment">// 使内部bean factory使用上下文类加载器等</span></div><div class="line">		beanFactory.setBeanClassLoader(getClassLoader());</div><div class="line">		beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver());</div><div class="line">		beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</div><div class="line"></div><div class="line">		<span class="comment">// 使用上下文回调配置bean factory</span></div><div class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</div><div class="line">		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</div><div class="line">		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</div><div class="line">		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</div><div class="line">		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</div><div class="line">		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</div><div class="line"></div><div class="line">		<span class="comment">// BeanFactory接口没有在在一个普通的工厂内注册为可解析类型</span></div><div class="line">		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</div><div class="line">		beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</div><div class="line">		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</div><div class="line">		beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 检测LoadTimeWeaver并准备织入</span></div><div class="line">		<span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</div><div class="line">			beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</div><div class="line">			<span class="comment">// Set a temporary ClassLoader for type matching.</span></div><div class="line">			beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 注册默认的环境beans</span></div><div class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</div><div class="line">			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</div><div class="line">			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</div><div class="line">			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">`</div></pre></td></tr></table></figure>
<p>第四步<br>postProcessBeanFactory(beanFactory)这一步允许子类对bean factory进行后处理，这里没有实现，不用展开。</p>
<p>第五步<br>invokeBeanFactoryPostProcessors(beanFactory)调用在上下文中作为bean注册的factory处理器。看起来比较复杂的一个方法，做了以下工作<br>1. 如果存在BeanDefinitionRegistryPostProcessors实例，则进行调用；<br>2. 寻找BeanFactoryPostProcessors实例，区分PriorityOrdered、Ordered和其他；<br>3. 调用继承PriorityOrdered的BeanFactoryPostProcessors实例；<br>4. 调用继承Ordered的BeanFactoryPostProcessors实例；<br>5. 调用其他BeanFactoryPostProcessors实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 调用在上下文中作为bean注册的factory处理器,</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class="line">		<span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></div><div class="line">		Set&amp;lt;String&amp;gt; processedBeans = <span class="keyword">new</span> HashSet&amp;lt;String&amp;gt;();</div><div class="line">		<span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</div><div class="line">			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</div><div class="line">			List&amp;lt;BeanFactoryPostProcessor&amp;gt; regularPostProcessors = <span class="keyword">new</span> LinkedList&amp;lt;BeanFactoryPostProcessor&amp;gt;();</div><div class="line">			List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; registryPostProcessors =</div><div class="line">					<span class="keyword">new</span> LinkedList&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt;();</div><div class="line">			<span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : getBeanFactoryPostProcessors()) &#123;</div><div class="line">				<span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</div><div class="line">					BeanDefinitionRegistryPostProcessor registryPostProcessor =</div><div class="line">							(BeanDefinitionRegistryPostProcessor) postProcessor;</div><div class="line">					registryPostProcessor.postProcessBeanDefinitionRegistry(registry);</div><div class="line">					registryPostProcessors.add(registryPostProcessor);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					regularPostProcessors.add(postProcessor);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			Map&amp;lt;String, BeanDefinitionRegistryPostProcessor&amp;gt; beanMap =</div><div class="line">					beanFactory.getBeansOfType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">			List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; registryPostProcessorBeans =</div><div class="line">					<span class="keyword">new</span> ArrayList&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt;(beanMap.values());</div><div class="line">			OrderComparator.sort(registryPostProcessorBeans);</div><div class="line">			<span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : registryPostProcessorBeans) &#123;</div><div class="line">				postProcessor.postProcessBeanDefinitionRegistry(registry);</div><div class="line">			&#125;</div><div class="line">			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);</div><div class="line">			invokeBeanFactoryPostProcessors(registryPostProcessorBeans, beanFactory);</div><div class="line">			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</div><div class="line">			processedBeans.addAll(beanMap.keySet());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// Invoke factory processors registered with the context instance.</span></div><div class="line">			invokeBeanFactoryPostProcessors(getBeanFactoryPostProcessors(), beanFactory);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></div><div class="line">		<span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></div><div class="line">		String[] postProcessorNames =</div><div class="line">				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">		<span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></div><div class="line">		<span class="comment">// Ordered, and the rest.</span></div><div class="line">		List&amp;lt;BeanFactoryPostProcessor&amp;gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&amp;lt;BeanFactoryPostProcessor&amp;gt;();</div><div class="line">		List&amp;lt;String&amp;gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;();</div><div class="line">		List&amp;lt;String&amp;gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;();</div><div class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</div><div class="line">			<span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</div><div class="line">				<span class="comment">// skip - already processed in first phase above</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (isTypeMatch(ppName, PriorityOrdered.class)) &#123;</div><div class="line">				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (isTypeMatch(ppName, Ordered.class)) &#123;</div><div class="line">				orderedPostProcessorNames.add(ppName);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				nonOrderedPostProcessorNames.add(ppName);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></div><div class="line">		OrderComparator.sort(priorityOrderedPostProcessors);</div><div class="line">		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</div><div class="line"></div><div class="line">		<span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></div><div class="line">		List&amp;lt;BeanFactoryPostProcessor&amp;gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&amp;lt;BeanFactoryPostProcessor&amp;gt;();</div><div class="line">		<span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</div><div class="line">			orderedPostProcessors.add(getBean(postProcessorName, BeanFactoryPostProcessor.class));</div><div class="line">		&#125;</div><div class="line">		OrderComparator.sort(orderedPostProcessors);</div><div class="line">		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</div><div class="line"></div><div class="line">		<span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></div><div class="line">		List&amp;lt;BeanFactoryPostProcessor&amp;gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&amp;lt;BeanFactoryPostProcessor&amp;gt;();</div><div class="line">		<span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</div><div class="line">			nonOrderedPostProcessors.add(getBean(postProcessorName, BeanFactoryPostProcessor.class));</div><div class="line">		&#125;</div><div class="line">		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第六步<br>registerBeanPostProcessors(beanFactory)注册拦截bean创建的处理器。这一步的步骤与上一部类似，如下，<br>1. 在BeanPostProcessor实例化的过程中有bean创建，则注册BeanPostProcessorChecker，该类完成对info信息的日志写入；<br>2. 寻找BeanPostProcessors实例，区分PriorityOrdered、Ordered和其他；<br>3. 注册继承PriorityOrdered的BeanPostProcessors实例；<br>4. 注册继承Ordered的BeanPostProcessors实例；<br>5. 注册其他合格的BeanPostProcessors实例。<br>6. 重新注册其他内部的BeanPostProcessors实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Instantiate and invoke all registered BeanPostProcessor beans,</div><div class="line">	 * respecting explicit order if given.</div><div class="line">	 * &amp;lt;p&amp;gt;Must be called before any instantiation of application beans.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">		<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></div><div class="line">		<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></div><div class="line">		<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></div><div class="line">		<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</div><div class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</div><div class="line"></div><div class="line">		<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></div><div class="line">		<span class="comment">// Ordered, and the rest.</span></div><div class="line">		List&amp;lt;BeanPostProcessor&amp;gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&amp;lt;BeanPostProcessor&amp;gt;();</div><div class="line">		List&amp;lt;BeanPostProcessor&amp;gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&amp;lt;BeanPostProcessor&amp;gt;();</div><div class="line">		List&amp;lt;String&amp;gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;();</div><div class="line">		List&amp;lt;String&amp;gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&amp;lt;String&amp;gt;();</div><div class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</div><div class="line">			<span class="keyword">if</span> (isTypeMatch(ppName, PriorityOrdered.class)) &#123;</div><div class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">				priorityOrderedPostProcessors.add(pp);</div><div class="line">				<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">					internalPostProcessors.add(pp);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (isTypeMatch(ppName, Ordered.class)) &#123;</div><div class="line">				orderedPostProcessorNames.add(ppName);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				nonOrderedPostProcessorNames.add(ppName);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></div><div class="line">		OrderComparator.sort(priorityOrderedPostProcessors);</div><div class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line"></div><div class="line">		<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></div><div class="line">		List&amp;lt;BeanPostProcessor&amp;gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&amp;lt;BeanPostProcessor&amp;gt;();</div><div class="line">		<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</div><div class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">			orderedPostProcessors.add(pp);</div><div class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">				internalPostProcessors.add(pp);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		OrderComparator.sort(orderedPostProcessors);</div><div class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line"></div><div class="line">		<span class="comment">// Now, register all regular BeanPostProcessors.</span></div><div class="line">		List&amp;lt;BeanPostProcessor&amp;gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&amp;lt;BeanPostProcessor&amp;gt;();</div><div class="line">		<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</div><div class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</div><div class="line">			nonOrderedPostProcessors.add(pp);</div><div class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</div><div class="line">				internalPostProcessors.add(pp);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</div><div class="line"></div><div class="line">		<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></div><div class="line">		OrderComparator.sort(internalPostProcessors);</div><div class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</div><div class="line"></div><div class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>第七步<br>initMessageSource()初始化MessageSource, 如果是null，在使用父类的。首先检查是否有MessageSource的定义，有的话，设置其父MessageSource；没有的话使用空MessageSource。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 * 初始化MessageSource, 如果是null，在使用父类的</div><div class="line">	 */</div><div class="line">	protected void initMessageSource() &#123;</div><div class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class="line">		if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</div><div class="line">			this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</div><div class="line">			// Make MessageSource aware of parent MessageSource.</div><div class="line">			if (this.parent != null &amp;amp;&amp;amp; this.messageSource instanceof HierarchicalMessageSource) &#123;</div><div class="line">				HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;</div><div class="line">				if (hms.getParentMessageSource() == null) &#123;</div><div class="line">					// Only set parent context as parent MessageSource if no parent MessageSource</div><div class="line">					// registered already.</div><div class="line">					hms.setParentMessageSource(getInternalParentMessageSource());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&amp;quot;Using MessageSource [&amp;quot; + this.messageSource + &amp;quot;]&amp;quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			// Use empty MessageSource to be able to accept getMessage calls.</div><div class="line">			DelegatingMessageSource dms = new DelegatingMessageSource();</div><div class="line">			dms.setParentMessageSource(getInternalParentMessageSource());</div><div class="line">			this.messageSource = dms;</div><div class="line">			beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&amp;quot;Unable to locate MessageSource with name '&amp;quot; + MESSAGE_SOURCE_BEAN_NAME +</div><div class="line">						&amp;quot;': using default [&amp;quot; + this.messageSource + &amp;quot;]&amp;quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第八步<br>initApplicationEventMulticaster()初始化ApplicationEventMulticaster，如果没有ApplicationEventMulticaster定义则使用SimpleApplicationEventMulticaster。首先判断是否存在ApplicationEventMulticaster的本定义，存在的话则获取该bean，否则新建一个SimpleApplicationEventMulticaster。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 * 初始化ApplicationEventMulticaster，如果没有ApplicationEventMulticaster定义则使用SimpleApplicationEventMulticaster</div><div class="line">	 */</div><div class="line">	protected void initApplicationEventMulticaster() &#123;</div><div class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class="line">		if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</div><div class="line">			this.applicationEventMulticaster =</div><div class="line">					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&amp;quot;Using ApplicationEventMulticaster [&amp;quot; + this.applicationEventMulticaster + &amp;quot;]&amp;quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);</div><div class="line">			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&amp;quot;Unable to locate ApplicationEventMulticaster with name '&amp;quot; +</div><div class="line">						APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</div><div class="line">						&amp;quot;': using default [&amp;quot; + this.applicationEventMulticaster + &amp;quot;]&amp;quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第九步<br>onRefresh()初始化子类中特殊的bean。这是一个可以被覆盖的添加添加上下文更新工作的模板方法，在单例对象的实例化之前初始化的特殊bean。</p>
<p>第十步<br>registerListeners()检测监听器bean并注册。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 添加实现ApplicationListener的bean作为监听器。不会影响其他可以不是bean的监听器。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 先注册静态指定侦听器.</span></div><div class="line">		<span class="keyword">for</span> (ApplicationListener&amp;lt;?&amp;gt; listener : getApplicationListeners()) &#123;</div><div class="line">			getApplicationEventMulticaster().addApplicationListener(listener);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></div><div class="line">		<span class="comment">// uninitialized to let post-processors apply to them!</span></div><div class="line">		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">		<span class="keyword">for</span> (String lisName : listenerBeanNames) &#123;</div><div class="line">			getApplicationEventMulticaster().addApplicationListenerBean(lisName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第十一步<br>finishBeanFactoryInitialization(beanFactory)初始化所有剩余的单例。这个方法比较复杂，下回讨论。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 结束上下文bean factory的初始化,</div><div class="line">	 * 初始化所有剩余的单例.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class="line">		<span class="comment">// 这个上下文初始化转换服务。</span></div><div class="line">		<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;amp;&amp;amp;</div><div class="line">				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</div><div class="line">			beanFactory.setConversionService(</div><div class="line">					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 初始化LoadTimeWeaverAware bean使得允许注册他们的转换器.</span></div><div class="line">		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">		<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</div><div class="line">			getBean(weaverAwareName);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 停止使用临时类加载器进行类型匹配</span></div><div class="line">		beanFactory.setTempClassLoader(<span class="keyword">null</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 允许缓存所有bean定义元数据,而不期待进一步的改变</span></div><div class="line">		beanFactory.freezeConfiguration();</div><div class="line"></div><div class="line">		<span class="comment">// 实例化所有剩余(non-lazy-init)单.</span></div><div class="line">		beanFactory.preInstantiateSingletons();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第十二步<br>finishRefresh()发布相关事件。实际上在我们的demo里这里只做了默认工作，暂不详细说明。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 完成上下文的刷新，调用LifecycleProcessor的onRefresh，发布ContextRefreshedEvent事件</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 初始化生命期处理器</span></div><div class="line">		initLifecycleProcessor();</div><div class="line"></div><div class="line">		<span class="comment">// 向生命周期处理器传播刷新</span></div><div class="line">		getLifecycleProcessor().onRefresh();</div><div class="line"></div><div class="line">		<span class="comment">// 发布最后的时间</span></div><div class="line">		publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</div><div class="line"></div><div class="line">		<span class="comment">// 如果活跃，参与LiveBeansView MBean</span></div><div class="line">		LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>已经将refresh()其余的工作做了简单的分析，真的很复杂的一个框架，其中finishBeanFactoryInitialization(beanFactory)比较复杂，期待下回分析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手码不易，转载请注明：&lt;a href=&quot;http://www.bugpointer.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BUG指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接上篇日志&lt;a href=&quot;http://www.bugpointer.com/a
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 使用简单Demo进行源码调试（四）</title>
    <link href="http://yoursite.com/2015/05/11/Spring%20%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95Demo%E8%BF%9B%E8%A1%8C%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2015/05/11/Spring 使用简单Demo进行源码调试（四）/</id>
    <published>2015-05-10T23:24:09.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>手码不易，转载请注明：<a href="http://www.bugpointer.com/" target="_blank" rel="external">BUG指南</a></p>
<p>接上篇日志<a href="http://www.bugpointer.com/archives/508.html" target="_blank" rel="external">Spring 使用简单Demo进行源码调试（三）</a>继续。</p>
<p>第一步<br>展开loadBeanDefinitions(resources)。这个代码比较简单，是对每一个资源进行加载。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">	Assert.notNull(resources, &amp;quot;Resource array must not be <span class="keyword">null</span>&amp;quot;);</div><div class="line">	<span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (Resource resource : resources) &#123;</div><div class="line">		counter += loadBeanDefinitions(resource);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>展开loadBeanDefinitions(resource)。这一步为从特定的XML文件中加载bean factory，使用EncodedResource包装传来的resource，然后进一步加载。EncodedResource结合特定编码的资源描述符或特定字符集用于阅读资源，这里的资源描述符和特定字符集都为。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 从特定的XML文件中加载bean factory</div><div class="line">	public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</div><div class="line">		return loadBeanDefinitions(new EncodedResource(resource));</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第二步<br>展开 loadBeanDefinitions(new EncodedResource(resource));。这一步从encodedResource获取读入流，然后设置编码，最后通过doLoadBeanDefinitions(inputSource, encodedResource.getResource())进一步解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 从特定的XML文件中加载bean factory</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">		Assert.notNull(encodedResource, &amp;quot;EncodedResource must not be <span class="keyword">null</span>&amp;quot;);</div><div class="line">		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">			logger.info(&amp;quot;Loading XML bean definitions from &amp;quot; + encodedResource.getResource());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Set&amp;lt;EncodedResource&amp;gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</div><div class="line">		<span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</div><div class="line">			currentResources = <span class="keyword">new</span> HashSet&amp;lt;EncodedResource&amp;gt;(<span class="number">4</span>);</div><div class="line">			<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">					&amp;quot;Detected cyclic loading of &amp;quot; + encodedResource + &amp;quot; - check your <span class="keyword">import</span> definitions!&amp;quot;);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			InputStream inputStream = encodedResource.getResource().getInputStream();</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</div><div class="line">				<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</div><div class="line">					inputSource.setEncoding(encodedResource.getEncoding());</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">finally</span> &#123;</div><div class="line">				inputStream.close();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">					&amp;quot;IOException parsing XML document from &amp;quot; + encodedResource.getResource(), ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">finally</span> &#123;</div><div class="line">			currentResources.remove(encodedResource);</div><div class="line">			<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</div><div class="line">				<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>第三步<br>展开doLoadBeanDefinitions(inputSource, encodedResource.getResource())。这一步初始化Document实例，然后通过registerBeanDefinitions(doc, resource)注册bean定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 实际的从特定的XML文件中加载bean factory</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></div><div class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">int</span> validationMode = getValidationModeForResource(resource);</div><div class="line">			Document doc = <span class="keyword">this</span>.documentLoader.loadDocument(</div><div class="line">					inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler, validationMode, isNamespaceAware());</div><div class="line">			<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> ex;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (SAXParseException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</div><div class="line">					&amp;quot;Line &amp;quot; + ex.getLineNumber() + &amp;quot; in XML document from &amp;quot; + resource + &amp;quot; is invalid&amp;quot;, ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (SAXException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</div><div class="line">					&amp;quot;XML document from &amp;quot; + resource + &amp;quot; is invalid&amp;quot;, ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</div><div class="line">					&amp;quot;Parser configuration exception parsing XML from &amp;quot; + resource, ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</div><div class="line">					&amp;quot;IOException parsing XML document from &amp;quot; + resource, ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</div><div class="line">					&amp;quot;Unexpected exception parsing XML document from &amp;quot; + resource, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第四步<br>展开registerBeanDefinitions(doc, resource)。这一步比较好理解，直接看documentReader.registerBeanDefinitions(doc, createReaderContext(resource))。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 使用DOM document注册bean定义.</div><div class="line">	 */</div><div class="line">	<span class="meta">@SuppressWarnings</span>(&amp;quot;deprecation&amp;quot;)</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</div><div class="line">		documentReader.setEnvironment(getEnvironment());</div><div class="line">		<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</div><div class="line">		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</div><div class="line">		<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第五步<br>展开documentReader.registerBeanDefinitions(doc, createReaderContext(resource))。还是比较简单，哎，看doRegisterBeanDefinitions(root)这一步吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 使用&amp;quot;spring-beans&amp;quot; XSD 或者 DTD 解析bean定义</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.readerContext = readerContext;</div><div class="line">		logger.debug(&amp;quot;Loading bean definitions&amp;quot;);</div><div class="line">		Element root = doc.getDocumentElement();</div><div class="line">		doRegisterBeanDefinitions(root);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第六步<br>展开doRegisterBeanDefinitions(root)。这一步使用Doc里的root元素注册每一个bean定义。使用createDelegate的原因是任何嵌套的&lt; bean&gt;元素将导致该方法递归。为了传播和保存<bean> default-*属性正确,跟踪当前的(parent)delegate,这可能是null。为了后退创建一个引用到父delegate新的(child)delegate,最终重置delegate改回到原来（parent）引用。这种行为模拟一堆delegate，并不需要专门得类完成。最后通过预处理xml、解析bean定义和后处理xml完成注册bean定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Register each bean definition within the given root &#123;<span class="doctag">@code</span> &amp;lt;beans/&amp;gt;&#125; element.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</div><div class="line">		String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</div><div class="line">		<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</div><div class="line">			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</div><div class="line">					profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</div><div class="line">			<span class="keyword">if</span> (!getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</div><div class="line">		<span class="keyword">this</span>.delegate = createDelegate(<span class="keyword">this</span>.readerContext, root, parent);</div><div class="line"></div><div class="line">		preProcessXml(root);</div><div class="line">		parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</div><div class="line">		postProcessXml(root);</div><div class="line"></div><div class="line">		<span class="keyword">this</span>.delegate = parent;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></bean></p>
<p>第七步<br>展开parseBeanDefinitions(root, this.delegate)。这一步从文档的根元素解析文档。delegate.isDefaultNamespace(ele)这一步判断ele是不是默认命名域，这里的默认命名域为”<a href="http://www.springframework.org/schema/beans&quot;。如果ele是默认命名域则解析ele，即parseDefaultElement(ele" target="_blank" rel="external">http://www.springframework.org/schema/beans&quot;。如果ele是默认命名域则解析ele，即parseDefaultElement(ele</a>, delegate)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 从文档的根元素解析文档</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</div><div class="line">			NodeList nl = root.getChildNodes();</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; nl.getLength(); i++) &#123;</div><div class="line">				Node node = nl.item(i);</div><div class="line">				<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</div><div class="line">					Element ele = (Element) node;</div><div class="line">					<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</div><div class="line">						parseDefaultElement(ele, delegate);</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">else</span> &#123;</div><div class="line">						delegate.parseCustomElement(ele);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			delegate.parseCustomElement(root);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第八步<br>展开parseDefaultElement(ele, delegate)。可以看到，我们是BEAN_ELEMENT，所以走processBeanDefinition(ele, delegate);这一步。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</div><div class="line">			importBeanDefinitionResource(ele);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</div><div class="line">			processAliasRegistration(ele);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</div><div class="line">                        <span class="comment">//走这一步</span></div><div class="line">			processBeanDefinition(ele, delegate);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</div><div class="line">			<span class="comment">// recurse</span></div><div class="line">			doRegisterBeanDefinitions(ele);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第九步<br>展开processBeanDefinition(ele, delegate)。这一步首先使用bean元素定义了BeanDefinitionHolder实例bdHolder，目前不详细解析了，BeanDefinitionHolder包含BeanDefinition名和别名，可以注册为一个内部bean的占位符。然后如果需要则修饰Bean定义。最后通过BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry())注册bean定义，BeanDefinitionReaderUtils类包含了bean定义阅读接口实现时有用的工具方法。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 * 处理bean元素,解析bean定义并注册</div><div class="line">	 */ </div><div class="line">	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</div><div class="line">		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</div><div class="line">		if (bdHolder != null) &#123;</div><div class="line">			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</div><div class="line">			try &#123;</div><div class="line">				// Register the final decorated instance.</div><div class="line">				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</div><div class="line">			&#125;</div><div class="line">			catch (BeanDefinitionStoreException ex) &#123;</div><div class="line">				getReaderContext().error(&amp;quot;Failed to register bean definition with name '&amp;quot; +</div><div class="line">						bdHolder.getBeanName() + &amp;quot;'&amp;quot;, ele, ex);</div><div class="line">			&#125;</div><div class="line">			// Send registration event.</div><div class="line">			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第十步<br>展开BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry())。首先获取bean名称；然后通过registry注册bean定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 使用最初的bean factory注册bean定义</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></div><div class="line">			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</div><div class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</div><div class="line"></div><div class="line">		<span class="comment">// Register bean definition under primary name.</span></div><div class="line">		String beanName = definitionHolder.getBeanName();</div><div class="line">		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</div><div class="line"></div><div class="line">		<span class="comment">// Register aliases for bean name, if any.</span></div><div class="line">		String[] aliases = definitionHolder.getAliases();</div><div class="line">		<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">for</span> (String aliase : aliases) &#123;</div><div class="line">				registry.registerAlias(beanName, aliase);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第十一步<br>展开registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())。可以看到，这一步主要完成的工作有，bean定义校验、有旧定义是否可覆盖、添加新的bean定义。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</div><div class="line">		throws BeanDefinitionStoreException &#123;</div><div class="line"></div><div class="line">	Assert.hasText(beanName, &amp;quot;Bean name must not be empty&amp;quot;);</div><div class="line">	Assert.notNull(beanDefinition, &amp;quot;BeanDefinition must not be null&amp;quot;);</div><div class="line"></div><div class="line">	if (beanDefinition instanceof AbstractBeanDefinition) &#123;</div><div class="line">		try &#123;</div><div class="line">			((AbstractBeanDefinition) beanDefinition).validate();</div><div class="line">		&#125;</div><div class="line">		catch (BeanDefinitionValidationException ex) &#123;</div><div class="line">			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</div><div class="line">					&amp;quot;Validation of bean definition failed&amp;quot;, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	BeanDefinition oldBeanDefinition;</div><div class="line"></div><div class="line">	synchronized (this.beanDefinitionMap) &#123;</div><div class="line">		oldBeanDefinition = this.beanDefinitionMap.get(beanName);</div><div class="line">		if (oldBeanDefinition != null) &#123;</div><div class="line">			if (!this.allowBeanDefinitionOverriding) &#123;</div><div class="line">				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</div><div class="line">						&amp;quot;Cannot register bean definition [&amp;quot; + beanDefinition + &amp;quot;] for bean '&amp;quot; + beanName +</div><div class="line">						&amp;quot;': There is already [&amp;quot; + oldBeanDefinition + &amp;quot;] bound.&amp;quot;);</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				if (this.logger.isInfoEnabled()) &#123;</div><div class="line">					this.logger.info(&amp;quot;Overriding bean definition for bean '&amp;quot; + beanName +</div><div class="line">							&amp;quot;': replacing [&amp;quot; + oldBeanDefinition + &amp;quot;] with [&amp;quot; + beanDefinition + &amp;quot;]&amp;quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			this.beanDefinitionNames.add(beanName);</div><div class="line">			this.frozenBeanDefinitionNames = null;</div><div class="line">		&#125;</div><div class="line">		this.beanDefinitionMap.put(beanName, beanDefinition);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (oldBeanDefinition != null || containsSingleton(beanName)) &#123;</div><div class="line">		resetBeanDefinition(beanName);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此为止bean定义的加载已经完成。但是由于代码过于复杂，没有分析很多细节以及异常，仅仅是将主要的一条线理了出来，还是远远不够的。有机会在进行深入解析。接下来会继续分析我们的demo运行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手码不易，转载请注明：&lt;a href=&quot;http://www.bugpointer.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BUG指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接上篇日志&lt;a href=&quot;http://www.bugpointer.com/a
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 使用简单Demo进行源码调试（三）</title>
    <link href="http://yoursite.com/2015/05/11/Spring%20%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95Demo%E8%BF%9B%E8%A1%8C%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2015/05/11/Spring 使用简单Demo进行源码调试（三）/</id>
    <published>2015-05-10T18:45:38.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>手码不易，转载请注明：<a href="http://www.bugpointer.com/" target="_blank" rel="external">BUG指南</a></p>
<p>接上篇日志<a href="http://www.bugpointer.com/archives/505.html" target="_blank" rel="external">Spring 使用简单Demo进行源码调试（二）</a>继续。</p>
<p>上篇提到了主要的初始化函数refresh，函数源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">            <span class="comment">// 为了刷新准备上下文</span></div><div class="line">            prepareRefresh();</div><div class="line"></div><div class="line">            <span class="comment">// 利用子类完成内部bean factory的刷新</span></div><div class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class="line"></div><div class="line">            <span class="comment">// 使用本地上下文准备bean factory</span></div><div class="line">            prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 允许在上下文子类中完成bean factory后处理</span></div><div class="line">                postProcessBeanFactory(beanFactory);</div><div class="line"></div><div class="line">                <span class="comment">// 调用上下文注册的bean factory处理器</span></div><div class="line">                invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line"></div><div class="line">                <span class="comment">// 注册拦截bean创建的bean处理器</span></div><div class="line">                registerBeanPostProcessors(beanFactory);</div><div class="line"></div><div class="line">                <span class="comment">// 初始化上下文中消息源</span></div><div class="line">                initMessageSource();</div><div class="line"></div><div class="line">                <span class="comment">// 初始化上下文中的事件多播</span></div><div class="line">                initApplicationEventMulticaster();</div><div class="line"></div><div class="line">                <span class="comment">// 在特定上下文子类中初始化其他特殊bean</span></div><div class="line">                onRefresh();</div><div class="line"></div><div class="line">                <span class="comment">// 检查监听器bean并注册 </span></div><div class="line">                registerListeners();</div><div class="line"></div><div class="line">                <span class="comment">// 实例化所有剩余(non-lazy-init)单例</span></div><div class="line">                finishBeanFactoryInitialization(beanFactory);</div><div class="line"></div><div class="line">                <span class="comment">// 发布相应的事件</span></div><div class="line">                finishRefresh();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">                logger.warn(&amp;quot;Exception encountered during context initialization - cancelling refresh attempt&amp;quot;, ex);</div><div class="line"></div><div class="line">                <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></div><div class="line">                destroyBeans();</div><div class="line"></div><div class="line">                <span class="comment">// Reset 'active' flag.</span></div><div class="line">                cancelRefresh(ex);</div><div class="line"></div><div class="line">                <span class="comment">// Propagate exception to caller.</span></div><div class="line">                <span class="keyword">throw</span> ex;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>先把prepareRefresh的代码贴出来。这段代码主要功能是初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Prepare this context for refreshing, setting its startup date and</div><div class="line">	 * active flag as well as performing any initialization of property sources.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.startupDate = System.currentTimeMillis();</div><div class="line"></div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.activeMonitor) &#123;</div><div class="line">			<span class="keyword">this</span>.active = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">			logger.info(&amp;quot;Refreshing &amp;quot; + <span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Initialize any placeholder property sources in the context environment</span></div><div class="line">		initPropertySources();</div><div class="line"></div><div class="line">		<span class="comment">// Validate that all properties marked as required are resolvable</span></div><div class="line">		<span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></div><div class="line">		getEnvironment().validateRequiredProperties();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这块基本是数据准备功能， 目前这一块没有实际用到。<br>接着我们看比较重要的一步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用子类完成内部bean factory的刷新</span></div><div class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div></pre></td></tr></table></figure></p>
<p>先展开obtainFreshBeanFactory函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Tell the subclass to refresh the internal bean factory.</div><div class="line">         * 使用子类完成内部bean factory</div><div class="line">	 * <span class="doctag">@return</span> the fresh BeanFactory instance</div><div class="line">	 * <span class="doctag">@see</span> #refreshBeanFactory()</div><div class="line">	 * <span class="doctag">@see</span> #getBeanFactory()</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">		refreshBeanFactory();</div><div class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</div><div class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(&amp;quot;Bean factory <span class="keyword">for</span> &amp;quot; + getDisplayName() + &amp;quot;: &amp;quot; + beanFactory);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> beanFactory;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>我们主要看refreshBeanFactory()这一步,分为以下步骤：<br>1. 如果有bean factory，删除之；<br>2. 新建一个bean factory；<br>3. 设置一个序列化Id；<br>4. 使用的上下文自定义内部bean factory；<br>5. 加载bean 定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * This implementation performs an actual refresh of this context's underlying</div><div class="line">	 * bean factory, shutting down the previous bean factory (if any) and</div><div class="line">	 * initializing a fresh bean factory for the next phase of the context's lifecycle.</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (hasBeanFactory()) &#123;</div><div class="line">			destroyBeans();</div><div class="line">			closeBeanFactory();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			DefaultListableBeanFactory beanFactory = createBeanFactory();</div><div class="line">			beanFactory.setSerializationId(getId());</div><div class="line">			customizeBeanFactory(beanFactory);</div><div class="line">			loadBeanDefinitions(beanFactory);</div><div class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</div><div class="line">				<span class="keyword">this</span>.beanFactory = beanFactory;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(&amp;quot;I/O error parsing bean definition source <span class="keyword">for</span> &amp;quot; + getDisplayName(), ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>现在看一下第5步，加载bean定义，其实现如下。可以看到，这一步将beanFactory传入XmlBeanDefinitionReader的构造函数，新建一个XmlBeanDefinitionReader对象，然后对其环境进行设置。其中Environment表示当前应用程序运行的环境接口；ResourceLoader表示加载资源策略接口；EntityResolver表示实体解析接口。最后初始化XmlBeanDefinitionReader对象，然后使用这个对象加载bean 定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Loads the bean definitions via an XmlBeanDefinitionReader.</div><div class="line">	 * <span class="doctag">@see</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader</div><div class="line">	 * <span class="doctag">@see</span> #initBeanDefinitionReader</div><div class="line">	 * <span class="doctag">@see</span> #loadBeanDefinitions</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</div><div class="line">		<span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></div><div class="line">		XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</div><div class="line"></div><div class="line">		<span class="comment">// Configure the bean definition reader with this context's</span></div><div class="line">		<span class="comment">// resource loading environment.</span></div><div class="line">		beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</div><div class="line">		beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</div><div class="line">		beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</div><div class="line"></div><div class="line">		<span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></div><div class="line">		<span class="comment">// then proceed with actually loading the bean definitions.</span></div><div class="line">		initBeanDefinitionReader(beanDefinitionReader);</div><div class="line">		loadBeanDefinitions(beanDefinitionReader);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>再看下一步，这个方法比较好理解，就是使用已有的配置资源或者配置文件进行加载，当前没有配置资源，所以只使用配置文件进行加载。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 使用XmlBeanDefinitionReader实例加载bean定义</div><div class="line">	 * <span class="doctag">@param</span> reader the XmlBeanDefinitionReader to use</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</div><div class="line">		Resource[] configResources = getConfigResources();</div><div class="line">		<span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</div><div class="line">			reader.loadBeanDefinitions(configResources);</div><div class="line">		&#125;</div><div class="line">		String[] configLocations = getConfigLocations();</div><div class="line">		<span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</div><div class="line">			reader.loadBeanDefinitions(configLocations);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>来看reader.loadBeanDefinitions(configLocations);这一步。这一步看起来很复杂，但最主要的还是loadBeanDefinitions(resources)这一步。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 使用配置文件加载bean定义	</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&amp;lt;Resource&amp;gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">		ResourceLoader resourceLoader = getResourceLoader();</div><div class="line">		<span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">					&amp;quot;Cannot <span class="keyword">import</span> bean definitions from location [&amp;quot; + location + &amp;quot;]: no ResourceLoader available&amp;quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</div><div class="line">			<span class="comment">// Resource pattern matching available.</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</div><div class="line">				<span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</div><div class="line">				<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</div><div class="line">					<span class="keyword">for</span> (Resource resource : resources) &#123;</div><div class="line">						actualResources.add(resource);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">					logger.debug(&amp;quot;Loaded &amp;quot; + loadCount + &amp;quot; bean definitions from location pattern [&amp;quot; + location + &amp;quot;]&amp;quot;);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> loadCount;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">						&amp;quot;Could not resolve bean definition resource pattern [&amp;quot; + location + &amp;quot;]&amp;quot;, ex);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// Can only load single resources by absolute URL.</span></div><div class="line">			Resource resource = resourceLoader.getResource(location);</div><div class="line">			<span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</div><div class="line">			<span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</div><div class="line">				actualResources.add(resource);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&amp;quot;Loaded &amp;quot; + loadCount + &amp;quot; bean definitions from location [&amp;quot; + location + &amp;quot;]&amp;quot;);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> loadCount;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下一回展开loadBeanDefinitions(resources)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手码不易，转载请注明：&lt;a href=&quot;http://www.bugpointer.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BUG指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接上篇日志&lt;a href=&quot;http://www.bugpointer.com/a
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 使用简单Demo进行源码调试（二）</title>
    <link href="http://yoursite.com/2015/05/09/Spring%20%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95Demo%E8%BF%9B%E8%A1%8C%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2015/05/09/Spring 使用简单Demo进行源码调试（二）/</id>
    <published>2015-05-09T02:22:48.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>手码不易，转载请注明：<a href="http://www.bugpointer.com/" target="_blank" rel="external">BUG指南</a></p>
<p>接上一篇文章 <a href="http://www.bugpointer.com/archives/491.html" target="_blank" rel="external">Spring 使用简单Demo进行源码调试（一）</a></p>
<p>在运行到下面语句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(&amp;quot;bean.xml&amp;quot;);<span class="comment">// 读取bean.xml中的内容</span></div></pre></td></tr></table></figure></p>
<p>该构造函数首先进入下面ClassPathXmlApplicationContext类中这段代码。代码中configLocations为我们的配置文件，及[bean.xml]；refresh表示是否刷新，这里为true，表示刷新配置；parent表示上级上下文，这里为null表示没有上级上下文。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 使用上一级上下文创建新的ClassPathXmlApplicationContext,</div><div class="line">	 * 从XML中加载定义</div><div class="line">	 * <span class="doctag">@param</span> configLocations 资源地址列表</div><div class="line">	 * <span class="doctag">@param</span> refresh 是否刷新上下文,</div><div class="line">	 * <span class="doctag">@param</span> parent 上一级上下文</div><div class="line">	 */</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></div><div class="line">			<span class="keyword">throws</span> BeansException &#123;			</div><div class="line">		<span class="comment">//parent = null;</span></div><div class="line">		<span class="comment">//refresh= true;</span></div><div class="line">		<span class="comment">//configLocations=[bean.xml];</span></div><div class="line">		<span class="keyword">super</span>(parent);</div><div class="line">		setConfigLocations(configLocations);</div><div class="line">		<span class="keyword">if</span> (refresh) &#123;</div><div class="line">			refresh();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>下面是抽象函数AbstractRefreshableConfigApplicationContext中setConfigLocations方法。该方法为设置配置文件，及将[bean.xml]设置为本地的this.configLocations属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * 为应用的上下文设置配置地址.</div><div class="line">	 * 如果没有设置,会使用默认的配置</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String[] locations)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</div><div class="line">			Assert.noNullElements(locations, &amp;quot;Config locations must not be <span class="keyword">null</span>&amp;quot;);</div><div class="line">			<span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; locations.length; i++) &#123;</div><div class="line">				<span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>接着是refresh函数，该函数在AbstractApplicationContext类中，代码如下。可以看到该函数一共分为以下几步：<br>1. 为了刷新准备上下文；<br>2. 利用子类完成内部bean factory的刷新；<br>3. 使用本地上下文准备bean factory；<br>4. 允许在上下文子类中完成bean factory后处理；<br>5. 调用上下文注册的bean factory处理器；<br>6. 注册拦截bean创建的bean处理器；<br>7. 初始化上下文中消息源；<br>8. 初始化上下文中的事件多播；<br>9. 在特定上下文子类中初始化其他特殊bean；<br>10. 检查监听器bean并注册；<br>11. 实例化所有剩余(non-lazy-init)单例；<br>12. 发布相应的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">			<span class="comment">// 为了刷新准备上下文</span></div><div class="line">			prepareRefresh();</div><div class="line"></div><div class="line">			<span class="comment">// 利用子类完成内部bean factory的刷新</span></div><div class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class="line"></div><div class="line">			<span class="comment">// 使用本地上下文准备bean factory</span></div><div class="line">			prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="comment">// 允许在上下文子类中完成bean factory后处理</span></div><div class="line">				postProcessBeanFactory(beanFactory);</div><div class="line"></div><div class="line">				<span class="comment">// 调用上下文注册的bean factory处理器</span></div><div class="line">				invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line"></div><div class="line">				<span class="comment">// 注册拦截bean创建的bean处理器</span></div><div class="line">				registerBeanPostProcessors(beanFactory);</div><div class="line"></div><div class="line">				<span class="comment">// 初始化上下文中消息源</span></div><div class="line">				initMessageSource();</div><div class="line"></div><div class="line">				<span class="comment">// 初始化上下文中的事件多播</span></div><div class="line">				initApplicationEventMulticaster();</div><div class="line"></div><div class="line">				<span class="comment">// 在特定上下文子类中初始化其他特殊bean</span></div><div class="line">				onRefresh();</div><div class="line"></div><div class="line">				<span class="comment">// 检查监听器bean并注册 </span></div><div class="line">				registerListeners();</div><div class="line"></div><div class="line">				<span class="comment">// 实例化所有剩余(non-lazy-init)单例</span></div><div class="line">				finishBeanFactoryInitialization(beanFactory);</div><div class="line"></div><div class="line">				<span class="comment">// 发布相应的事件</span></div><div class="line">				finishRefresh();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">				logger.warn(&amp;quot;Exception encountered during context initialization - cancelling refresh attempt&amp;quot;, ex);</div><div class="line"></div><div class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></div><div class="line">				destroyBeans();</div><div class="line"></div><div class="line">				<span class="comment">// Reset 'active' flag.</span></div><div class="line">				cancelRefresh(ex);</div><div class="line"></div><div class="line">				<span class="comment">// Propagate exception to caller.</span></div><div class="line">				<span class="keyword">throw</span> ex;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这里的每一步可能都很繁琐，鉴于我也是第一次看这些代码，还是慢慢进行分析吧，先到这里。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手码不易，转载请注明：&lt;a href=&quot;http://www.bugpointer.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BUG指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接上一篇文章 &lt;a href=&quot;http://www.bugpointer.com
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 使用简单Demo进行源码调试（一）</title>
    <link href="http://yoursite.com/2015/05/08/Spring%20%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95Demo%E8%BF%9B%E8%A1%8C%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2015/05/08/Spring 使用简单Demo进行源码调试（一）/</id>
    <published>2015-05-07T22:33:01.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>手码不易，转载请注明：<a href="http://www.bugpointer.com/" target="_blank" rel="external">BUG指南</a></p>
<p><strong>第一步</strong><br>在源码调试之前，需要将spring源码进行编译，这里选择的是3.2.x版本，这个版本在导入eclipse都会出现bug，但是不影响目前的调试。</p>
<p><strong>第二步</strong><br>将编译后的源码导入eclispe，如下图所示：<br><img src="/images/spring源码导入eclipse-242x300.png" alt="spring源码导入eclipse"><br>可以看到有两个工程报错，分别是spring—orm-hibernate4和spring-webmvc-tiles3，暂且不去管它，因为目前不会影响到后续的源码调试。</p>
<p><strong>第三步</strong><br>新建一个工程，Test，然后右键该工程，选择Build path -》 Configure Build Path…，然后把当前所有的没有报错的工程加入到Projects里，如下图所示：<br><img src="/images/加入未报错工程-300x234.png" alt="加入未报错工程"></p>
<p>新建一个pojo类，Animal，代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.bean;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(&amp;quot;name:&amp;quot; + getName() + &amp;quot; age:&amp;quot; + getAge());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">```java</div><div class="line"></div><div class="line">新建一个Main类，代码如下：</div><div class="line">```java</div><div class="line"><span class="keyword">package</span> com.test.bean;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(&amp;quot;bean.xml&amp;quot;);<span class="comment">// 读取bean.xml中的内容</span></div><div class="line">		Animal a = ctx.getBean(&amp;quot;animal&amp;quot;, Animal.class);<span class="comment">// 创建bean的引用对象</span></div><div class="line">		a.info();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新建一个bean.xml，代码如下：<br><code>xml
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
    xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
    xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&amp;quot;&amp;gt;
    &amp;lt;bean id=&amp;quot;animal&amp;quot; class=&amp;quot;com.test.bean.Animal&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;mao&amp;quot; /&amp;gt;
        &amp;lt;property name=&amp;quot;age&amp;quot; value=&amp;quot;12&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;</code>xml</p>
<p>第四部，运行Main.java，可以看到如下运行结果：<br><img src="/images/运行结果-300x69.png" alt="运行结果"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手码不易，转载请注明：&lt;a href=&quot;http://www.bugpointer.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BUG指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;&lt;br&gt;在源码调试之前，需要将spring
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/Spring/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>java实现文件操作</title>
    <link href="http://yoursite.com/2015/05/04/java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2015/05/04/java实现文件操作/</id>
    <published>2015-05-04T01:57:38.000Z</published>
    <updated>2016-08-23T03:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.java实现文件复制、剪切文件和删除<br>[java]<br>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.FileOutputStream;<br>import java.io.IOException;</p>
<p>/**</p>
<ul>
<li>Java实现文件复制、剪切、删除操作</li>
<li>文件指文件或文件夹</li>
<li>文件分割符统一用&quot;\&quot;<br>*/</li>
</ul>
<p>public class FileOperateDemo {</p>
<pre><code>/**
 * 复制文件或文件夹
 * @param srcPath 源文件或源文件夹的路径
 * @param destDir 目标文件所在的目录
 * @return
 */
public static boolean copyGeneralFile(String srcPath, String destDir) {
    boolean flag = false;
    File file = new File(srcPath);
    if(!file.exists()) { // 源文件或源文件夹不存在
        return false;
    }

    if(file.isFile()) {    // 文件复制
        flag = copyFile(srcPath, destDir);
    }
    else if(file.isDirectory()) { // 文件夹复制
        flag = copyDirectory(srcPath, destDir);
    }

    return flag;
}

/**
 * 默认的复制文件方法，默认会覆盖目标文件夹下的同名文件
 * @param srcPath
 *            源文件绝对路径
 * @param destDir
 *            目标文件所在目录
 * @return boolean
 */
public static boolean copyFile(String srcPath, String destDir) {
 return copyFile(srcPath, destDir, true/**overwriteExistFile*/); // 默认覆盖同名文件
}

/**
 * 默认的复制文件夹方法，默认会覆盖目标文件夹下的同名文件夹
 * @param srcPath    源文件夹路径
 * @param destPath    目标文件夹所在目录
 * @return boolean
 */
public static boolean copyDirectory(String srcPath, String destDir) {
 return copyDirectory(srcPath, destDir, true/**overwriteExistDir*/);
}

/**
 * 复制文件到目标目录
 * @param srcPath
 *            源文件绝对路径
 * @param destDir
 *            目标文件所在目录
 * @param overwriteExistFile
 *            是否覆盖目标目录下的同名文件
 * @return boolean
 */
public static boolean copyFile(String srcPath, String destDir, boolean overwriteExistFile) {
    boolean flag = false;

    File srcFile = new File(srcPath);
    if (!srcFile.exists() || !srcFile.isFile()) { // 源文件不存在
        return false;
    }

    //获取待复制文件的文件名
    String fileName = srcFile.getName();
    String destPath = destDir + File.separator +fileName;
    File destFile = new File(destPath);
    if (destFile.getAbsolutePath().equals(srcFile.getAbsolutePath())) { // 源文件路径和目标文件路径重复
        return false;
    }
    if(destFile.exists() &amp;amp;&amp;amp; !overwriteExistFile) {    // 目标目录下已有同名文件且不允许覆盖
        return false;
    }

    File destFileDir = new File(destDir);
    if(!destFileDir.exists() &amp;amp;&amp;amp; !destFileDir.mkdirs()) { // 目录不存在并且创建目录失败直接返回
     return false;
    }

    try {
        FileInputStream fis = new FileInputStream(srcPath);
        FileOutputStream fos = new FileOutputStream(destFile);
        byte[] buf = new byte[1024];
        int c;
        while ((c = fis.read(buf)) != -1) {
            fos.write(buf, 0, c);
        }
        fos.flush();
        fis.close();
        fos.close();

        flag = true;
    } catch (IOException e) {
        e.printStackTrace();
    }

    return flag;
}

/**
 * 
 * @param srcPath    源文件夹路径
 * @param destPath    目标文件夹所在目录
 * @return
 */
public static boolean copyDirectory(String srcPath, String destDir, boolean overwriteExistDir) {
    if(destDir.contains(srcPath))
       return false;
    boolean flag = false;

    File srcFile = new File(srcPath);
    if (!srcFile.exists() || !srcFile.isDirectory()) { // 源文件夹不存在
        return false;
    }

    //获得待复制的文件夹的名字，比如待复制的文件夹为&amp;quot;E:\\dir\\&amp;quot;则获取的名字为&amp;quot;dir&amp;quot;
    String dirName = srcFile.getName();

    //目标文件夹的完整路径
    String destDirPath = destDir + File.separator + dirName + File.separator;
    File destDirFile = new File(destDirPath);
    if(destDirFile.getAbsolutePath().equals(srcFile.getAbsolutePath())) {
     return false;
    }
    if(destDirFile.exists() &amp;amp;&amp;amp; destDirFile.isDirectory() &amp;amp;&amp;amp; !overwriteExistDir) {    // 目标位置有一个同名文件夹且不允许覆盖同名文件夹，则直接返回false
        return false;
    }

    if(!destDirFile.exists() &amp;amp;&amp;amp; !destDirFile.mkdirs()) {  // 如果目标目录不存在并且创建目录失败
     return false;
    }

    File[] fileList = srcFile.listFiles();    //获取源文件夹下的子文件和子文件夹
    if(fileList.length==0) {    // 如果源文件夹为空目录则直接设置flag为true，这一步非常隐蔽，debug了很久
        flag = true;
    }
    else {
        for(File temp: fileList) {
            if(temp.isFile()) {    // 文件
                flag = copyFile(temp.getAbsolutePath(), destDirPath, overwriteExistDir);     // 递归复制时也继承覆盖属性
            }
            else if(temp.isDirectory()) {    // 文件夹
                flag = copyDirectory(temp.getAbsolutePath(), destDirPath, overwriteExistDir);   // 递归复制时也继承覆盖属性
            }

            if(!flag) {
                break;
            }
        }
    }

    return flag;
}

/**
 * 删除文件或文件夹
 * @param path
 *            待删除的文件的绝对路径
 * @return boolean
 */
public static boolean deleteFile(String path) {
    boolean flag = false;

    File file = new File(path);
    if (!file.exists()) { // 文件不存在直接返回
        return flag;
    }
    flag = file.delete();

    return flag;
}

/**
 * 由上面方法延伸出剪切方法：复制+删除
 * @param  destDir 同上
 */
public static boolean cutGeneralFile(String srcPath, String destDir) {
 boolean flag = false;
    if(copyGeneralFile(srcPath, destDir) &amp;amp;&amp;amp; deleteFile(srcPath)) { // 复制和删除都成功
     flag = true;
    }

    return flag;
}

public static void main(String[] args) {
 /** 测试复制文件 */
 System.out.println(copyGeneralFile(&amp;quot;d://test/test.html&amp;quot;, &amp;quot;d://test/test/&amp;quot;));  // 一般正常场景
 System.out.println(copyGeneralFile(&amp;quot;d://notexistfile&amp;quot;, &amp;quot;d://test/&amp;quot;));      // 复制不存在的文件或文件夹
 System.out.println(copyGeneralFile(&amp;quot;d://test/test.html&amp;quot;, &amp;quot;d://test/&amp;quot;));      // 待复制文件与目标文件在同一目录下
 System.out.println(copyGeneralFile(&amp;quot;d://test/test.html&amp;quot;, &amp;quot;d://test/test/&amp;quot;));  // 覆盖目标目录下的同名文件
 System.out.println(copyFile(&amp;quot;d://test/&amp;quot;, &amp;quot;d://test2&amp;quot;, false)); // 不覆盖目标目录下的同名文件
 System.out.println(copyGeneralFile(&amp;quot;d://test/test.html&amp;quot;, &amp;quot;notexist://noexistdir/&amp;quot;)); // 复制文件到一个不可能存在也不可能创建的目录下

 System.out.println(&amp;quot;---------&amp;quot;);

 /** 测试复制文件夹 */
 System.out.println(copyGeneralFile(&amp;quot;d://test/&amp;quot;, &amp;quot;d://test2/&amp;quot;));

 System.out.println(&amp;quot;---------&amp;quot;);

 /** 测试删除文件 */
 System.out.println(deleteFile(&amp;quot;d://a/&amp;quot;));
}
</code></pre><p>}<br>[/java]</p>
<p>2.验证传入路径是否为正确的路径名(Windows系统，其他系统未使用)<br>[java]<br>// 验证字符串是否为正确路径名的正则表达式<br>private static String matches = &quot;[A-Za-z]:\\[^:?\&quot;&gt;&lt;<em>]</em>&quot;;<br>// 通过 sPath.matches(matches) 方法的返回值判断是否正确<br>// sPath 为路径字符串<br>[/java]</p>
<p>3.通用的文件夹或文件删除方法，直接调用此方法，即可实现删除文件夹或文件，包括文件夹下的所有文件<br>[java]<br>/** </p>
<ul>
<li>根据路径删除指定的目录或文件，无论存在与否<br><em>@param sPath  要删除的目录或文件 
</em>@return 删除成功返回 true，否则返回 false。<br>*/<br>public boolean DeleteFolder(String sPath) {<br>flag = false;<br>file = new File(sPath);<br>// 判断目录或文件是否存在<br>if (!file.exists()) {  // 不存在返回 false  <pre><code>return flag;  
</code></pre>} else {  <pre><code>// 判断是否为文件  
if (file.isFile()) {  // 为文件时调用删除文件方法  
    return deleteFile(sPath);  
} else {  // 为目录时调用删除目录方法  
    return deleteDirectory(sPath);  
}  
</code></pre>}<br>}<br>[/java]</li>
</ul>
<p>4.实现删除文件的方法，<br>[java]<br>/** </p>
<ul>
<li>删除单个文件 </li>
<li>@param   sPath    被删除文件的文件名 </li>
<li>@return 单个文件删除成功返回true，否则返回false<br>*/<br>public boolean deleteFile(String sPath) {<br> flag = false;<br> file = new File(sPath);<br> // 路径为文件且不为空则进行删除<br> if (file.isFile() &amp;&amp; file.exists()) {  <pre><code>file.delete();  
flag = true;  
</code></pre> }<br> return flag;<br>}<br>[/java]</li>
</ul>
<p>5.实现删除文件夹的方法，<br>[java]<br>/** </p>
<ul>
<li>删除目录（文件夹）以及目录下的文件 </li>
<li>@param   sPath 被删除目录的文件路径 </li>
<li>@return  目录删除成功返回true，否则返回false<br>*/<br>public boolean deleteDirectory(String sPath) {<br> //如果sPath不以文件分隔符结尾，自动添加文件分隔符<br> if (!sPath.endsWith(File.separator)) {  <pre><code>sPath = sPath + File.separator;  
</code></pre> }<br> File dirFile = new File(sPath);<br> //如果dir对应的文件不存在，或者不是一个目录，则退出<br> if (!dirFile.exists() || !dirFile.isDirectory()) {  <pre><code>return false;  
</code></pre> }<br> flag = true;<br> //删除文件夹下的所有文件(包括子目录)<br> File[] files = dirFile.listFiles();<br> for (int i = 0; i &lt; files.length; i++) {  <pre><code>//删除子文件  
if (files[i].isFile()) {  
    flag = deleteFile(files[i].getAbsolutePath());  
    if (!flag) break;  
} //删除子目录  
else {  
    flag = deleteDirectory(files[i].getAbsolutePath());  
    if (!flag) break;  
}  
</code></pre> }<br> if (!flag) return false;<br> //删除当前目录<br> if (dirFile.delete()) {  <pre><code>return true;  
</code></pre> } else {  <pre><code>return false;  
</code></pre> }<br>}<br>[/java] </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.java实现文件复制、剪切文件和删除&lt;br&gt;[java]&lt;br&gt;import java.io.File;&lt;br&gt;import java.io.FileInputStream;&lt;br&gt;import java.io.FileOutputStream;&lt;br&gt;import j
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
